<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="TOOLS" directorySegmentName="seg_0" id="E0E6AA71-A2D7-6B23-4C5F-C0BCD7A9E30F">
<sourceConnName>codesys12</sourceConnName>
<sourceObjSchema>CODESYS</sourceObjSchema>
<sourceObjName>TOOLS</sourceObjName>
<createdBy>Simon</createdBy>
<createdTime>2015-10-27 07:11:21 UTC</createdTime>
<ownerDesignName>ManagedColumns</ownerDesignName>
<owner>CD237EE0-EC38-4CFB-299A-D68C1EE5DB10</owner>
<source>CREATE OR REPLACE Package CODESYS.TOOLS&lt;br/&gt;AUTHID CURRENT_USER&lt;br/&gt;Is&lt;br/&gt;&lt;br/&gt;   TYPE T_Strings IS TABLE OF VARCHAR2(4000);&lt;br/&gt;&lt;br/&gt;   Function isCompound( p_sdo_elem_info in mdsys.sdo_elem_info_array )&lt;br/&gt;     return integer deterministic;&lt;br/&gt;&lt;br/&gt;   /*** @function    Execute_Statement&lt;br/&gt;   **   @description Executes a SQL statement capturing errors.&lt;br/&gt;   **   @param       p_sql     The SQL statement to be executed.&lt;br/&gt;   **   @param       p_display Whether to write any errors to dbms_output.&lt;br/&gt;   **/&lt;br/&gt;   Procedure Execute_Statement( p_sql     IN VarChar2,&lt;br/&gt;                                p_display IN Boolean := FALSE);&lt;br/&gt;&lt;br/&gt;   /*** @function    GeometryCheck&lt;br/&gt;   **   @description Procedure that processes the supplied object looking&lt;br/&gt;   **                for errors and correcting where possible.&lt;br/&gt;   **                Writes activity to FEATURE_ERRORS table.&lt;br/&gt;   **   @param       p_schema      The owner of the table/geometry column data.&lt;br/&gt;   **   @param       p_tableName   The table holding the geometry data to be checked.&lt;br/&gt;   **   @param       p_ColumnName  The sdo_geometry column in the table to be checked.&lt;br/&gt;   **   @param       p_whereClause A predicate to limit the activity to specific rows.&lt;br/&gt;   **/&lt;br/&gt;   Procedure GeometryCheck( p_schema        IN VarChar2,&lt;br/&gt;                            p_tableName     IN VarChar2,&lt;br/&gt;                            p_ColumnName    IN VarChar2,&lt;br/&gt;                            p_whereClause   IN VarChar2);&lt;br/&gt;&lt;br/&gt;   /** @function    VertexAnalyzer&lt;br/&gt;   *   @description Function that computes basic statistics about the geometries in a table.&lt;br/&gt;   *   The stats computed are:&lt;br/&gt;   *     - Max,&lt;br/&gt;   *     - Min&lt;br/&gt;   *     - Avg number of vertices.&lt;br/&gt;   * @param p_owner       Schema that owns the table.&lt;br/&gt;   * @param p_table_regex Regular expression of the tables to be processed.&lt;br/&gt;   **/&lt;br/&gt;   Procedure VertexAnalyzer( p_owner       In VarChar2 := NULL,&lt;br/&gt;                             p_table_regex IN VarChar2 := &apos;*&apos;,&lt;br/&gt;                             p_activity    In Out NoCopy codesys.TOOLS.T_Strings );&lt;br/&gt;&lt;br/&gt;   /** @function    hasData&lt;br/&gt;   *   @description Simply checks if the table has any data in it.&lt;br/&gt;   *   @param       p_table_name : varchar2 : Object name.&lt;br/&gt;   *   @param       p_owner      : varchar2 : The schema that holds the table.&lt;br/&gt;   */&lt;br/&gt;   Function hasData( p_table_name In VarChar2,&lt;br/&gt;                     p_owner      In VarChar2 := NULL)&lt;br/&gt;     Return Boolean Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    Generate_Object_Name&lt;br/&gt;   *   @description Generates index/constraint name following a fixed pattern.&lt;br/&gt;   *   @param       p_object_name   : varchar2 : Object name normally a table.&lt;br/&gt;   *   @param       p_column_name   : varchar2 : Normally the name of a column.&lt;br/&gt;   *   @param       p_obj_shortname : varchar2 : An abbreviation of the object&lt;br/&gt;   *   @param       p_col_shortname : varchar2 : An abbreviation of the column&lt;br/&gt;   *   @param       p_prefix        : varchar2 : A prefix normally of a few chars in length.&lt;br/&gt;   *   @param       p_suffix        : varchar2 : A suffix normally of a few chars in length.&lt;br/&gt;   *   @param       p_name_length   : varchar2 : Max length of the desired name.&lt;br/&gt;   **/&lt;br/&gt;   Function Generate_Object_Name ( p_object_name   IN VARCHAR2,&lt;br/&gt;                                   p_column_name   IN VARCHAR2,&lt;br/&gt;                                   p_obj_shortname IN VARCHAR2,&lt;br/&gt;                                   p_col_shortname IN VARCHAR2,&lt;br/&gt;                                   p_prefix        IN VARCHAR2,&lt;br/&gt;                                   p_suffix        IN VARCHAR2,&lt;br/&gt;                                   p_name_length   IN PLS_INTEGER := 30 )&lt;br/&gt;     Return VarChar2 Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    NonLeaf_Spatial_IndexName&lt;br/&gt;   *   @description Gets name of Spatal Index NonLeaf component as well as its size.&lt;br/&gt;   *   @param       p_spindex_name : varchar2 : The user&apos;s name of the spatial index.&lt;br/&gt;   *   @param       p_nl_size      : NUMBER : The size of the non-leaf index.&lt;br/&gt;   *   @param       p_owner        : varchar2 : The schema that owns the object.&lt;br/&gt;   *   @param       p_pin          : boolean : Flag saying whether to pin the index in memory.&lt;br/&gt;   */&lt;br/&gt;   Function NonLeaf_Spatial_IndexName( p_spindex_name IN VARCHAR2,&lt;br/&gt;                                       p_nl_size      In Out NoCopy Number,&lt;br/&gt;                                       p_owner        In VarChar2 := NULL,&lt;br/&gt;                                       p_pin          In BOOLEAN  := FALSE )&lt;br/&gt;     Return VarChar2 Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    Discover_SpatialType&lt;br/&gt;   *   @description Processes table/sdo_geometry column to discover type of spatial data it contains.&lt;br/&gt;   *   @param       p_table_name  : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name : varchar2 : The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_owner       : varchar2 : Schema that owns the table.&lt;br/&gt;   *   @param       p_activity    : T_TokenSet : Array of debug activities that can be used to discover how the procedure processed its data.&lt;br/&gt;   */&lt;br/&gt;   Function Discover_SpatialType( p_table_name  In VarChar2,&lt;br/&gt;                                  p_column_name In VarChar2,&lt;br/&gt;                                  p_owner       In VarChar2 := NULL,&lt;br/&gt;                                  p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     Return VarChar2 Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    Discover_Dimensions&lt;br/&gt;   *   @description Processes table/sdo_geometry column to discover dimensionality of the spatial data&lt;br/&gt;   *   @param       p_table_name  The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_owner       Schema that owns the table.&lt;br/&gt;   *   @param       p_default_dim Default to return if no data.&lt;br/&gt;   *   @param       p_activity    Array of debug activities that can be used to discover how the procedure processed its data.&lt;br/&gt;   */&lt;br/&gt;   Function Discover_Dimensions( p_table_name  IN VarChar2,&lt;br/&gt;                                 p_column_name IN VarChar2,&lt;br/&gt;                                 p_owner       IN VarChar2 := NULL,&lt;br/&gt;                                 p_default_dim IN Number   := 2,&lt;br/&gt;                                 p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     Return Number Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    Discover_SRID&lt;br/&gt;   *   @description Processes table/sdo_geometry column to discover SRID of the spatial data&lt;br/&gt;   *   @param       p_table_name  : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name : varchar2 : The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_owner       : varchar2 : Schema that owns the table.&lt;br/&gt;   *   @param       p_activity    : T_TokenSet : Array of debug activities that can be used to discover how the procedure processed its data.&lt;br/&gt;   */&lt;br/&gt;   Function Discover_SRID( p_table_name  In VarChar2,&lt;br/&gt;                           p_column_name In VarChar2,&lt;br/&gt;                           p_owner       In VarChar2 := NULL,&lt;br/&gt;                           p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     Return Number Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    UpdateSdoMetadata&lt;br/&gt;   *   @description Updates 2D spatial extent of DIMINFO associated with table/column in all_sdo_geom_metadata&lt;br/&gt;   *   @param       p_table_name  : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name : varchar2 : The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_mbr_factor  : number   : Expansion/Shrinkage amount for MBR of current data.&lt;br/&gt;   *   @param       p_commit      : boolean  : Whether to commit the update.&lt;br/&gt;   */&lt;br/&gt;   Procedure UpdateSdoMetadata( p_table_name  in varchar2,&lt;br/&gt;                                p_column_name in varchar2,&lt;br/&gt;                                p_mbr_factor  in number,&lt;br/&gt;                                p_commit      in boolean := false );&lt;br/&gt;&lt;br/&gt;   /** @function    GetSpatialIndexName&lt;br/&gt;   *   @description Gets name of the spatial index associated with a table/column&lt;br/&gt;   *   @param       p_table_name  : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name : varchar2 : The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_owner       : varchar2 : Schema that owns the table.&lt;br/&gt;   */&lt;br/&gt;   Function GetSpatialIndexName( p_table_name  In VarChar2,&lt;br/&gt;                                 p_column_name In VarChar2,&lt;br/&gt;                                 p_owner       In VarChar2 := NULL )&lt;br/&gt;     Return VarChar2 Deterministic;&lt;br/&gt;&lt;br/&gt;   /** @function    DropSpatialIndex&lt;br/&gt;   *   @description Finds and drops spatial index associated with a table/column.&lt;br/&gt;   *   @param       p_table_name  : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name : varchar2 : The sdo_geometry column whose index we want to drop.&lt;br/&gt;   *   @param       p_owner       : varchar2 : Schema that owns the table.&lt;br/&gt;   */&lt;br/&gt;   Procedure DropSpatialIndex( p_table_name  In VarChar2,&lt;br/&gt;                               p_column_Name In VarChar2,&lt;br/&gt;                               p_owner       In VarChar2 := NULL);&lt;br/&gt;&lt;br/&gt;   /** @function    SpatialIndexer&lt;br/&gt;   *   @description Procedure that can be used to spatially index a&lt;br/&gt;   *                single table/sdo_geometry column.&lt;br/&gt;   *                Will also analyze the index.&lt;br/&gt;   *   @param       p_table_name      : varchar2 : The object containing the spatal data.&lt;br/&gt;   *   @param       p_column_name     : varchar2 : The sdo_geometry column to be analyzed.&lt;br/&gt;   *   @param       p_owner           : varchar2 : Schema that owns the table.&lt;br/&gt;   *   @param       p_spatial_type    : varchar2 : layer_gtype parameter string value. If NULL Discover_SpatialType is called.&lt;br/&gt;   *   @param       p_check           : boolean  : Check table has metadata and has data before indexing.&lt;br/&gt;   *   @param       p_dimensions      : number   : Dimensionality of data in p_column_name (see Discover_Dimensions)&lt;br/&gt;   *   @param       p_tablespace      : varchar2 : For 10g and above, tablespace to hold index data.&lt;br/&gt;   *   @param       p_work_tablespace : varchar2 : For 10g and above, work tablespace as index is built.&lt;br/&gt;   *   @param       p_pin_non_leaf    : boolean  : If set non leaf index is created and pinned into memory.&lt;br/&gt;   *   @param       p_stats_percent   : number   : If &gt; 0 causes index to be analyzed.&lt;br/&gt;   *   @param       p_activity        : T_TokenSet : Array of debug activities that can be used to discover how the procedure processed its data.&lt;br/&gt;   */&lt;br/&gt;   Procedure SpatialIndexer( p_table_name      In VarChar2,&lt;br/&gt;                             p_column_name     In VarChar2,&lt;br/&gt;                             p_owner           In VarChar2    := NULL,&lt;br/&gt;                             p_spatial_type    In VarChar2    := NULL,&lt;br/&gt;                             p_check           In Boolean     := FALSE,&lt;br/&gt;                             p_dimensions      In Number      := 2,&lt;br/&gt;                             p_tablespace      In VarChar2    := NULL,&lt;br/&gt;                             p_work_tablespace In VarChar2    := NULL,&lt;br/&gt;                             p_pin_non_leaf    In Boolean     := FALSE,&lt;br/&gt;                             p_stats_percent   In PLS_INTEGER := 0,&lt;br/&gt;                             p_activity        In Out NoCopy codesys.TOOLS.T_Strings );&lt;br/&gt;&lt;br/&gt;   /** @function    SpatialIndexUnindexed&lt;br/&gt;   *   @description Procedure that can be used to spatially index those objects with no existing index.&lt;br/&gt;   *   @param       p_owner           : varchar2 : Schema that owns the objects to be indexed. If NULL the sys_context(...,CurrentUser)&lt;br/&gt;   *   @param       p_check           : varchar2 : Check table has metadata and has data before indexing.&lt;br/&gt;   *   @param       p_tablespace      : varchar2 : For 10g and above, tablespace to hold index data.&lt;br/&gt;   *   @param       p_work_tablespace : varchar2 : For 10g and above, work tablespace as index is built.&lt;br/&gt;   *   @param       p_pin_non_leaf    : booelan  : If set non leaf index is created and pinned into memory.&lt;br/&gt;   *   @param       p_stats_percent   : number   : If &gt; 0 causes index to be analyzed.&lt;br/&gt;   **/&lt;br/&gt;   Procedure SpatialIndexUnindexed( p_owner           In VarChar2    := NULL,&lt;br/&gt;                                    p_check           In Boolean     := FALSE,&lt;br/&gt;                                    p_tablespace      In VarChar2    := NULL,&lt;br/&gt;                                    p_work_tablespace In VarChar2    := NULL,&lt;br/&gt;                                    p_pin_non_leaf    In Boolean     := FALSE,&lt;br/&gt;                                    p_stats_percent   In PLS_INTEGER := 0 );&lt;br/&gt;&lt;br/&gt;   /** @function    MeadataAnalyzer&lt;br/&gt;   *   @description Procedure that can be used to discover sdo_geom_metadata including sdo_tolerance, generates spatial indexes etc.&lt;br/&gt;   *   @param       p_owner           : varchar2 : Schema that owns the objects to be indexed. If NULL the sys_context(...,CurrentUser)&lt;br/&gt;   *   @param       p_table_regex     : varchar2 : Regular expression used to select tables for processing (10g and above)&lt;br/&gt;   *   @param       p_fixed_srid      : varchar2 : If data is from one SRID, user can set it.&lt;br/&gt;   *   @param       p_fixed_diminfo   : SDO_DIM_ARRAY : If user wants to apply a single diminfo structure to processed tables.&lt;br/&gt;   *   @param       p_tablespace      : varchar2 : For 10g and above, tablespace to hold index data.&lt;br/&gt;   *   @param       p_work_tablespace : varchar2 : For 10g and above, work tablespace as index is built.&lt;br/&gt;   *   @param       p_pin_non_leaf    : boolean  : If set non leaf index is created and pinned into memory.&lt;br/&gt;   *   @param       p_stats_percent   : PLS_Integer : If &gt; 0 causes index to be analyzed.&lt;br/&gt;   *   @param       p_min_projected_tolerance : boolean : The smallest tolerance after which tolerance discovery stops.&lt;br/&gt;   *   @param       p_rectify_geometry : boolean  : Attempt to correct invalid geometries&lt;br/&gt;   **/&lt;br/&gt;   Procedure MetadataAnalyzer( p_owner                   IN VARCHAR2            := NULL,&lt;br/&gt;                               p_table_regex             IN VARCHAR2            := &apos;*&apos;,&lt;br/&gt;                               p_column_regex            IN VARCHAR2            := &apos;*&apos;,&lt;br/&gt;                               p_fixed_srid              IN NUMBER              := -9999,&lt;br/&gt;                               p_fixed_diminfo           IN MDSYS.SDO_DIM_ARRAY := NULL,&lt;br/&gt;                               p_tablespace              IN VARCHAR2            := NULL,&lt;br/&gt;                               p_work_tablespace         IN VARCHAR2            := NULL,&lt;br/&gt;                               p_pin_non_leaf            IN BOOLEAN             := FALSE,&lt;br/&gt;                               p_stats_percent           IN PLS_INTEGER         := 100,&lt;br/&gt;                               p_min_projected_tolerance IN NUMBER              := 0.00005,&lt;br/&gt;                               p_rectify_geometry        IN BOOLEAN             := FALSE );&lt;br/&gt;&lt;br/&gt;   /** @function    RandomSearchByExtent&lt;br/&gt;   *   @description Procedure that can help for independent testing of the performance of a table/geometry column&lt;br/&gt;   *                perhaps when spatially indexing, reorganising data, rounding ordinates etc.&lt;br/&gt;   *   @param       p_schema          : varchar2 : Schema that owns the object to be searched.&lt;br/&gt;   *   @param       p_table_name      : varchar2 : The object containing the spatal data for which we want to gather stats.&lt;br/&gt;   *   @param       p_column_name     : varchar2 : The sdo_geometry column to be searched.&lt;br/&gt;   *   @param       p_number_searches : number : Number of times to execute each search.&lt;br/&gt;   *   @param       p_window_set      : T_WindowSet : Set of search &quot;windows&quot;&lt;br/&gt;   *   @param       p_no_zeros        : boolean : TRUE =&gt; zero features searches ignored&lt;br/&gt;   *   @param       p_sdo_anyinteract : boolean : Use Sdo_AnyInteract rather than SDO_FILTER&lt;br/&gt;   *   @param       p_count_vertices  : boolean : Force code to actually process geometry data.&lt;br/&gt;   *   @param       p_debug_detail    : boolean : Don&apos;t bother displaying individual search stats&lt;br/&gt;   *   @param       p_min_pixel_size  : number  : Include min_resolution=p_min_pixel_size in search  (only when SDO_FILTERing)&lt;br/&gt;   **/&lt;br/&gt;   Procedure RandomSearchByExtent(p_schema          In VarChar2,&lt;br/&gt;                                  p_table_name      In VarChar2,&lt;br/&gt;                                  p_column_name     In VarChar2,&lt;br/&gt;                                  p_number_searches In Number  := 100,&lt;br/&gt;                                  p_window_set      In codesys.T_WindowSet := codesys.T_WindowSet(500,1000,2000,3000,4000,5000,10000,20000,50000),&lt;br/&gt;                                  p_no_zeros        In Boolean := TRUE,&lt;br/&gt;                                  p_sdo_anyinteract In Boolean := FALSE,&lt;br/&gt;                                  p_count_vertices  in Boolean := FALSE,&lt;br/&gt;                                  p_debug_detail    In Boolean := FALSE,&lt;br/&gt;                                  p_min_pixel_size  In Number  := NULL );&lt;br/&gt;&lt;br/&gt;END TOOLS;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="TOOLS" id="E0E6AA71-A2D7-6B23-4C5F-C0BCD7A9E30F">
<sourceConnName>codesys12</sourceConnName>
<sourceObjSchema>CODESYS</sourceObjSchema>
<sourceObjName>TOOLS</sourceObjName>
<createdBy>Simon</createdBy>
<createdTime>2015-10-27 07:11:21 UTC</createdTime>
<ownerDesignName>ManagedColumns</ownerDesignName>
<owner>CD237EE0-EC38-4CFB-299A-D68C1EE5DB10</owner>
<source>CREATE OR REPLACE Package Body CODESYS.TOOLS&lt;br/&gt;As&lt;br/&gt;   c_discover_srid        CONSTANT Number        := -9999;&lt;br/&gt;   c_module_name          CONSTANT varchar2(256) := &apos;TOOLS&apos;;&lt;br/&gt;   c_max_number           CONSTANT Number        := 9999999999.9999;&lt;br/&gt;   c_min_number           CONSTANT Number        := -9999999999.9999;&lt;br/&gt;   c_max_tolerance        CONSTANT Number        := 500;&lt;br/&gt;   c_Collection           CONSTANT varchar2(20)  := &apos;COLLECTION&apos;;&lt;br/&gt;&lt;br/&gt;   c_spindex_suffix       VARCHAR2(6)            := &apos;$X&apos;;  -- Set to NULL if don&apos;t want it.&lt;br/&gt;   c_spindex_prefix       VARCHAR2(6)            := NULL;  -- Set to a value (eg SP) if want it&lt;br/&gt;&lt;br/&gt;   -- *****************************************************************************************&lt;br/&gt;   -- Private functions for use in Spatial Indexing and Metadata Analyzer&lt;br/&gt;   --&lt;br/&gt;&lt;br/&gt;   PROCEDURE Execute_Statement( p_sql     In VarChar2,&lt;br/&gt;                                p_display In Boolean := FALSE)&lt;br/&gt;   IS&lt;br/&gt;   BEGIN&lt;br/&gt;      EXECUTE IMMEDIATE p_sql;&lt;br/&gt;      EXCEPTION&lt;br/&gt;        WHEN OTHERS THEN&lt;br/&gt;          IF ( p_display ) THEN&lt;br/&gt;            dbms_output.put_line(SUBSTR(LPAD(&apos;_&apos;,6,&apos;_&apos;)||p_sql,1,255));&lt;br/&gt;            dbms_output.put_line(SUBSTR(LPAD(&apos;_&apos;,8,&apos;_&apos;)||&apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE),1,255));&lt;br/&gt;          END IF;&lt;br/&gt;   END Execute_Statement;&lt;br/&gt;&lt;br/&gt;   FUNCTION Managed_Column_Id( p_table_Name  IN VarChar2,&lt;br/&gt;                               p_Column_Name IN VarChar2,&lt;br/&gt;                               p_owner       IN VarChar2 := NULL )&lt;br/&gt;     Return Integer&lt;br/&gt;   Is&lt;br/&gt;     v_id      INTEGER;&lt;br/&gt;     v_owner   VARCHAR2(32);&lt;br/&gt;   Begin&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;     SELECT ID&lt;br/&gt;       INTO v_id&lt;br/&gt;       FROM codesys.MANAGED_COLUMNS&lt;br/&gt;      WHERE owner       = v_owner&lt;br/&gt;        AND table_name  = UPPER(p_table_name)&lt;br/&gt;        AND column_name = UPPER(p_column_name);&lt;br/&gt;     RETURN v_id;&lt;br/&gt;     EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;          SELECT codesys.MANAGED_COLUMNS_ID.NEXTVAL INTO v_id FROM DUAL;&lt;br/&gt;          INSERT INTO codesys.MANAGED_COLUMNS (ID,owner,table_name,column_name)&lt;br/&gt;            VALUES (v_id,v_owner,UPPER(p_table_name),UPPER(p_column_name));&lt;br/&gt;          RETURN v_id;&lt;br/&gt;   End Managed_Column_Id;&lt;br/&gt;&lt;br/&gt;   Function Get_Diminfo( p_table_Name  IN VarChar2,&lt;br/&gt;                         p_Column_Name IN VarChar2,&lt;br/&gt;                         p_owner       IN VarChar2 := NULL )&lt;br/&gt;     Return MDSYS.SDO_DIM_ARRAY&lt;br/&gt;   Is&lt;br/&gt;     v_diminfo       MDSYS.SDO_DIM_ARRAY;&lt;br/&gt;     v_owner         VARCHAR2(32);&lt;br/&gt;   Begin&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;     SELECT   diminfo&lt;br/&gt;       INTO v_diminfo&lt;br/&gt;       FROM ALL_SDO_GEOM_METADATA&lt;br/&gt;      WHERE owner       = v_Owner&lt;br/&gt;        AND table_name  = UPPER(p_Table_Name)&lt;br/&gt;        AND column_name = UPPER(p_Column_Name);&lt;br/&gt;     RETURN v_DimInfo;&lt;br/&gt;     EXCEPTION&lt;br/&gt;      WHEN NO_DATA_FOUND THEN&lt;br/&gt;        RETURN NULL;&lt;br/&gt;   END Get_Diminfo;&lt;br/&gt;&lt;br/&gt;   /** @function    Get_Spatial_Index_Extent&lt;br/&gt;   *   @description Uses SDO_TUNE.EXTENT_OF to get extent of data in the spatial index&lt;br/&gt;   *   @param       p_table_name  The object with the sdo_geometry column.&lt;br/&gt;   *   @param       p_column_name The sdo_geometry column.&lt;br/&gt;   *   @param       p_diminfo     The dimarray into which the new extent data will be written.&lt;br/&gt;   */&lt;br/&gt;   FUNCTION Get_Spatial_Index_Extent( p_table_name  IN VARCHAR2,&lt;br/&gt;                                      p_column_name IN VARCHAR2,&lt;br/&gt;                                      p_diminfo     IN OUT NOCOPY MDSYS.SDO_DIM_ARRAY )&lt;br/&gt;     RETURN BOOLEAN&lt;br/&gt;   IS&lt;br/&gt;     v_geometry  MDSYS.SDO_GEOMETRY;&lt;br/&gt;     v_ordinates MDSYS.SDO_ORDINATE_ARRAY;&lt;br/&gt;   BEGIN&lt;br/&gt;      -- Note only returns extent of 2D indexed data up to 10gR2.&lt;br/&gt;      v_geometry := MDSYS.SDO_TUNE.EXTENT_OF(p_table_name,p_column_name);&lt;br/&gt;      If ( v_geometry is not null ) Then&lt;br/&gt;        v_ordinates := v_geometry.sdo_ordinates;&lt;br/&gt;        If ( v_ordinates.COUNT = 4 ) Then&lt;br/&gt;          p_diminfo(1).sdo_lb := v_ordinates(1);&lt;br/&gt;          p_diminfo(1).sdo_ub := v_ordinates(3);&lt;br/&gt;          p_diminfo(2).sdo_lb := v_ordinates(2);&lt;br/&gt;          p_diminfo(2).sdo_ub := v_ordinates(4);&lt;br/&gt;        End If;&lt;br/&gt;      End If;&lt;br/&gt;      IF ( p_diminfo(1).sdo_lb IS NULL ) OR&lt;br/&gt;         ( p_diminfo(1).sdo_ub IS NULL ) OR&lt;br/&gt;         ( p_diminfo(2).sdo_lb IS NULL ) OR&lt;br/&gt;         ( p_diminfo(2).sdo_ub IS NULL ) THEN&lt;br/&gt;         RETURN FALSE;&lt;br/&gt;      END IF;&lt;br/&gt;      RETURN TRUE;&lt;br/&gt;      EXCEPTION&lt;br/&gt;        WHEN OTHERS THEN&lt;br/&gt;          dbms_output.put_line(SUBSTR(&apos;GET_SPATIAL_INDEX_EXTENT: (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos;)&apos;,1,255));&lt;br/&gt;          RETURN FALSE;&lt;br/&gt;   END Get_Spatial_Index_Extent;&lt;br/&gt;&lt;br/&gt;   /* =================== Public Rountine =============== */&lt;br/&gt;&lt;br/&gt;  Function isCompound( p_sdo_elem_info in mdsys.sdo_elem_info_array )&lt;br/&gt;     return integer&lt;br/&gt;  Is&lt;br/&gt;    v_compound_element_count number := 0;&lt;br/&gt;  Begin&lt;br/&gt;    SELECT count(*) as c_element_count&lt;br/&gt;      INTO v_compound_element_count&lt;br/&gt;      FROM (SELECT e.id,&lt;br/&gt;                   e.etype,&lt;br/&gt;                   e.offset,&lt;br/&gt;                   e.interpretation&lt;br/&gt;              FROM (SELECT trunc((rownum - 1) / 3,0) as id,&lt;br/&gt;                           sum(case when mod(rownum,3) = 1 then sei.column_value else null end) as offset,&lt;br/&gt;                           sum(case when mod(rownum,3) = 2 then sei.column_value else null end) as etype,&lt;br/&gt;                           sum(case when mod(rownum,3) = 0 then sei.column_value else null end) as interpretation&lt;br/&gt;                      FROM TABLE(p_sdo_elem_info) sei&lt;br/&gt;                     GROUP BY trunc((rownum - 1) / 3,0)&lt;br/&gt;                    ) e&lt;br/&gt;           ) i&lt;br/&gt;     WHERE i.etype = 2&lt;br/&gt;       AND i.interpretation = 2;&lt;br/&gt;    Return case when v_compound_element_count &gt; 0 then 1 else 0 end;&lt;br/&gt;   End isCompound;&lt;br/&gt;&lt;br/&gt;   Procedure GeometryCheck( p_schema        IN VarChar2,&lt;br/&gt;                            p_tableName     IN VarChar2,&lt;br/&gt;                            p_ColumnName    IN VarChar2,&lt;br/&gt;                            p_whereClause   IN VarChar2)&lt;br/&gt;   IS&lt;br/&gt;     v_Ok            NUMBER;&lt;br/&gt;     v_shape         MDSYS.SDO_GEOMETRY;&lt;br/&gt;     c_shape         MDSYS.SDO_GEOMETRY;&lt;br/&gt;     v_managed_id    INTEGER;&lt;br/&gt;     v_sequence_id   INTEGER;&lt;br/&gt;     v_OwnerName     VARCHAR2(30);&lt;br/&gt;     v_TableName     VARCHAR2(30);&lt;br/&gt;     v_ColumnName    VARCHAR2(30);&lt;br/&gt;     c_rowid         UROWID;&lt;br/&gt;     v_error_code    FEATURE_ERRORS.ERROR_CODE%TYPE;&lt;br/&gt;     v_error_status  FEATURE_ERRORS.ERROR_STATUS%TYPE;&lt;br/&gt;     v_error_context FEATURE_ERRORS.ERROR_CONTEXT%TYPE;&lt;br/&gt;     v_error_count   NUMBER;&lt;br/&gt;     v_error_found   NUMBER;&lt;br/&gt;     v_fixed_count   NUMBER;&lt;br/&gt;     v_count         NUMBER;&lt;br/&gt;     v_diminfo       MDSYS.SDO_DIM_ARRAY;&lt;br/&gt;     v_start_date    DATE;&lt;br/&gt;     v_end_date      DATE;&lt;br/&gt;     v_tolerance     NUMBER;&lt;br/&gt;     v_query         VARCHAR2(1024);&lt;br/&gt;     TYPE shapeCursorType IS REF CURSOR;&lt;br/&gt;     shapeCursor     shapeCursorType;&lt;br/&gt;   Begin&lt;br/&gt;      If ( p_schema Is NULL ) Then&lt;br/&gt;        v_ownerName := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_ownerName := UPPER(SUBSTR(p_schema,1,32));&lt;br/&gt;      End If;&lt;br/&gt;     v_TableName   := UPPER(p_tablename);&lt;br/&gt;     v_ColumnName  := UPPER(p_ColumnName);&lt;br/&gt;     SELECT COUNT(*)&lt;br/&gt;       INTO v_count&lt;br/&gt;       FROM ALL_TAB_COLUMNS&lt;br/&gt;      WHERE owner       = v_OwnerName&lt;br/&gt;        AND  table_name = v_TableName&lt;br/&gt;        AND column_name = v_ColumnName&lt;br/&gt;        AND   data_type = &apos;SDO_GEOMETRY&apos;;&lt;br/&gt;     If ( v_count = 0 ) Then&lt;br/&gt;        raise_application_error(codesys.CONSTANTS.c_i_table_geometry,codesys.CONSTANTS.c_s_table_geometry,TRUE);&lt;br/&gt;     End If;&lt;br/&gt;     v_managed_id         := Managed_Column_Id( v_TableName, v_ColumnName, v_OwnerName);&lt;br/&gt;     v_diminfo            := Get_Diminfo( v_TableName, v_ColumnName, v_OwnerName);&lt;br/&gt;     If ( v_diminfo IS NULL ) Then&lt;br/&gt;        dbms_output.put_line(SUBSTR(&apos;No diminfo found in all_sdo_geom_metadata for &apos;||v_OwnerName||&apos;.&apos;||v_TableName||&apos;.&apos;||v_ColumnName,1,255));&lt;br/&gt;        raise_application_error(codesys.CONSTANTS.c_i_no_diminfo,codesys.CONSTANTS.c_s_no_diminfo,TRUE);&lt;br/&gt;     End If;&lt;br/&gt;     v_tolerance   := v_diminfo(1).sdo_tolerance;&lt;br/&gt;     v_count       := 0;&lt;br/&gt;     v_error_count := 0;&lt;br/&gt;     v_fixed_count := 0;&lt;br/&gt;     IF ( p_whereClause is not null ) THEN&lt;br/&gt;       v_query := &apos;SELECT ROWID,&apos; ||v_ColumnName|| &apos; FROM &apos; ||v_OwnerName|| &apos;.&apos; ||v_TableName|| &apos; WHERE &apos; ||p_whereClause;&lt;br/&gt;     ELSE&lt;br/&gt;       v_query := &apos;SELECT ROWID,&apos; ||v_ColumnName|| &apos; FROM &apos; ||v_OwnerName|| &apos;.&apos; ||v_TableName;&lt;br/&gt;     END IF;&lt;br/&gt;     v_start_date := SYSDATE;&lt;br/&gt;     OPEN shapeCursor&lt;br/&gt;      FOR v_query;&lt;br/&gt;     LOOP&lt;br/&gt;      FETCH shapeCursor INTO c_rowid, c_shape;&lt;br/&gt;      EXIT WHEN shapeCursor%NOTFOUND;&lt;br/&gt;      IF ( c_shape IS NULL ) THEN&lt;br/&gt;        v_error_code := &apos;NULL&apos;;&lt;br/&gt;      ELSE&lt;br/&gt;        v_error_code := SUBSTR(MDSYS.SDO_GEOM.VALIDATE_GEOMETRY( c_shape, v_diminfo ),1,5);&lt;br/&gt;      END IF;&lt;br/&gt;      IF ( v_error_code &lt;&gt; &apos;TRUE&apos; ) THEN&lt;br/&gt;        v_error_count := v_error_count + 1;&lt;br/&gt;        v_error_status  := &apos;E&apos;; -- if exception raised in following block this will remain &apos;E&apos;&lt;br/&gt;        IF ( v_error_code &lt;&gt; &apos;NULL&apos; ) THEN&lt;br/&gt;          BEGIN  -- Exception block in case any of the functions trying to fix the shape fail...&lt;br/&gt;            IF ( v_error_code = &apos;13356&apos; ) THEN&lt;br/&gt;              v_shape := mdsys.sdo_util.remove_duplicate_vertices(c_shape,v_tolerance);&lt;br/&gt;            ELSIF c_shape.sdo_gtype in (2003,2007) THEN  -- only try to fix bad polygons&lt;br/&gt;              If ( DBMS_DB_VERSION.VERSION &gt;= 10 ) Then&lt;br/&gt;                EXECUTE IMMEDIATE &apos;SELECT mdsys.sdo_util.rectify_geometry(:1,:2) FROM DUAL&apos;&lt;br/&gt;		             INTO v_shape&lt;br/&gt;		            USING c_shape, v_tolerance;&lt;br/&gt;              Else&lt;br/&gt;                Begin&lt;br/&gt;                  -- Can only use this if Enterprise Edition and SDO&lt;br/&gt;                  SELECT 1&lt;br/&gt;                    INTO v_Ok&lt;br/&gt;                    FROM v$version&lt;br/&gt;                   WHERE banner like &apos;%Enterprise Edition%&apos;;&lt;br/&gt;                  SELECT 1&lt;br/&gt;                    INTO v_Ok&lt;br/&gt;                    FROM dba_registry&lt;br/&gt;                   WHERE comp_id = &apos;SDO&apos;;&lt;br/&gt;                  v_shape := mdsys.sdo_geom.sdo_union(c_shape,v_diminfo,c_shape,v_diminfo);&lt;br/&gt;                  EXCEPTION&lt;br/&gt;                    WHEN OTHERS THEN&lt;br/&gt;                      v_shape := c_shape;&lt;br/&gt;                End;&lt;br/&gt;              End If;&lt;br/&gt;              IF ( v_shape.sdo_gtype = 2004 ) THEN&lt;br/&gt;                v_shape := codesys.geom.ExtractPolygon(v_shape);&lt;br/&gt;              END IF;&lt;br/&gt;            END IF;&lt;br/&gt;            -- Update shape to reflect whatever happened...&lt;br/&gt;            EXECUTE IMMEDIATE &apos;UPDATE &apos; || v_OwnerName||&apos;.&apos;||v_TableName || &apos; A SET A.&apos;||v_ColumnName||&apos; = :1 WHERE rowid = :2 &apos;&lt;br/&gt;                        USING v_shape,c_rowid;&lt;br/&gt;            -- Check whether it was corrected or not...&lt;br/&gt;            v_error_context := SUBSTR(MDSYS.SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(v_shape,v_diminfo),1,2000);&lt;br/&gt;            v_error_code    := SUBSTR(v_error_context,1,5);&lt;br/&gt;            v_error_context := SUBSTR(v_error_context,6,2000);&lt;br/&gt;            IF v_error_code = &apos;TRUE&apos; THEN&lt;br/&gt;              v_error_status  := &apos;F&apos;;&lt;br/&gt;              v_fixed_count := v_fixed_count + 1;&lt;br/&gt;            END IF;&lt;br/&gt;            EXCEPTION&lt;br/&gt;              WHEN OTHERS THEN&lt;br/&gt;                NULL;&lt;br/&gt;          END;&lt;br/&gt;        END IF;  -- v_error_code = NULL&lt;br/&gt;        SELECT codesys.FEATURE_ERRORS_ID.NEXTVAL INTO v_sequence_id FROM DUAL;&lt;br/&gt;        INSERT INTO codesys.Feature_Errors&lt;br/&gt;                    (id,Managed_Column_Id,feature_rowid,error_code,error_status,error_context,error_date)&lt;br/&gt;             VALUES (v_sequence_id,v_managed_id,c_rowid,v_error_code,v_error_status,v_error_context,SYSDATE);&lt;br/&gt;      END IF;&lt;br/&gt;     END LOOP;&lt;br/&gt;     v_count := shapeCursor%ROWCOUNT;&lt;br/&gt;     CLOSE shapeCursor;&lt;br/&gt;     v_end_date := SYSDATE;&lt;br/&gt;     SELECT codesys.FEATURE_ERRORS_SUMMARIES_ID.NEXTVAL INTO v_sequence_id FROM DUAL;&lt;br/&gt;     INSERT INTO codesys.FEATURE_ERROR_SUMMARIES&lt;br/&gt;                 (id,Managed_Column_Id,predicate,process_start,process_end,process_count,error_total,error_fixed)&lt;br/&gt;          VALUES (v_sequence_id,v_managed_id,p_whereClause,v_start_date,v_end_date,v_count,v_error_count,v_fixed_count);&lt;br/&gt;   END GeometryCheck;&lt;br/&gt;&lt;br/&gt;   Procedure VertexAnalyzer( p_owner       In VarChar2 := NULL,&lt;br/&gt;                             p_table_regex In VarChar2 := &apos;*&apos;,&lt;br/&gt;                             p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;   IS&lt;br/&gt;      CURSOR c_geom_columns ( p_owner In VarChar2,&lt;br/&gt;                              p_regex In VarChar2 ) IS&lt;br/&gt;         SELECT atc.TABLE_NAME,&lt;br/&gt;                atc.COLUMN_NAME&lt;br/&gt;           FROM ALL_TAB_COLUMNS atc&lt;br/&gt;          WHERE atc.owner     = p_owner&lt;br/&gt;            AND atc.DATA_TYPE = &apos;SDO_GEOMETRY&apos;&lt;br/&gt;            AND REGEXP_LIKE(atc.TABLE_NAME,p_regex);&lt;br/&gt;&lt;br/&gt;      v_managed_id INTEGER;&lt;br/&gt;      v_min        NUMBER;&lt;br/&gt;      v_avg        NUMBER;&lt;br/&gt;      v_max        NUMBER;&lt;br/&gt;      v_rubbish    VARCHAR2(4000);&lt;br/&gt;      v_owner      VARCHAR2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Processing tables like &apos;|| p_table_regex ||&apos; in schema (&apos;|| v_owner || &apos;) ...&apos;;&lt;br/&gt;&lt;br/&gt;      &lt;&lt;user_tab_columns_loop&gt;&gt;&lt;br/&gt;      FOR geomcolrec IN c_geom_columns( v_owner, p_table_regex ) LOOP  -- process each row one at a time&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Processing: &apos; || geomcolrec.table_name || &apos;.&apos; || geomcolrec.column_name;&lt;br/&gt;        v_managed_id := Managed_Column_Id(geomcolrec.Table_Name, geomcolrec.Column_Name, v_owner);&lt;br/&gt;        BEGIN&lt;br/&gt;          EXECUTE IMMEDIATE &apos;SELECT &apos;&apos;NO&apos;&apos; FROM &apos;||geomcolrec.table_name || &apos; WHERE ROWNUM = 1&apos;&lt;br/&gt;                       INTO v_rubbish;&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Data exists.&apos;;&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Computing Minimum, Average and Maximum vertex count&apos;;&lt;br/&gt;          EXECUTE IMMEDIATE &apos;SELECT MIN(VERTEXCOUNT), AVG(VERTEXCOUNT), MAX(VERTEXCOUNT) &apos;||&lt;br/&gt;                              &apos;FROM ( SELECT MDSYS.SDO_UTIL.GETNUMVERTICES(A.&apos;||geomcolrec.column_name||&apos;) as VERTEXCOUNT &apos;||&lt;br/&gt;                                      &apos; FROM &apos;||geomcolrec.table_name || &apos; A )&apos;&lt;br/&gt;                       INTO v_min, v_avg, v_max;&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;MIN(&apos;||v_min||&apos;) AVG(&apos;||v_avg||&apos;) MAX(&apos;||v_max||&apos;)&apos;;&lt;br/&gt;          UPDATE codesys.Managed_Columns&lt;br/&gt;             SET Vertex_Date  = SYSDATE,&lt;br/&gt;                 min_vertices = v_min,&lt;br/&gt;                 avg_vertices = v_avg,&lt;br/&gt;                 max_vertices = v_max&lt;br/&gt;           WHERE ID = v_managed_id;&lt;br/&gt;          EXCEPTION&lt;br/&gt;            WHEN NO_DATA_FOUND THEN&lt;br/&gt;              p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;No data or vertex count can be generated.&apos;;&lt;br/&gt;            WHEN OTHERS THEN&lt;br/&gt;              p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE);&lt;br/&gt;        END;&lt;br/&gt;      END LOOP user_tab_columns_loop;&lt;br/&gt;      COMMIT;&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Done&apos;;&lt;br/&gt;   END VertexAnalyzer;&lt;br/&gt;&lt;br/&gt;   Function hasData( p_table_name In VarChar2,&lt;br/&gt;                     p_owner      In VarChar2 := NULL)&lt;br/&gt;     Return Boolean&lt;br/&gt;   Is&lt;br/&gt;     v_rubbish VarChar2(100);&lt;br/&gt;     v_owner   VARCHAR2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;     If ( p_owner Is NULL ) Then&lt;br/&gt;       v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;       v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     dbms_output.put_line(LPAD(&apos;_&apos;,4,&apos;_&apos;)||&apos;Check if any data in table...&apos;);&lt;br/&gt;     EXECUTE IMMEDIATE &apos;SELECT &apos;&apos;NO&apos;&apos; FROM &apos; || v_owner || &apos;.&apos; || p_table_name || &apos; WHERE ROWNUM = 1&apos;&lt;br/&gt;        INTO v_rubbish;&lt;br/&gt;     dbms_output.put_line(LPAD(&apos;_&apos;,6,&apos;_&apos;)||&apos;Yes.&apos;);&lt;br/&gt;     Return TRUE;&lt;br/&gt;     EXCEPTION&lt;br/&gt;         WHEN OTHERS THEN&lt;br/&gt;           dbms_output.put_line(LPAD(&apos;_&apos;,6,&apos;_&apos;)||&apos;No.&apos;);&lt;br/&gt;           Return False;&lt;br/&gt;   END hasData;&lt;br/&gt;&lt;br/&gt;   Function Generate_Object_Name ( p_object_name   IN VARCHAR2,&lt;br/&gt;                                   p_column_name   IN VARCHAR2,&lt;br/&gt;                                   p_obj_shortname IN VARCHAR2,&lt;br/&gt;                                   p_col_shortname IN VARCHAR2,&lt;br/&gt;                                   p_prefix        IN VARCHAR2,&lt;br/&gt;                                   p_suffix        IN VARCHAR2,&lt;br/&gt;                                   p_name_length   IN PLS_INTEGER := 30 )&lt;br/&gt;     Return VarChar2&lt;br/&gt;   IS&lt;br/&gt;     v_temp_name        VARCHAR2(4000);&lt;br/&gt;     v_table_len        PLS_INTEGER;&lt;br/&gt;     v_colmn_len        PLS_INTEGER;&lt;br/&gt;   BEGIN&lt;br/&gt;     IF ( p_suffix is not null ) THEN&lt;br/&gt;       -- Try pure name concatenation ...&lt;br/&gt;       v_temp_name := p_object_name || &apos;_&apos; || p_column_name || &apos;_&apos; || p_suffix;&lt;br/&gt;       IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;         -- Try using table short name with normal column name...&lt;br/&gt;         v_temp_name := p_obj_shortname || &apos;_&apos; || p_column_name || &apos;_&apos; || p_suffix;&lt;br/&gt;         IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;           -- Try shortening both names&lt;br/&gt;           v_temp_name := p_obj_shortname || &apos;_&apos; || p_col_shortname || &apos;_&apos; || p_suffix;&lt;br/&gt;           IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;             -- Try table name and suffix&lt;br/&gt;             v_temp_name := p_object_name || &apos;_&apos; || p_suffix;&lt;br/&gt;             IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;               -- Try table short name and suffix&lt;br/&gt;               v_temp_name := p_obj_shortname || &apos;_&apos; || p_suffix;&lt;br/&gt;               IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;                 -- Truncate table short name with suffix&lt;br/&gt;                 v_temp_name := SUBSTR(p_obj_shortname,1,(p_name_length-1-LENGTH(p_suffix))) || &apos;_&apos; || p_suffix;&lt;br/&gt;               END IF;&lt;br/&gt;             END IF;&lt;br/&gt;           END IF;&lt;br/&gt;         END IF;&lt;br/&gt;       END IF;&lt;br/&gt;     ELSIF ( p_prefix is not null ) THEN&lt;br/&gt;       -- Try pure name concatenation ...&lt;br/&gt;       v_temp_name := p_prefix || &apos;_&apos; || p_object_name || &apos;_&apos; || p_column_name;&lt;br/&gt;       IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;         -- Try using table short name with normal column name...&lt;br/&gt;         v_temp_name := p_prefix || &apos;_&apos; || p_obj_shortname || &apos;_&apos; || p_column_name;&lt;br/&gt;         IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;           -- Try shortening both names&lt;br/&gt;           v_temp_name := p_prefix || &apos;_&apos; || p_obj_shortname || &apos;_&apos; || p_col_shortname;&lt;br/&gt;           IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;             -- Try prefix and table name ...&lt;br/&gt;             v_temp_name := p_prefix || &apos;_&apos; || p_object_name;&lt;br/&gt;             IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;               -- Try prefix and table short name ...&lt;br/&gt;               v_temp_name := p_prefix || &apos;_&apos; || p_obj_shortname;&lt;br/&gt;               IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;                 -- Try prefix and truncated table short name ...&lt;br/&gt;                 v_temp_name := p_prefix || &apos;_&apos; || SUBSTR(p_obj_shortname,1,(p_name_length-1-LENGTH(p_suffix)));&lt;br/&gt;               END IF;&lt;br/&gt;             END IF;&lt;br/&gt;           END IF;&lt;br/&gt;         END IF;&lt;br/&gt;       END IF;&lt;br/&gt;     ELSE&lt;br/&gt;       -- Try pure name concatenation ...&lt;br/&gt;       v_temp_name := p_object_name || &apos;_&apos; || p_column_name;&lt;br/&gt;       IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;         -- Try using table short name with normal column name...&lt;br/&gt;         v_temp_name := p_obj_shortname || &apos;_&apos; || p_column_name;&lt;br/&gt;         IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;           -- Try shortening both names&lt;br/&gt;           v_temp_name := p_obj_shortname || &apos;_&apos; || p_col_shortname;&lt;br/&gt;           IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;             -- Generate name from short table name truncated with length of the short column name&lt;br/&gt;             v_temp_name := SUBSTR(p_obj_shortname,1,(p_name_length-1-LENGTH(p_col_shortname))) || &apos;_&apos; || p_col_shortname;&lt;br/&gt;             IF ( LENGTH( v_temp_name ) &gt; p_name_length ) THEN&lt;br/&gt;               -- Generate name by truncating short table and column names in a 2/3 to 1/3 ratio ...&lt;br/&gt;               v_table_len := TRUNC(p_name_length * 2 / 3);&lt;br/&gt;               v_colmn_len := TRUNC(p_name_length / 3) - 1;&lt;br/&gt;               v_temp_name := SUBSTR(p_obj_shortname,1,v_table_len) || &apos;_&apos; || SUBSTR(p_col_shortname,1,v_colmn_len);&lt;br/&gt;             END IF;&lt;br/&gt;           END IF;&lt;br/&gt;         END IF;&lt;br/&gt;       END IF;&lt;br/&gt;     END IF;&lt;br/&gt;     RETURN SUBSTR(v_temp_name,1,p_name_length);&lt;br/&gt;   END Generate_Object_Name;&lt;br/&gt;&lt;br/&gt;   Function NonLeaf_Spatial_IndexName( p_spindex_name In VARCHAR2,&lt;br/&gt;                                       p_nl_size      In Out NoCopy Number,&lt;br/&gt;                                       p_owner        In VarChar2 := NULL,&lt;br/&gt;                                       p_pin          In BOOLEAN  := FALSE )&lt;br/&gt;     Return VarChar2&lt;br/&gt;   IS&lt;br/&gt;     v_nl_name   USER_SDO_INDEX_METADATA.SDO_NL_INDEX_TABLE%TYPE;&lt;br/&gt;     v_sql       varchar2(4000);&lt;br/&gt;     v_owner   VARCHAR2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;     If ( p_owner Is NULL ) Then&lt;br/&gt;       v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;       v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     BEGIN&lt;br/&gt;       SELECT sdo_nl_index_table&lt;br/&gt;         INTO v_nl_name&lt;br/&gt;         FROM ALL_SDO_INDEX_METADATA&lt;br/&gt;        WHERE sdo_index_owner = v_owner&lt;br/&gt;          AND sdo_index_name  = p_spindex_name ;&lt;br/&gt;       EXCEPTION&lt;br/&gt;         WHEN OTHERS THEN&lt;br/&gt;           RETURN NULL;&lt;br/&gt;     END;&lt;br/&gt;     -- Retrieve Size&lt;br/&gt;     BEGIN&lt;br/&gt;       SELECT sum(bytes)/1024/1024&lt;br/&gt;         INTO p_nl_size&lt;br/&gt;         FROM user_extents&lt;br/&gt;        WHERE segment_name = v_nl_name&lt;br/&gt;           OR segment_name IN&lt;br/&gt;              (SELECT segment_name&lt;br/&gt;                 FROM user_lobs&lt;br/&gt;                WHERE table_name = v_nl_name );&lt;br/&gt;       EXCEPTION&lt;br/&gt;         WHEN OTHERS THEN&lt;br/&gt;           RETURN v_nl_name;&lt;br/&gt;     END;&lt;br/&gt;     v_sql := &apos;ALTER TABLE &apos;||v_nl_name||&apos; STORAGE(BUFFER_POOL KEEP)&apos;;&lt;br/&gt;     IF ( p_pin ) THEN&lt;br/&gt;       Execute_Statement(v_sql,TRUE);&lt;br/&gt;     END IF;&lt;br/&gt;     Return v_nl_name;&lt;br/&gt;   END NonLeaf_Spatial_IndexName;&lt;br/&gt;&lt;br/&gt;   Function Discover_SpatialType( p_table_name  In VarChar2,&lt;br/&gt;                                  p_column_name In VarChar2,&lt;br/&gt;                                  p_owner       In VarChar2 := NULL,&lt;br/&gt;                                  p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     Return VarChar2&lt;br/&gt;   IS&lt;br/&gt;     TYPE t_SpatialTypes IS TABLE OF VARCHAR2(20);&lt;br/&gt;     v_SpatialTypes t_SpatialTypes;&lt;br/&gt;     v_spatial_type VARCHAR2(20) := &apos;NO_DATA&apos;;&lt;br/&gt;     v_base_type    VARCHAR2(20) := NULL;&lt;br/&gt;     v_sql          VARCHAR2(4000);&lt;br/&gt;     v_rowcount     NUMBER;&lt;br/&gt;     v_owner        VarChar2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;      v_sql :=          &apos;SELECT SUBSTR(spatialtype,1,20) AS spatialtype&apos;;&lt;br/&gt;      v_sql := v_sql || &apos;  FROM (SELECT DISTINCT a.&apos; || p_column_name|| &apos;.sdo_gtype AS gtype, &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               CASE MOD(a.&apos; || p_column_name|| &apos;.sdo_gtype,10) &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               WHEN 0 THEN &apos;&apos;UNKNOWN&apos;&apos;&apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               WHEN 1 THEN &apos;&apos;POINT&apos;&apos;      WHEN 5 THEN &apos;&apos;MULTIPOINT&apos;&apos; &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               WHEN 2 THEN &apos;&apos;LINE&apos;&apos;       WHEN 6 THEN &apos;&apos;MULTILINE&apos;&apos; &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               WHEN 3 THEN &apos;&apos;POLYGON&apos;&apos;    WHEN 7 THEN &apos;&apos;MULTIPOLYGON&apos;&apos; &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;               WHEN 4 THEN &apos;&apos;&apos; || c_Collection || &apos;&apos;&apos; ELSE &apos;&apos;NULL&apos;&apos; END AS SpatialType &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;          FROM &apos; || v_owner || &apos;.&apos; || p_table_name || &apos; a &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;         WHERE a.&apos; || p_column_name ||&apos; IS NOT NULL &apos;;&lt;br/&gt;      v_sql := v_sql || &apos;       ) ORDER BY gtype DESC&apos;;&lt;br/&gt;      EXECUTE IMMEDIATE v_sql&lt;br/&gt;        BULK COLLECT INTO v_SpatialTypes;&lt;br/&gt;      v_rowcount := v_SpatialTypes.COUNT;&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Number of Spatial Types in table is &apos; || v_rowcount;&lt;br/&gt;      IF ( v_rowcount = 0 ) THEN&lt;br/&gt;        RETURN &apos;NO_DATA&apos;;&lt;br/&gt;      ELSIF ( v_rowcount = 1 ) THEN&lt;br/&gt;        v_spatial_type := v_SpatialTypes(1);&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Single spatial type of table is: &apos; || v_spatial_type;&lt;br/&gt;        IF ( v_Spatial_type IN (&apos;NULL&apos;,&apos;UNKNOWN&apos;) ) THEN&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Fix spatial types immediately and then re-run Analyzer (Set to COLLECTION).&apos;;&lt;br/&gt;          v_spatial_type := c_Collection;&lt;br/&gt;        END IF;&lt;br/&gt;      ELSE&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Spatial Types in table are:&apos;;&lt;br/&gt;        -- Set to first of the types as this is probably the MULTI...&lt;br/&gt;        v_spatial_type := v_SpatialTypes(1);&lt;br/&gt;        &lt;&lt;list_spatial_types&gt;&gt;&lt;br/&gt;        FOR i IN v_SpatialTypes.First..v_SpatialTypes.Last LOOP&lt;br/&gt;          p_activity(p_activity.LAST) := p_activity(p_activity.LAST) || &apos; &apos; || v_SpatialTypes(i);&lt;br/&gt;          -- Update value only if not a COLLECTION&lt;br/&gt;          IF ( v_spatial_type &lt;&gt; c_Collection ) THEN&lt;br/&gt;            IF ( v_SpatialTypes(i) = c_Collection ) THEN&lt;br/&gt;              v_spatial_type := c_Collection;&lt;br/&gt;            -- If NULL or UNKNOWN and not of the same initial type... set to COLLECTION&lt;br/&gt;            ELSIF ( v_SpatialTypes(i) IN (&apos;NULL&apos;,&apos;UNKNOWN&apos;) ) THEN&lt;br/&gt;              p_activity(p_activity.LAST) := p_activity(p_activity.LAST) || &apos;(Fix and re-run Analyzer)&apos;;&lt;br/&gt;              v_spatial_type := c_Collection;&lt;br/&gt;            ELSE&lt;br/&gt;              IF ( v_base_type IS NULL ) THEN&lt;br/&gt;                -- Extract base type&lt;br/&gt;                IF ( INSTR(v_SpatialTypes(i),&apos;MULTI&apos;) &gt; 0 ) THEN&lt;br/&gt;                  v_base_type := SUBSTR(v_SpatialTypes(i),6,LENGTH(v_SpatialTypes(i)));&lt;br/&gt;                ELSE&lt;br/&gt;                  v_base_type := v_SpatialTypes(i);&lt;br/&gt;                END IF;&lt;br/&gt;                p_activity(p_activity.LAST) := p_activity(p_activity.LAST) || &apos;(Base spatial type is &apos;|| v_base_type || &apos;)&apos;;&lt;br/&gt;              ELSE&lt;br/&gt;                -- compare base type to the current object for type conflict&lt;br/&gt;                IF ( INSTR(v_SpatialTypes(i),v_base_type) = 0 ) THEN&lt;br/&gt;                  p_activity(p_activity.LAST) := p_activity(p_activity.LAST) || &apos;(Base spatial type conflict)&apos;;&lt;br/&gt;                  v_spatial_type := c_Collection;&lt;br/&gt;                END IF;&lt;br/&gt;              END IF;&lt;br/&gt;            END IF;&lt;br/&gt;          END IF;&lt;br/&gt;        END LOOP list_spatial_types;&lt;br/&gt;      END IF;&lt;br/&gt;      RETURN v_spatial_type;&lt;br/&gt;      EXCEPTION&lt;br/&gt;         WHEN OTHERS THEN&lt;br/&gt;           RETURN c_Collection;&lt;br/&gt;   END Discover_SpatialType;&lt;br/&gt;&lt;br/&gt;   Function Discover_Dimensions( p_table_name  IN VarChar2,&lt;br/&gt;                                 p_column_name IN VarChar2,&lt;br/&gt;                                 p_owner       IN VarChar2 := NULL,&lt;br/&gt;                                 p_default_dim IN Number   := 2,&lt;br/&gt;				 p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     Return Number&lt;br/&gt;   IS&lt;br/&gt;     v_sql        VarChar2(4000);&lt;br/&gt;     v_dimensions Number;&lt;br/&gt;     v_owner      VarChar2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;     If ( p_owner Is NULL ) Then&lt;br/&gt;       v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;       v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Discovering if geometry contains 2D or 3D data...&apos;;&lt;br/&gt;     -- Check to see if all sdo_geometry objects are coded with same GTYPE ...&lt;br/&gt;     If ( DBMS_DB_VERSION.VERSION &gt;= 10 ) Then&lt;br/&gt;       EXECUTE IMMEDIATE &apos;SELECT DISTINCT A.&apos;||p_column_name||&apos;.Get_Dims() FROM &apos;|| v_owner || &apos;.&apos; || p_table_name || &apos; A&apos;&lt;br/&gt;                    INTO v_dimensions;&lt;br/&gt;     ELSE&lt;br/&gt;       EXECUTE IMMEDIATE &apos;SELECT DISTINCT TRUNC(A.&apos;||p_column_name||&apos;.Get_GType / 1000) AS Dim FROM &apos;|| v_owner || &apos;.&apos; || p_table_name || &apos; A&apos;&lt;br/&gt;                    INTO v_dimensions;&lt;br/&gt;       -- In case of single digit gtypes (from 8i)...&lt;br/&gt;       IF ( v_dimensions = 0 ) THEN&lt;br/&gt;         v_dimensions := p_default_dim;&lt;br/&gt;       END IF;&lt;br/&gt;     END IF;&lt;br/&gt;     p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Geometry is &apos;||v_dimensions || &apos;D&apos;;&lt;br/&gt;     RETURN v_dimensions;&lt;br/&gt;     EXCEPTION&lt;br/&gt;       WHEN NO_DATA_FOUND THEN&lt;br/&gt;         p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;No data in table (Assume &apos; || p_default_dim || &apos;D)&apos;;&lt;br/&gt;         RETURN p_default_dim;&lt;br/&gt;       WHEN TOO_MANY_ROWS THEN&lt;br/&gt;         p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Multiple dimensions exist within the table (Assume &apos; || p_default_dim || &apos;D)&apos;;&lt;br/&gt;         RETURN p_default_dim;&lt;br/&gt;       WHEN OTHERS THEN&lt;br/&gt;         p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;When determining geometry dimensionality an error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos; was encountered (Assume &apos; || p_default_dim || &apos;D)&apos;;&lt;br/&gt;         RETURN p_default_dim;&lt;br/&gt;   END Discover_Dimensions;&lt;br/&gt;&lt;br/&gt;   FUNCTION Discover_SRID( p_table_name  In VarChar2,&lt;br/&gt;                           p_column_name In VarChar2,&lt;br/&gt;                           p_owner       In VarChar2 := NULL,&lt;br/&gt;                           p_activity    In Out NoCopy codesys.TOOLS.T_Strings )&lt;br/&gt;     RETURN NUMBER&lt;br/&gt;   IS&lt;br/&gt;     TYPE t_SRIDs IS TABLE OF VARCHAR2(20);&lt;br/&gt;     v_SRIDs      t_SRIDs;&lt;br/&gt;     v_srid       VarChar2(20);&lt;br/&gt;     v_rowcount   Number;&lt;br/&gt;     v_owner      VarChar2(32);&lt;br/&gt;     v_report     VarChar2(1000);&lt;br/&gt;     v_sql        VarChar2(4000);&lt;br/&gt;   BEGIN&lt;br/&gt;     If ( p_owner Is NULL ) Then&lt;br/&gt;       v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;       v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     --&lt;br/&gt;     -- Start message&lt;br/&gt;     --&lt;br/&gt;     p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Discovering SRID...&apos;;&lt;br/&gt;     --&lt;br/&gt;     -- Check to see if all sdo_geometry objects are coded with same SRID ...&lt;br/&gt;     --&lt;br/&gt;     EXECUTE IMMEDIATE &apos;SELECT DISTINCT NVL(TO_CHAR(A.&apos;||p_column_name||&apos;.SDO_SRID),&apos;&apos;NULL&apos;&apos;) AS SRID FROM &apos; || v_owner || &apos;.&apos; || p_table_name || &apos; A&apos;&lt;br/&gt;        BULK COLLECT INTO v_SRIDs;&lt;br/&gt;     v_rowcount := v_SRIDs.COUNT;&lt;br/&gt;     IF ( v_rowcount = 1 ) THEN&lt;br/&gt;       v_srid := v_SRIDs(1);&lt;br/&gt;     ELSE&lt;br/&gt;       v_report := &apos;(&apos;;&lt;br/&gt;       &lt;&lt;list_SRIDs&gt;&gt;&lt;br/&gt;       FOR i IN v_SRIDs.First..v_SRIDs.Last LOOP&lt;br/&gt;          v_report := v_report || v_SRIDs(i) || &apos;,&apos;;&lt;br/&gt;       END LOOP list_SRIDs;&lt;br/&gt;       v_report := TRIM(TRAILING &apos;,&apos; FROM v_report) || &apos;)&apos;;&lt;br/&gt;       --&lt;br/&gt;       -- Report multi-srid result&lt;br/&gt;       --&lt;br/&gt;       p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Multiple SRIDs &apos; || v_report || &apos; exist within table. Discovering most prevalent.&apos;;&lt;br/&gt;       --&lt;br/&gt;       -- Get most prevalent srid&lt;br/&gt;       --&lt;br/&gt;       v_sql := &apos;SELECT SRID&lt;br/&gt;                   FROM ( SELECT NVL(TO_CHAR(A.&apos;||p_column_name||&apos;.SDO_SRID),&apos;&apos;NULL&apos;&apos;) AS SRID,&lt;br/&gt;                                 COUNT(*) AS SRIDCount&lt;br/&gt;                            FROM &apos;||p_table_name||&apos; a&lt;br/&gt;                           GROUP BY NVL(TO_CHAR(A.&apos;||p_column_name||&apos;.SDO_SRID),&apos;&apos;NULL&apos;&apos;)&lt;br/&gt;                           ORDER BY 2 DESC&lt;br/&gt;                        )&lt;br/&gt;                  WHERE ROWNUM = 1&apos;;&lt;br/&gt;       EXECUTE IMMEDIATE v_sql&lt;br/&gt;                    INTO v_srid;&lt;br/&gt;     END IF;&lt;br/&gt;     --&lt;br/&gt;     -- Report result&lt;br/&gt;     --&lt;br/&gt;     IF ( v_srid = &apos;NULL&apos; ) THEN&lt;br/&gt;       p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Discovered SRID IS NULL.&apos;;&lt;br/&gt;     ELSE&lt;br/&gt;       p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Discovered SRID = &apos; || v_srid;&lt;br/&gt;     END IF;&lt;br/&gt;     --&lt;br/&gt;     -- Return result&lt;br/&gt;     --&lt;br/&gt;     RETURN CASE WHEN v_srid = &apos;NULL&apos; THEN NULL ELSE TO_NUMBER(v_srid) END;&lt;br/&gt;   END Discover_SRID;&lt;br/&gt;&lt;br/&gt;   Procedure UpdateSdoMetadata( p_table_name  in varchar2,&lt;br/&gt;                                p_column_name in varchar2,&lt;br/&gt;                                p_mbr_factor  in number,&lt;br/&gt;                                p_commit      in boolean := false )&lt;br/&gt;   As&lt;br/&gt;     v_mbr_factor number := case when p_mbr_factor is null then 0 else p_mbr_factor end;&lt;br/&gt;     v_diminfo    mdsys.sdo_dim_array;&lt;br/&gt;   Begin&lt;br/&gt;     -- Check if something to process&lt;br/&gt;     If ( p_table_name is null or p_column_name is null ) Then&lt;br/&gt;       Return;&lt;br/&gt;     End If;&lt;br/&gt;&lt;br/&gt;     -- Get existing record (checks if one even exists)&lt;br/&gt;     --&lt;br/&gt;     SELECT diminfo&lt;br/&gt;       INTO v_diminfo&lt;br/&gt;       FROM user_sdo_geom_metadata&lt;br/&gt;      WHERE table_name  = UPPER(p_table_name)&lt;br/&gt;        AND column_name = UPPER(p_column_name);&lt;br/&gt;&lt;br/&gt;     -- Update the diminfo with the MBR of the existing data&lt;br/&gt;     EXECUTE IMMEDIATE &apos;SELECT MDSYS.SDO_DIM_ARRAY(&lt;br/&gt;                                MDSYS.SDO_DIM_ELEMENT(&apos;&apos;X&apos;&apos;, minx, maxx, :1),&lt;br/&gt;                                MDSYS.SDO_DIM_ELEMENT(&apos;&apos;Y&apos;&apos;, miny, maxy, :2)) as diminfo&lt;br/&gt;                     FROM ( SELECT TRUNC( MIN( v.x ) - :3,0) as minx,&lt;br/&gt;                                   ROUND( MAX( v.x ) + :4,0) as maxx,&lt;br/&gt;                                   TRUNC( MIN( v.y ) - :5,0) as miny,&lt;br/&gt;                                   ROUND( MAX( v.y ) + :6,0) as maxy&lt;br/&gt;                              FROM (SELECT SDO_AGGR_MBR(a.&apos; || p_column_name || &apos;) as mbr&lt;br/&gt;                                      FROM &apos; || p_table_name || &apos; a) b,&lt;br/&gt;                                           TABLE(mdsys.sdo_util.getvertices(b.mbr)) v&lt;br/&gt;                           )&apos;&lt;br/&gt;                 INTO v_diminfo&lt;br/&gt;                USING v_diminfo(1).sdo_tolerance,&lt;br/&gt;                      v_diminfo(2).sdo_tolerance,&lt;br/&gt;                      v_mbr_factor,v_mbr_factor,v_mbr_factor,v_mbr_factor;&lt;br/&gt;&lt;br/&gt;     -- Now update the existing record&lt;br/&gt;     --&lt;br/&gt;     UPDATE user_sdo_geom_metadata&lt;br/&gt;        SET diminfo     = v_diminfo&lt;br/&gt;      WHERE table_name  = UPPER(p_table_name)&lt;br/&gt;        AND column_name = UPPER(p_column_name);&lt;br/&gt;&lt;br/&gt;    -- Commit if requested&lt;br/&gt;    If ( p_commit ) Then&lt;br/&gt;      commit;&lt;br/&gt;    End If;&lt;br/&gt;&lt;br/&gt;    EXCEPTION&lt;br/&gt;      WHEN NO_DATA_FOUND THEN&lt;br/&gt;         raise_application_error(-20000, &apos;No SDO_METADATA record exists for &apos; || p_table_name || &apos;.&apos; || p_column_name || &apos;. Run MetadataAnalayzer&apos;);&lt;br/&gt;   End UpdateSdoMetadata;&lt;br/&gt;&lt;br/&gt;   Function GetSpatialIndexName( p_table_name  In VarChar2,&lt;br/&gt;                                 p_column_name In VarChar2,&lt;br/&gt;                                 p_owner       In VarChar2 := NULL )&lt;br/&gt;     Return VarChar2&lt;br/&gt;   IS&lt;br/&gt;      v_index_name  ALL_INDEXES.INDEX_NAME%TYPE;&lt;br/&gt;      v_owner       VarChar2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;      /*** I have seen this SQL break because an entry for a spatial index existed in all_indexes BUT the metadata entry in all_sdo_index_metadata didn&apos;t!&lt;br/&gt;      SELECT INDEX_NAME&lt;br/&gt;        INTO v_index_name&lt;br/&gt;        FROM all_indexes ai&lt;br/&gt;             INNER JOIN&lt;br/&gt;             all_sdo_index_metadata asi&lt;br/&gt;             ON ( asi.sdo_index_owner = ai.owner&lt;br/&gt;                  AND&lt;br/&gt;                  asi.sdo_index_name  = ai.index_name&lt;br/&gt;                )&lt;br/&gt;       WHERE ai.owner            = UPPER(v_owner)&lt;br/&gt;         AND ai.table_name       = UPPER(p_table_name)&lt;br/&gt;         AND ai.index_type       = &apos;DOMAIN&apos;&lt;br/&gt;         AND asi.sdo_column_name = &apos;&quot;&apos; || UPPER(p_column_name) || &apos;&quot;&apos;;&lt;br/&gt;      So... go for simplicity itself...&lt;br/&gt;      **/&lt;br/&gt;      SELECT INDEX_NAME&lt;br/&gt;        INTO v_index_name&lt;br/&gt;        FROM all_indexes ai&lt;br/&gt;       WHERE ai.owner      = UPPER(v_owner)&lt;br/&gt;         AND ai.table_name = UPPER(p_table_name)&lt;br/&gt;         AND ai.index_type = &apos;DOMAIN&apos;&lt;br/&gt;         AND ai.ITYP_OWNER = &apos;MDSYS&apos;&lt;br/&gt;         AND ai.ITYP_NAME  = &apos;SPATIAL_INDEX&apos;;&lt;br/&gt;      RETURN v_index_name;&lt;br/&gt;      EXCEPTION&lt;br/&gt;        WHEN OTHERS THEN&lt;br/&gt;          RETURN NULL;&lt;br/&gt;   END GetSpatialIndexName;&lt;br/&gt;&lt;br/&gt;   Procedure DropSpatialIndex( p_table_name  In VarChar2,&lt;br/&gt;                               p_column_Name In VarChar2,&lt;br/&gt;                               p_owner       In VarChar2 := NULL )&lt;br/&gt;   Is&lt;br/&gt;     v_index_name VarChar2(32);&lt;br/&gt;     v_owner      VarChar2(32);&lt;br/&gt;   Begin&lt;br/&gt;     If ( p_owner Is NULL ) Then&lt;br/&gt;       v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;       v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     v_index_name := GetSpatialIndexName( p_table_name, p_column_name, v_owner );&lt;br/&gt;     If ( v_Index_Name IS NOT NULL ) Then&lt;br/&gt;       EXECUTE IMMEDIATE &apos;DROP INDEX &apos; || v_owner || &apos;.&apos; || v_index_name || &apos; FORCE&apos;;&lt;br/&gt;     End If;&lt;br/&gt;     EXCEPTION&lt;br/&gt;       WHEN OTHERS THEN&lt;br/&gt;            NULL;&lt;br/&gt;   End DropSpatialIndex;&lt;br/&gt;&lt;br/&gt;   Procedure SpatialIndexer( p_table_name      In VarChar2,&lt;br/&gt;                             p_column_name     In VarChar2,&lt;br/&gt;                             p_owner           In VarChar2    := NULL,&lt;br/&gt;                             p_spatial_type    In VarChar2    := NULL,&lt;br/&gt;                             p_check           In Boolean     := FALSE,&lt;br/&gt;                             p_dimensions      In Number      := 2,&lt;br/&gt;                             p_tablespace      In VarChar2    := NULL,&lt;br/&gt;                             p_work_tablespace In VarChar2    := NULL,&lt;br/&gt;                             p_pin_non_leaf    In Boolean     := FALSE,&lt;br/&gt;                             p_stats_percent   In PLS_INTEGER := 0,&lt;br/&gt;                             p_activity        In Out NoCopy codesys.TOOLS.T_Strings)&lt;br/&gt;   Is&lt;br/&gt;      v_spindex_name  VarChar2(32);&lt;br/&gt;      v_sql           VarChar2(1000);&lt;br/&gt;      v_parameters    VarChar2(1000);&lt;br/&gt;      v_spatial_type  VarChar2(100) := p_spatial_type;&lt;br/&gt;      v_name_length   Number        := 30;&lt;br/&gt;      v_owner         VarChar2(32);&lt;br/&gt;      v_stats_percent PLS_INTEGER   := p_stats_percent;&lt;br/&gt;&lt;br/&gt;      FUNCTION Generate_Spatial_Index_Params( p_spatial_type    IN VARCHAR2,&lt;br/&gt;                                              p_tablespace      IN VARCHAR2 := NULL,&lt;br/&gt;                                              p_work_tablespace IN VARCHAR2 := NULL,&lt;br/&gt;                                              p_transactional   IN BOOLEAN  := FALSE,&lt;br/&gt;                                              p_3D              IN BOOLEAN  := FALSE )&lt;br/&gt;        RETURN varchar2&lt;br/&gt;      IS&lt;br/&gt;        v_parameters   VARCHAR2(1000);&lt;br/&gt;      BEGIN&lt;br/&gt;         v_parameters := &apos;sdo_indx_dims=2&apos;;&lt;br/&gt;         IF ( p_3D And DBMS_DB_VERSION.VERSION &gt;= 11 ) THEN&lt;br/&gt;           v_parameters := &apos;sdo_indx_dims=3&apos;;&lt;br/&gt;         END IF;&lt;br/&gt;         IF ( p_spatial_type &lt;&gt; c_Collection ) THEN&lt;br/&gt;           v_parameters := v_parameters || &apos;, layer_gtype=&apos;||p_spatial_type;&lt;br/&gt;         END IF;&lt;br/&gt;         If ( DBMS_DB_VERSION.VERSION &gt;= 10 ) Then&lt;br/&gt;           v_parameters := v_parameters || &apos;, sdo_non_leaf_tbl=true&apos;;&lt;br/&gt;           IF ( p_transactional ) THEN&lt;br/&gt;              v_parameters := v_parameters || &apos;, sdo_rtr_pctfree=40, sdo_dml_batch_size=1000&apos;;&lt;br/&gt;           ELSE&lt;br/&gt;              v_parameters := v_parameters || &apos;, sdo_rtr_pctfree=1&apos;;&lt;br/&gt;           END IF;&lt;br/&gt;           IF ( p_tablespace IS NOT NULL ) THEN&lt;br/&gt;             v_parameters := v_parameters || &apos;, tablespace=&apos;||p_tablespace;&lt;br/&gt;           END IF;&lt;br/&gt;           IF ( p_work_tablespace IS NOT NULL ) THEN&lt;br/&gt;             v_parameters := v_parameters || &apos;, work_tablespace=&apos;||p_work_tablespace;&lt;br/&gt;           END IF;&lt;br/&gt;         End If;&lt;br/&gt;        RETURN v_parameters;&lt;br/&gt;      END Generate_Spatial_Index_Params;&lt;br/&gt;&lt;br/&gt;      Function CheckMetadata&lt;br/&gt;        Return Boolean&lt;br/&gt;      Is&lt;br/&gt;        v_diminfo            MDSYS.SDO_DIM_ARRAY;&lt;br/&gt;      Begin&lt;br/&gt;        -- Check if USER_SDO_GEOM_METADATA record exists&lt;br/&gt;        SELECT diminfo&lt;br/&gt;          INTO v_diminfo&lt;br/&gt;          FROM ALL_SDO_GEOM_METADATA&lt;br/&gt;         WHERE       owner = v_owner&lt;br/&gt;           AND  table_name = UPPER(p_table_name)&lt;br/&gt;           AND column_name = UPPER(p_column_name);&lt;br/&gt;        Return True;&lt;br/&gt;        EXCEPTION&lt;br/&gt;          WHEN NO_DATA_FOUND THEN&lt;br/&gt;             Return False;&lt;br/&gt;      End CheckMetadata;&lt;br/&gt;&lt;br/&gt;   Begin&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;      If ( p_check ) Then&lt;br/&gt;         If ( Not CheckMetadata ) Then&lt;br/&gt;            p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;No user_sdo_geom_metadata record exists: Run MetadataAnalyzer.&apos;;&lt;br/&gt;	          Return;&lt;br/&gt;         End If;&lt;br/&gt;         If ( NOT hasData( p_table_name, v_owner ) ) Then&lt;br/&gt;            p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;No data in table: Skipping object.&apos;;&lt;br/&gt;            Return;&lt;br/&gt;         End If;&lt;br/&gt;      End If;&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Dropping existing index.&apos;;&lt;br/&gt;      DropSpatialIndex( p_table_name  =&gt; p_table_name,&lt;br/&gt;                        p_column_name =&gt; p_column_name,&lt;br/&gt;                        p_owner       =&gt; v_owner );&lt;br/&gt;      v_spindex_name := Generate_Object_Name(p_object_name   =&gt; p_table_name,&lt;br/&gt;                                             p_column_name   =&gt; p_column_name,&lt;br/&gt;                                             p_obj_shortname =&gt; REPLACE(TRANSLATE(p_table_name ,&apos;AEIOU&apos;,&apos;_&apos;),&apos;_&apos;),&lt;br/&gt;                                             p_col_shortname =&gt; REPLACE(TRANSLATE(p_column_name,&apos;AEIOU&apos;,&apos;_&apos;),&apos;_&apos;),&lt;br/&gt;                                             p_prefix        =&gt; c_spindex_prefix,&lt;br/&gt;                                             p_suffix        =&gt; c_spindex_suffix,&lt;br/&gt;                                             p_name_length   =&gt; v_name_length );&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Generated object name is &apos; || v_spindex_name;&lt;br/&gt;      If ( p_spatial_type IS NULL ) Then&lt;br/&gt;        v_spatial_type := Discover_SpatialType(p_table_name, p_column_name, v_owner, p_activity);&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Discovered spatial type is &apos; || v_spatial_type;&lt;br/&gt;        If ( v_spatial_type = &apos;NO_DATA&apos; ) Then&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Indexing terminated&apos;;&lt;br/&gt;          Return;&lt;br/&gt;        End If;&lt;br/&gt;      End If;&lt;br/&gt;      v_parameters := Generate_Spatial_Index_Params( p_spatial_type     =&gt; v_spatial_type,&lt;br/&gt;                                                     p_tablespace       =&gt; p_tablespace,&lt;br/&gt;                                                     p_work_tablespace  =&gt; p_work_tablespace,&lt;br/&gt;                                                     p_transactional    =&gt; FALSE,&lt;br/&gt;                                                     p_3D               =&gt; ( p_dimensions &lt;&gt; 2 ) );&lt;br/&gt;      p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Generated spatial index parameters are (&apos;|| v_parameters ||&apos;)&apos;;&lt;br/&gt;      v_sql := &apos;CREATE INDEX &apos; || v_owner || &apos;.&apos; || v_spindex_name ||&lt;br/&gt;                        &apos; ON &apos; || v_owner || &apos;.&apos; || p_table_name || &apos;(&apos; || p_column_name||&apos;)&apos; ||&lt;br/&gt;                        &apos; INDEXTYPE IS MDSYS.SPATIAL_INDEX PARAMETERS(&apos;&apos;&apos; || v_parameters || &apos;&apos;&apos;)&apos;;&lt;br/&gt;      Execute_Statement(v_sql,TRUE);&lt;br/&gt;      --&lt;br/&gt;      -- Check if exists&lt;br/&gt;      --&lt;br/&gt;      If ( GetSpatialIndexName( p_table_name  =&gt; p_table_name,&lt;br/&gt;                                p_column_name =&gt; p_column_name,&lt;br/&gt;                                p_owner       =&gt; v_owner )&lt;br/&gt;           IS NOT NULL ) Then&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Index successfully created.&apos;;&lt;br/&gt;        --&lt;br/&gt;        -- Get Non-Leaf details if created&lt;br/&gt;        --&lt;br/&gt;        If ( p_pin_non_leaf ) Then&lt;br/&gt;          v_sql := NonLeaf_Spatial_IndexName( p_spindex_name =&gt; v_spindex_name,&lt;br/&gt;                                              p_nl_size      =&gt; v_name_length,&lt;br/&gt;                                              p_owner        =&gt; v_owner,&lt;br/&gt;                                              p_pin          =&gt; p_pin_non_leaf );&lt;br/&gt;          p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Non-Leaf Name(Size MB): &apos; || v_sql || &apos;(&apos; || v_name_length || &apos;) and pinned into memory.&apos;;&lt;br/&gt;        End If;&lt;br/&gt;        --&lt;br/&gt;        -- Generate statistics on created index&lt;br/&gt;        --&lt;br/&gt;        If ( v_stats_percent Is Not NULL ) Then&lt;br/&gt;          If ( v_stats_percent &gt; 100 ) Then&lt;br/&gt;             v_stats_percent := 100;&lt;br/&gt;          ElsIf ( v_stats_percent &lt; 0 ) Then&lt;br/&gt;             v_stats_percent := 0;&lt;br/&gt;          End If;&lt;br/&gt;          If ( v_stats_percent Between 1 And 100 ) Then&lt;br/&gt;            BEGIN&lt;br/&gt;              DBMS_STATS.GATHER_INDEX_STATS( v_owner,&lt;br/&gt;                                             v_spindex_name,&lt;br/&gt;                                             estimate_percent =&gt; v_stats_percent );&lt;br/&gt;              p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Statistics gathered on &apos;||v_stats_percent||&apos;% of the spatial index.&apos;;&lt;br/&gt;              EXCEPTION&lt;br/&gt;                WHEN OTHERS THEN&lt;br/&gt;                    p_activity.EXTEND(1); p_activity(p_activity.LAST) :=  &apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos;: Terminate spatial index stats.&apos;;&lt;br/&gt;            END;&lt;br/&gt;          End If;&lt;br/&gt;        End If;&lt;br/&gt;      Else&lt;br/&gt;        p_activity.EXTEND(1); p_activity(p_activity.LAST) := &apos;Index did not build.&apos;;&lt;br/&gt;      End If;&lt;br/&gt;   End SpatialIndexer;&lt;br/&gt;&lt;br/&gt;   Procedure SpatialIndexUnindexed( p_owner           In VarChar2    := NULL,&lt;br/&gt;                                    p_check           In Boolean     := FALSE,&lt;br/&gt;                                    p_tablespace      In VarChar2    := NULL,&lt;br/&gt;                                    p_work_tablespace In VarChar2    := NULL,&lt;br/&gt;                                    p_pin_non_leaf    In Boolean     := FALSE,&lt;br/&gt;                                    p_stats_percent   In PLS_INTEGER := 0 )&lt;br/&gt;   Is&lt;br/&gt;     v_owner    VarChar2(32);&lt;br/&gt;     v_activity codesys.TOOLS.T_Strings:= codesys.TOOLS.T_Strings(&apos; &apos;);&lt;br/&gt;&lt;br/&gt;     -- Declare cursor for all table/column pairs with no index...&lt;br/&gt;     CURSOR c_no_index_table_columns( p_owner In VarChar2 ) Is&lt;br/&gt;       SELECT atc.table_name,&lt;br/&gt;              atc.column_name&lt;br/&gt;         FROM all_objects ao&lt;br/&gt;              INNER JOIN&lt;br/&gt;              all_tab_cols atc ON ( atc.owner      = ao.owner&lt;br/&gt;                                    AND&lt;br/&gt;                                    atc.table_name = ao.object_name )&lt;br/&gt;        WHERE ao.owner        = p_owner&lt;br/&gt;          AND ao.object_type  = &apos;TABLE&apos;&lt;br/&gt;          AND ( atc.data_type = &apos;SDO_GEOMETRY&apos;&lt;br/&gt;                AND&lt;br/&gt;                atc.hidden_column  = &apos;NO&apos;&lt;br/&gt;                AND&lt;br/&gt;                atc.virtual_column = &apos;NO&apos; )&lt;br/&gt;      MINUS&lt;br/&gt;      SELECT atc.table_name,&lt;br/&gt;             atc.column_name&lt;br/&gt;        FROM all_objects ao&lt;br/&gt;             INNER JOIN all_tab_cols atc ON ( atc.owner =  ao.owner AND atc.table_name =  ao.object_name )&lt;br/&gt;             INNER JOIN all_indexes   ai ON (  ai.owner = atc.owner AND  ai.table_name = atc.table_name )&lt;br/&gt;             INNER JOIN all_sdo_index_metadata asim&lt;br/&gt;             ON ( asim.sdo_index_owner = ai.owner&lt;br/&gt;                  AND&lt;br/&gt;                  asim.sdo_index_name = ai.index_name&lt;br/&gt;                  AND&lt;br/&gt;                  REPLACE(asim.sdo_column_name,&apos;&quot;&apos;,&apos;&apos;) = atc.column_name&lt;br/&gt;                )&lt;br/&gt;       WHERE ao.owner        = p_owner&lt;br/&gt;         AND ao.object_type  = &apos;TABLE&apos;&lt;br/&gt;         AND ( atc.data_type = &apos;SDO_GEOMETRY&apos;&lt;br/&gt;               AND&lt;br/&gt;               atc.hidden_column  = &apos;NO&apos;&lt;br/&gt;               AND&lt;br/&gt;               atc.virtual_column = &apos;NO&apos;&lt;br/&gt;             )&lt;br/&gt;         AND ai.index_type = &apos;DOMAIN&apos;&lt;br/&gt;         ORDER BY 1, 2;&lt;br/&gt;&lt;br/&gt;   Begin&lt;br/&gt;     If ( p_owner IS NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     dbms_output.put_line(&apos;Processing table/sdo_geometry columns for &apos; || p_owner || &apos; ... &apos;);&lt;br/&gt;     FOR rec IN c_no_index_table_columns(v_owner) Loop&lt;br/&gt;       dbms_output.put_line(LPAD(&apos;_&apos;,2,&apos;_&apos;)|| rec.table_name || &apos;.&apos; || rec.column_name);&lt;br/&gt;       SpatialIndexer( p_table_name      =&gt; rec.table_name,&lt;br/&gt;                       p_column_name     =&gt; rec.column_name,&lt;br/&gt;                       p_owner           =&gt; v_owner,&lt;br/&gt;                       p_spatial_type    =&gt; NULL,&lt;br/&gt;                       p_check           =&gt; p_check,&lt;br/&gt;                       p_dimensions      =&gt; NULL,&lt;br/&gt;                       p_tablespace      =&gt; p_tablespace,&lt;br/&gt;                       p_work_tablespace =&gt; p_work_tablespace,&lt;br/&gt;                       p_pin_non_leaf    =&gt; p_pin_non_leaf,&lt;br/&gt;                       p_stats_percent   =&gt; p_stats_percent,&lt;br/&gt;                       p_activity        =&gt; v_activity );&lt;br/&gt;     End Loop;&lt;br/&gt;   End SpatialIndexUnindexed;&lt;br/&gt;&lt;br/&gt;   /***&lt;br/&gt;   **  @History : Simon Greener - January 2007 - Updated for 3D data&lt;br/&gt;   **  @History : Simon Greener -  August 2007 - Moved common indexing functions out so new Spatial Indexing function can use them...&lt;br/&gt;   ***/&lt;br/&gt;   Procedure MetadataAnalyzer( p_owner                   IN VARCHAR2            := NULL,&lt;br/&gt;                               p_table_regex             IN VARCHAR2            := &apos;*&apos;,&lt;br/&gt;                               p_column_regex            IN VARCHAR2            := &apos;*&apos;,&lt;br/&gt;                               p_fixed_srid              IN NUMBER              := -9999,&lt;br/&gt;                               p_fixed_diminfo           IN MDSYS.SDO_DIM_ARRAY := NULL,&lt;br/&gt;                               p_tablespace              IN VARCHAR2            := NULL,&lt;br/&gt;                               p_work_tablespace         IN VARCHAR2            := NULL,&lt;br/&gt;                               p_pin_non_leaf            IN BOOLEAN             := FALSE,&lt;br/&gt;                               p_stats_percent           IN PLS_INTEGER         := 100,&lt;br/&gt;                               p_min_projected_tolerance IN NUMBER              := 0.00005,&lt;br/&gt;                               p_rectify_geometry        IN BOOLEAN             := FALSE )&lt;br/&gt;   IS&lt;br/&gt;      -- Some constants&lt;br/&gt;      c_geographic             MDSYS.SDO_COORD_REF_SYS.coord_ref_sys_kind%TYPE := &apos;GEOGRAPHIC&apos;;&lt;br/&gt;      c_commit_interval        NUMBER := 1000;&lt;br/&gt;      -- Variables&lt;br/&gt;      v_owner                  VarChar2(32);&lt;br/&gt;      v_activity               codesys.TOOLS.T_Strings:= codesys.TOOLS.T_Strings(&apos; &apos;);&lt;br/&gt;      action                   PLS_INTEGER;&lt;br/&gt;      v_geom_metadata_rec      USER_SDO_GEOM_METADATA%ROWTYPE;&lt;br/&gt;      v_data                   BOOLEAN;&lt;br/&gt;      v_discover_data_extent   BOOLEAN;&lt;br/&gt;      v_id                     INTEGER;&lt;br/&gt;      v_managed_id             INTEGER;&lt;br/&gt;      v_srid                   NUMBER;&lt;br/&gt;      v_dimensions             NUMBER;&lt;br/&gt;      v_start_date             DATE;&lt;br/&gt;      v_rowtext                VARCHAR2(4000);&lt;br/&gt;      v_sql                    VARCHAR2(4000);&lt;br/&gt;      v_spatial_type           VARCHAR2(20);&lt;br/&gt;      v_spindex_name           USER_INDEXES.INDEX_NAME%TYPE;&lt;br/&gt;      v_coord_ref              MDSYS.SDO_COORD_REF_SYS.coord_ref_sys_kind%TYPE;&lt;br/&gt;      v_rubbish                VARCHAR2(4000);&lt;br/&gt;      BAD_STATS_PARAMETER      EXCEPTION;&lt;br/&gt;&lt;br/&gt;      CURSOR c_geom_columns ( p_owner In VarChar2,&lt;br/&gt;                              p_regex IN VARCHAR2 ) IS&lt;br/&gt;       SELECT atc.table_name,&lt;br/&gt;              atc.column_name&lt;br/&gt;         FROM all_objects ao&lt;br/&gt;              INNER JOIN&lt;br/&gt;              all_tab_cols atc ON ( atc.owner      = ao.owner&lt;br/&gt;                                    AND&lt;br/&gt;                                    atc.table_name = ao.object_name )&lt;br/&gt;        WHERE ao.owner       = p_owner&lt;br/&gt;          AND ao.object_type = &apos;TABLE&apos;&lt;br/&gt;          AND REGEXP_LIKE(ao.object_name,p_regex)&lt;br/&gt;          /** SGG Removed 27th October 2015&lt;br/&gt;          AND NOT EXISTS (SELECT 1&lt;br/&gt;                            FROM SYS.DBA_RECYCLEBIN AR  -- Need to GRANT SELECT ON DBA_RECYCLEBIN TO codesys; in SYS schema to work&lt;br/&gt;                           WHERE ar.owner = ao.owner&lt;br/&gt;                             AND ar.object_name = ao.object_name )&lt;br/&gt;          **/&lt;br/&gt;          AND ( atc.data_type = &apos;SDO_GEOMETRY&apos;&lt;br/&gt;                AND&lt;br/&gt;                atc.hidden_column  = &apos;NO&apos;&lt;br/&gt;                AND&lt;br/&gt;                atc.virtual_column = &apos;NO&apos; );&lt;br/&gt;&lt;br/&gt;      Function Create_Diminfo( p_dimensions  IN NUMBER,&lt;br/&gt;                               p_lb          IN NUMBER,&lt;br/&gt;                               p_ub          IN NUMBER,&lt;br/&gt;                               p_tolerance   IN NUMBER )&lt;br/&gt;        Return MDSYS.SDO_DIM_ARRAY&lt;br/&gt;      Is&lt;br/&gt;         v_diminfo MDSYS.SDO_DIM_ARRAY;&lt;br/&gt;      Begin&lt;br/&gt;        v_diminfo := MDSYS.SDO_DIM_ARRAY( MDSYS.SDO_DIM_ELEMENT(&apos;X&apos;,p_lb,p_ub,p_tolerance),&lt;br/&gt;                                          MDSYS.SDO_DIM_ELEMENT(&apos;Y&apos;,p_lb,p_ub,p_tolerance));&lt;br/&gt;        If p_dimensions &gt; 2 Then&lt;br/&gt;          v_diminfo.EXTEND(1);&lt;br/&gt;          v_diminfo(3) := MDSYS.SDO_DIM_ELEMENT(&apos;Z&apos;,p_lb,p_ub,p_tolerance);&lt;br/&gt;          If ( p_dimensions &gt; 3 ) Then&lt;br/&gt;             v_diminfo.EXTEND(1);&lt;br/&gt;             v_diminfo(4) := MDSYS.SDO_DIM_ELEMENT(&apos;M&apos;,p_lb,p_ub,p_tolerance);&lt;br/&gt;          End If;&lt;br/&gt;        End If;&lt;br/&gt;        Return v_diminfo;&lt;br/&gt;      End Create_Diminfo;&lt;br/&gt;&lt;br/&gt;      /** @function    Analysis_Report_Row&lt;br/&gt;      *   @description Simply writes a row to the COLUMN_ANALYSES table that reports what actions occured.&lt;br/&gt;      *   @param       p_tabsize  Integer of the amount of padding to use when writing to dbms_output.&lt;br/&gt;      *   @param       p_text     Text to be written to table/dbms_output.&lt;br/&gt;      */&lt;br/&gt;      Procedure Analysis_Report_Row( p_tabsize     In PLS_Integer,&lt;br/&gt;                                     p_text        In VarChar2 )&lt;br/&gt;      Is&lt;br/&gt;         v_id     INTEGER;&lt;br/&gt;         v_ts     codesys.COLUMN_ANALYSES.ANALYSIS_DATE%type := SYSTIMESTAMP;&lt;br/&gt;      Begin&lt;br/&gt;         SELECT codesys.COLUMN_ANALYSES_ID.NEXTVAL INTO v_id FROM DUAL;&lt;br/&gt;         INSERT INTO codesys.COLUMN_ANALYSES ( ID, Managed_Column_ID, analysis_date, result )&lt;br/&gt;                VALUES ( v_id, v_managed_id, v_ts, p_text );&lt;br/&gt;         dbms_output.put_line(SUBSTR(LPAD(&apos;_&apos;,p_tabsize,&apos;_&apos;) || p_text,1,255));&lt;br/&gt;      End Analysis_Report_Row;&lt;br/&gt;&lt;br/&gt;      Function Check_DimInfo_Dimensions( p_dimensions  IN NUMBER,&lt;br/&gt;                                         p_diminfo     IN MDSYS.SDO_DIM_ARRAY )&lt;br/&gt;        Return MDSYS.SDO_DIM_ARRAY&lt;br/&gt;      Is&lt;br/&gt;        v_dimcount Integer;&lt;br/&gt;        v_diminfo  MDSYS.SDO_DIM_ARRAY := p_diminfo;&lt;br/&gt;      Begin&lt;br/&gt;        v_dimcount := p_diminfo.COUNT;&lt;br/&gt;        If ( v_dimcount &lt; 2 ) Then&lt;br/&gt;          v_diminfo := Create_Diminfo( p_dimensions, c_min_number, c_max_number, c_max_tolerance );&lt;br/&gt;        Else&lt;br/&gt;          If v_dimcount = p_dimensions Then&lt;br/&gt;            v_diminfo := p_diminfo;&lt;br/&gt;          ElsIf ( v_dimcount &lt; p_dimensions ) Then&lt;br/&gt;            v_diminfo := p_diminfo;&lt;br/&gt;            v_diminfo.EXTEND(p_dimensions - v_dimcount);&lt;br/&gt;            If ( v_dimcount = 2 ) Then&lt;br/&gt;              v_diminfo(3) := MDSYS.SDO_DIM_ELEMENT(&apos;Z&apos;,c_min_number,c_max_number,c_max_tolerance);&lt;br/&gt;            Else&lt;br/&gt;              v_diminfo(4) := MDSYS.SDO_DIM_ELEMENT(&apos;M&apos;,c_min_number,c_max_number,c_max_tolerance);&lt;br/&gt;            End If;&lt;br/&gt;            Analysis_Report_Row( 5, &apos;DimInfo modified to include &apos;||to_char(p_dimensions - v_dimcount)||&apos; extra dim_elements.&apos; );&lt;br/&gt;          End If;&lt;br/&gt;        End If;&lt;br/&gt;        Return v_diminfo;&lt;br/&gt;      End Check_DimInfo_Dimensions;&lt;br/&gt;&lt;br/&gt;      Procedure Update_Table_Column_SRID( p_table_name  IN VARCHAR2,&lt;br/&gt;                                          p_column_name IN VARCHAR2,&lt;br/&gt;                                          p_srid        IN NUMBER )&lt;br/&gt;      IS&lt;br/&gt;      BEGIN&lt;br/&gt;        Analysis_Report_Row( 4, &apos;Updating SRID...&apos;);&lt;br/&gt;        EXECUTE IMMEDIATE &apos;UPDATE &apos;     || p_table_name  || &apos; a &apos; ||&lt;br/&gt;                            &apos; SET a.&apos;   || p_column_name || &apos;.sdo_srid  = :1 &apos; ||&lt;br/&gt;                            &apos; WHERE a.&apos; || p_column_name || &apos;.sdo_srid &lt;&gt; :2&apos;&lt;br/&gt;                    USING p_srid,&lt;br/&gt;                          p_srid;&lt;br/&gt;        COMMIT;&lt;br/&gt;        Analysis_Report_Row( 8, &apos;SRID updated.&apos; );&lt;br/&gt;        EXCEPTION&lt;br/&gt;          WHEN OTHERS THEN&lt;br/&gt;            Analysis_Report_Row(6,&apos;Error updating SRID (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE));&lt;br/&gt;            RETURN ;&lt;br/&gt;      END Update_Table_Column_SRID;&lt;br/&gt;&lt;br/&gt;      FUNCTION Discover_Data_Extent( p_owner        IN VARCHAR2,&lt;br/&gt;                                     p_spatial_type IN VARCHAR2,&lt;br/&gt;                                     p_table_name   IN VARCHAR2,&lt;br/&gt;                                     p_column_name  IN VARCHAR2,&lt;br/&gt;                                     p_coord_ref    IN VARCHAR2,&lt;br/&gt;                                     p_diminfo      IN OUT NOCOPY MDSYS.SDO_DIM_ARRAY )&lt;br/&gt;        RETURN BOOLEAN&lt;br/&gt;      IS&lt;br/&gt;        v_sql    VARCHAR2(4000);&lt;br/&gt;        v_x_lb   NUMBER;&lt;br/&gt;        v_x_ub   NUMBER;&lt;br/&gt;        v_y_lb   NUMBER;&lt;br/&gt;        v_y_ub   NUMBER;&lt;br/&gt;        v_z_lb   NUMBER;&lt;br/&gt;        v_z_ub   NUMBER;&lt;br/&gt;      BEGIN&lt;br/&gt;         Analysis_Report_Row( 4, &apos;Discovering Data Extent...&apos;);&lt;br/&gt;         -- Get maximum extent of the actual data into our record (plus a bit)....&lt;br/&gt;         -- Need to modify for &gt; 3D data discovery...&lt;br/&gt;         v_sql := &apos;SELECT min(c.x) as x_lb, &apos; ||&lt;br/&gt;                         &apos;max(c.x) as x_ub, &apos; ||&lt;br/&gt;                         &apos;min(c.y) as y_lb, &apos; ||&lt;br/&gt;                         &apos;max(c.y) as y_ub&apos;;&lt;br/&gt;         Analysis_Report_Row( 6, &apos;p_DimInfo count is = &apos; || p_diminfo.COUNT || &apos; x sdo_tolerance is &apos; || p_diminfo(1).sdo_tolerance);&lt;br/&gt;         If ( p_diminfo.COUNT &gt; 2 ) Then&lt;br/&gt;           v_sql := v_sql || &apos;, &apos; ||&lt;br/&gt;                         &apos;min(c.z) as z_lb, &apos; ||&lt;br/&gt;                         &apos;max(c.z) as z_ub&apos;;&lt;br/&gt;         End If;&lt;br/&gt;         v_sql := v_sql || &apos;&lt;br/&gt;                   FROM &apos; || p_table_name||&apos; g,&lt;br/&gt;                        TABLE( mdsys.sdo_util.getvertices(mdsys.sdo_3gl.mbr_geometry(g.&apos; || p_column_name||&apos;,:1) )) c&lt;br/&gt;                  WHERE g.&apos;||p_column_name||&apos; IS NOT NULL&apos;;&lt;br/&gt;/* This wasn&apos;t cause of problem                    AND codesys.TOOLS.isCompound(g.geom.sdo_elem_info) = 0&apos;; */&lt;br/&gt;&lt;br/&gt;         If ( p_diminfo.COUNT = 2 ) Then&lt;br/&gt;           EXECUTE IMMEDIATE v_sql&lt;br/&gt;                        INTO v_x_lb, v_x_ub, v_y_lb, v_y_ub&lt;br/&gt;                        USING p_diminfo;&lt;br/&gt;         Else&lt;br/&gt;           EXECUTE IMMEDIATE v_sql&lt;br/&gt;                        INTO v_x_lb, v_x_ub, v_y_lb, v_y_ub, v_z_lb, v_z_ub&lt;br/&gt;                        USING p_diminfo;&lt;br/&gt;         End If;&lt;br/&gt;&lt;br/&gt;         -- Generate some wiggle room...&lt;br/&gt;         -- If geodetic we will not subtract/add 1 to the extents in case we turn things like -90 to -91!&lt;br/&gt;         IF ( p_coord_ref &lt;&gt; c_geographic ) THEN&lt;br/&gt;           p_diminfo(1).sdo_lb := v_x_lb - 1;&lt;br/&gt;           p_diminfo(1).sdo_ub := v_x_ub - 1;&lt;br/&gt;           p_diminfo(2).sdo_lb := v_y_lb + 1;&lt;br/&gt;           p_diminfo(2).sdo_ub := v_y_ub + 1;&lt;br/&gt;         ELSE&lt;br/&gt;           p_diminfo(1).sdo_lb := v_x_lb;&lt;br/&gt;           p_diminfo(1).sdo_ub := v_x_ub;&lt;br/&gt;           p_diminfo(2).sdo_lb := v_y_lb;&lt;br/&gt;           p_diminfo(2).sdo_ub := v_y_ub;&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         If ( p_diminfo.COUNT = 2 ) Then&lt;br/&gt;           Analysis_Report_Row( 5,&lt;br/&gt;                                &apos;Discovered Extent is (&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_lb || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_lb ||&lt;br/&gt;                                &apos;)(&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_ub || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_ub  ||&lt;br/&gt;                                &apos;)&apos;&lt;br/&gt;                              );&lt;br/&gt;         Else&lt;br/&gt;           p_diminfo(3) := MDSYS.SDO_DIM_ELEMENT(&apos;Z&apos;,v_z_lb,v_z_ub,0.5);&lt;br/&gt;           Analysis_Report_Row( 5,&lt;br/&gt;                                &apos;Discovered Extent is (&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_lb || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_lb || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(3).sdo_lb ||&lt;br/&gt;                                &apos;)(&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_ub || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_ub || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(3).sdo_ub  ||&lt;br/&gt;                                &apos;)&apos;&lt;br/&gt;                              );&lt;br/&gt;         End If;&lt;br/&gt;         RETURN TRUE;&lt;br/&gt;         EXCEPTION&lt;br/&gt;          WHEN OTHERS THEN&lt;br/&gt;            Analysis_Report_Row( 6, &apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos; encountered when discovering extent with &apos; || v_sql);&lt;br/&gt;            RETURN FALSE;&lt;br/&gt;      END Discover_Data_Extent;&lt;br/&gt;&lt;br/&gt;      FUNCTION GetC2M( p_SRID IN NUMBER )&lt;br/&gt;        RETURN NUMBER&lt;br/&gt;      IS&lt;br/&gt;        v_c2m           NUMBER; -- Metric conversion from SRID unit to meters&lt;br/&gt;      BEGIN&lt;br/&gt;         v_c2m := 1;&lt;br/&gt;         IF ( p_SRID IS NOT NULL ) THEN&lt;br/&gt;           BEGIN&lt;br/&gt;             SELECT TO_NUMBER(TRIM(substr(comma_pair,INSTR(comma_pair,&apos;,&apos;)+1))) AS c2m&lt;br/&gt;               INTO v_c2m&lt;br/&gt;               FROM (SELECT REPLACE(SUBSTR(remainder,1,INSTR(remainder,&apos;]&apos;)-1),&apos;&quot;&apos;) as comma_pair&lt;br/&gt;                       FROM (SELECT SUBSTR(wktext,INSTR(wktext,&apos;UNIT [&quot;&apos;,-1) + LENGTH(&apos;UNIT [&quot;&apos;)) as remainder&lt;br/&gt;                               FROM mdsys.cs_srs&lt;br/&gt;                              WHERE SRID = p_SRID&lt;br/&gt;                                AND wktext IS NOT NULL )&lt;br/&gt;                    );&lt;br/&gt;             EXCEPTION&lt;br/&gt;               WHEN NO_DATA_FOUND THEN&lt;br/&gt;                 v_c2m := 1;&lt;br/&gt;           END;&lt;br/&gt;         END IF;&lt;br/&gt;         RETURN v_c2m;&lt;br/&gt;      END GetC2M;&lt;br/&gt;&lt;br/&gt;      PROCEDURE Check_GType_Is_Current( p_table_name  IN VARCHAR2,&lt;br/&gt;                                        p_column_name IN VARCHAR2 )&lt;br/&gt;      IS&lt;br/&gt;        v_current NUMBER;&lt;br/&gt;      BEGIN&lt;br/&gt;        EXECUTE IMMEDIATE &apos;SELECT /*+FIRST_ROWS(1)*/ 0 &apos; ||&lt;br/&gt;                            &apos;FROM &apos;||p_table_name || &apos; A &apos; ||&lt;br/&gt;                           &apos;WHERE A.&apos;||p_column_name||&apos;.sdo_gtype IS NOT NULL &apos; ||&lt;br/&gt;                           &apos;  AND A.&apos;||p_column_name||&apos;.sdo_gtype &lt; 2000 &apos; ||&lt;br/&gt;                           &apos; AND ROWNUM = 1&apos;&lt;br/&gt;                     INTO v_current;&lt;br/&gt;        Analysis_Report_Row( 4, &apos;Geometry sdo_gtype is not current - Executing SDO_MIGRATE.TO_CURRENT.&apos;);&lt;br/&gt;        MDSYS.SDO_MIGRATE.TO_CURRENT( p_table_name, p_column_name, c_commit_interval);&lt;br/&gt;        Analysis_Report_Row( 5, &apos;Done.&apos;);&lt;br/&gt;        EXCEPTION&lt;br/&gt;          WHEN NO_DATA_FOUND THEN&lt;br/&gt;            Analysis_Report_Row( 4, &apos;Geometry sdo_gtype is current.&apos;);&lt;br/&gt;          WHEN OTHERS THEN&lt;br/&gt;            Analysis_Report_Row( 4, &apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos; when checking if geometry sdo_gtype is current&apos; );&lt;br/&gt;      END Check_Gtype_Is_Current;&lt;br/&gt;&lt;br/&gt;      FUNCTION Discover_Tolerance( p_table_name  IN VARCHAR2,&lt;br/&gt;                                   p_column_name IN VARCHAR2,&lt;br/&gt;                                   p_coord_ref   IN VARCHAR2 )&lt;br/&gt;        RETURN NUMBER&lt;br/&gt;      IS&lt;br/&gt;        v_c2m             NUMBER; -- Metric conversion from SRID unit to meters&lt;br/&gt;        v_tolerance       NUMBER;&lt;br/&gt;        v_min_tolerance   NUMBER;&lt;br/&gt;        v_validate_result VARCHAR2(200);&lt;br/&gt;        v_rectify_sql     VARCHAR2(4000) := &apos;&lt;br/&gt;UPDATE &apos; || p_table_name || &apos; r&lt;br/&gt;   SET r.&apos; || p_column_name || &apos; = MDSYS.SDO_UTIL.RECTIFY_GEOMETRY(r.&apos; || p_column_name || &apos;,:1)&lt;br/&gt; WHERE MDSYS.SDO_GEOM.VALIDATE_GEOMETRY(r.&apos; || p_column_name || &apos;,:2) &lt;&gt; &apos;&apos;TRUE&apos;&apos;&apos;;&lt;br/&gt;        v_validate_sql    VARCHAR2(4000) := &apos;&lt;br/&gt;SELECT SUBSTR(sdo_geom.validate_geometry(A.&apos;||p_column_name||&apos;,:1),1,20)&lt;br/&gt;  FROM &apos; || p_table_name || &apos; A&lt;br/&gt; WHERE A.&apos;||p_column_name||&apos; IS NOT NULL&lt;br/&gt;   AND mdsys.sdo_geom.validate_geometry(A.&apos;||p_column_name||&apos;,:2) &lt;&gt; &apos;&apos;TRUE&apos;&apos;&lt;br/&gt;   AND rownum = 1&apos;;&lt;br/&gt;      BEGIN&lt;br/&gt;         Analysis_Report_Row( 4, &apos;Discovering Best Tolerance.&apos;);&lt;br/&gt;         -- From the Oracle Spatial documentation.&lt;br/&gt;         -- * For geodetic data (such as data identified by longitude and latitude coordinates), the tolerance value&lt;br/&gt;         --   is a number of meters. For example, a tolerance value of 100 indicates a tolerance of 100 meters.&lt;br/&gt;         --   The tolerance value for geodetic data should not be smaller than 0.05 (5 centimeters), and in most cases&lt;br/&gt;         --   it should be larger. Spatial uses 0.05 as the tolerance value for geodetic data if you specify a smaller value.&lt;br/&gt;         -- * For non-geodetic data, the tolerance value is a number of the units that are associated with the&lt;br/&gt;         --   coordinate system associated with the data. For example, if the unit of measurement is miles,&lt;br/&gt;         --   a tolerance value of 0.005 indicates a tolerance of 0.005 (that is, 1/200) mile (approximately 26 feet),&lt;br/&gt;         --   and a tolerance value of 2 indicates a tolerance of 2 miles.&lt;br/&gt;         --&lt;br/&gt;&lt;br/&gt;         -- Set starting tolerance to be large relative to the coordinate system&apos;s unit of measure ...&lt;br/&gt;         IF ( p_coord_ref &lt;&gt; c_geographic ) THEN&lt;br/&gt;            Analysis_Report_Row( 5, &apos;Provided minimum tolerance = &apos; || p_min_projected_tolerance);&lt;br/&gt;            v_min_tolerance := p_min_projected_tolerance;  -- eg 0.00005 x unit of measurement. Eg if miles then 1/20000 = .26 feet.&lt;br/&gt;            v_tolerance     := 5;                          -- 5 x unit of measure ie if MILE then 5 miles, if CM then 5 CM...&lt;br/&gt;         ELSE&lt;br/&gt;            v_min_tolerance := 0.05;     -- As per documentation ie 5cm&lt;br/&gt;            v_tolerance     := 5000;     -- About 3.1 miles&lt;br/&gt;         END IF;&lt;br/&gt;&lt;br/&gt;         -- Let&apos;s have a look at the data and do some validate_geometry tests&lt;br/&gt;         v_validate_result := &apos;FALSE&apos;;&lt;br/&gt;         &lt;&lt;validity_tests_loop&gt;&gt;&lt;br/&gt;         WHILE ( v_validate_result &lt;&gt; &apos;TRUE&apos; ) LOOP&lt;br/&gt;            v_tolerance := v_tolerance / 10;&lt;br/&gt;            Analysis_Report_Row( 6, &apos;Testing &apos; || v_tolerance || &apos; ... &apos; );&lt;br/&gt;            BEGIN&lt;br/&gt;              EXECUTE IMMEDIATE v_validate_sql&lt;br/&gt;                           INTO v_validate_result&lt;br/&gt;                          USING v_tolerance,&lt;br/&gt;                                v_tolerance;&lt;br/&gt;              IF ( v_validate_result IS NULL ) THEN&lt;br/&gt;                Analysis_Report_Row(8,&apos;Null result (sdo_geometry object error most likely): Terminating discovery.&apos;);&lt;br/&gt;                v_validate_result := &apos;TRUE&apos;;&lt;br/&gt;              ELSE&lt;br/&gt;                Analysis_Report_Row(8,&apos;Result is &apos; || v_validate_result );&lt;br/&gt;              END IF;&lt;br/&gt;              EXCEPTION&lt;br/&gt;                WHEN NO_DATA_FOUND THEN&lt;br/&gt;                  Analysis_Report_Row( 8,&apos;Result OK.&apos; );&lt;br/&gt;                  v_validate_result := &apos;TRUE&apos;;&lt;br/&gt;                WHEN OTHERS THEN&lt;br/&gt;                  Analysis_Report_Row( 8,&apos;Error (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE) || &apos;: Terminating discovery.&apos;);&lt;br/&gt;                  v_validate_result := &apos;TRUE&apos;;&lt;br/&gt;            END;&lt;br/&gt;            IF ( v_validate_result &lt;&gt; &apos;TRUE&apos; AND v_tolerance = v_min_tolerance ) THEN&lt;br/&gt;              Analysis_Report_Row( 8,&apos;Can&apos;&apos;t discover tolerance as still getting errors at minimum of &apos; || v_min_tolerance);&lt;br/&gt;              If ( p_rectify_geometry ) Then&lt;br/&gt;                Analysis_Report_Row(10,&apos;Attempting to Rectify the Geometry.&apos;);&lt;br/&gt;                EXECUTE IMMEDIATE v_rectify_sql&lt;br/&gt;                            USING v_tolerance,&lt;br/&gt;                                  v_tolerance;&lt;br/&gt;                Analysis_Report_Row(12,&apos;Done.&apos;);&lt;br/&gt;                Analysis_Report_Row(12, &apos;Testing for errors after rectification using mdsys.sdo_geom.validate_geometry().&apos; );&lt;br/&gt;                v_validate_result := &apos;FALSE&apos;;&lt;br/&gt;                BEGIN&lt;br/&gt;                EXECUTE IMMEDIATE v_validate_sql&lt;br/&gt;                             INTO v_validate_result&lt;br/&gt;                            USING v_tolerance,&lt;br/&gt;                                  v_tolerance;&lt;br/&gt;                Analysis_Report_Row(14,&apos;Failed: Data still invalid with errors like &apos; || v_validate_result || &apos;, consider fixing manually or using Tools.GeometryCheck&apos;);&lt;br/&gt;                EXCEPTION&lt;br/&gt;                  WHEN NO_DATA_FOUND THEN&lt;br/&gt;                    Analysis_Report_Row(14,&apos;Passed: Data is clean&apos;);&lt;br/&gt;                END;&lt;br/&gt;              Else&lt;br/&gt;                Analysis_Report_Row(14,&apos;Failed: Data still invalid with errors like &apos; || v_validate_result || &apos;, consider fixing manually or using Tools.GeometryCheck&apos;);&lt;br/&gt;              End If;&lt;br/&gt;              -- STOP&lt;br/&gt;              v_validate_result := &apos;TRUE&apos;;&lt;br/&gt;            END IF;&lt;br/&gt;         END LOOP validity_tests_loop;&lt;br/&gt;         Analysis_Report_Row( 5,&apos;Best calculated tolerance is &apos; || v_tolerance );&lt;br/&gt;         RETURN v_tolerance;&lt;br/&gt;      END Discover_Tolerance;&lt;br/&gt;&lt;br/&gt;      FUNCTION Apply_Tolerance_To_Extent( p_diminfo MDSYS.SDO_DIM_ARRAY )&lt;br/&gt;        RETURN MDSYS.SDO_DIM_ARRAY&lt;br/&gt;      IS&lt;br/&gt;        v_diminfo      MDSYS.SDO_DIM_ARRAY := p_diminfo;&lt;br/&gt;        v_x_tolerance  NUMBER;&lt;br/&gt;        v_y_tolerance  NUMBER;&lt;br/&gt;        v_z_tolerance  NUMBER;  -- Not currently implemented.&lt;br/&gt;      BEGIN&lt;br/&gt;         v_x_tolerance := round(log(10,1/v_diminfo(1).sdo_tolerance))+1;&lt;br/&gt;         v_y_tolerance := round(log(10,1/v_diminfo(2).sdo_tolerance))+1;&lt;br/&gt;         v_diminfo(1).sdo_lb := round(v_diminfo(1).sdo_lb,v_x_tolerance);&lt;br/&gt;         v_diminfo(1).sdo_ub := round(v_diminfo(1).sdo_ub,v_x_tolerance);&lt;br/&gt;         v_diminfo(2).sdo_lb := round(v_diminfo(2).sdo_lb,v_y_tolerance);&lt;br/&gt;         v_diminfo(2).sdo_ub := round(v_diminfo(2).sdo_ub,v_y_tolerance);&lt;br/&gt;         If ( p_diminfo.COUNT = 2 ) Then&lt;br/&gt;           Analysis_Report_Row( 4,&lt;br/&gt;                                &apos;Extent after rounding by tolerance is (&apos; ||&lt;br/&gt;                                v_diminfo(1).sdo_lb||&apos;,&apos;||v_diminfo(2).sdo_lb ||&lt;br/&gt;                                &apos;)(&apos;||&lt;br/&gt;                                v_diminfo(1).sdo_ub||&apos;,&apos;||v_diminfo(2).sdo_ub ||&lt;br/&gt;                                &apos;)&apos;&lt;br/&gt;                                );&lt;br/&gt;         Else&lt;br/&gt;           Analysis_Report_Row( 4,&lt;br/&gt;                                &apos;Extent after rounding by tolerance is (&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_lb || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_lb || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(3).sdo_lb ||&lt;br/&gt;                                &apos;)(&apos; ||&lt;br/&gt;                                p_diminfo(1).sdo_ub || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(2).sdo_ub || &apos;,&apos; ||&lt;br/&gt;                                p_diminfo(3).sdo_ub  ||&lt;br/&gt;                                &apos;)&apos;&lt;br/&gt;                              );&lt;br/&gt;         End If;&lt;br/&gt;         RETURN v_diminfo;&lt;br/&gt;      END Apply_Tolerance_To_Extent;&lt;br/&gt;&lt;br/&gt;      Procedure Update_Metadata( p_record IN USER_SDO_GEOM_METADATA%ROWTYPE )&lt;br/&gt;      Is&lt;br/&gt;       RECORD_ALREADY_EXISTS EXCEPTION;&lt;br/&gt;       PRAGMA                EXCEPTION_INIT(RECORD_ALREADY_EXISTS, -13223);&lt;br/&gt;      BEGIN&lt;br/&gt;        Analysis_Report_Row( 4, &apos;USER_SDO_GEOM_METADATA for (&apos; || p_record.table_name || &apos;,&apos; || p_record.column_name || &apos;) updated.&apos;);&lt;br/&gt;        INSERT INTO USER_SDO_GEOM_METADATA VALUES p_record;&lt;br/&gt;        COMMIT;&lt;br/&gt;        EXCEPTION&lt;br/&gt;          WHEN RECORD_ALREADY_EXISTS THEN&lt;br/&gt;            UPDATE USER_SDO_GEOM_METADATA&lt;br/&gt;               SET diminfo = p_record.diminfo,&lt;br/&gt;                   srid = p_record.SRID&lt;br/&gt;             WHERE table_name = p_record.table_name&lt;br/&gt;               AND column_name = p_record.column_name;&lt;br/&gt;            COMMIT;&lt;br/&gt;      END Update_Metadata;&lt;br/&gt;&lt;br/&gt;      Function Format_Metadata_Record( p_record IN USER_SDO_GEOM_METADATA%ROWTYPE )&lt;br/&gt;         Return VarChar2&lt;br/&gt;      Is&lt;br/&gt;         v_line  VarChar2(4000);&lt;br/&gt;&lt;br/&gt;         Function Null_String_Check( p_value IN VarChar2 )&lt;br/&gt;           Return VarChar2&lt;br/&gt;         Is&lt;br/&gt;            v_value VarChar2(4000);&lt;br/&gt;         Begin&lt;br/&gt;            If ( p_value is NULL ) Then&lt;br/&gt;              v_value := &apos;NULL&apos;;&lt;br/&gt;            Else&lt;br/&gt;              v_value := p_value;&lt;br/&gt;            End If;&lt;br/&gt;            Return v_value;&lt;br/&gt;         End Null_String_Check;&lt;br/&gt;&lt;br/&gt;         Function Null_Number_Check( p_value IN NUMBER )&lt;br/&gt;           Return VarChar2&lt;br/&gt;         Is&lt;br/&gt;            v_value VarChar2(4000);&lt;br/&gt;         Begin&lt;br/&gt;            If ( p_value is NULL ) Then&lt;br/&gt;              v_value := &apos;NULL&apos;;&lt;br/&gt;            Else&lt;br/&gt;              v_value := To_Char(p_value);&lt;br/&gt;            End If;&lt;br/&gt;            Return v_value;&lt;br/&gt;         End Null_Number_Check;&lt;br/&gt;&lt;br/&gt;      Begin&lt;br/&gt;          v_line := &apos;Metadata Record: &apos; ||&lt;br/&gt;                       &apos;SRID(&apos; || Null_Number_Check(p_record.srid) ||&lt;br/&gt;                       &apos;) DimInfo(&apos;;&lt;br/&gt;          If ( p_record.diminfo is NULL ) Then&lt;br/&gt;            v_line := v_line || &apos;NULL&apos;;&lt;br/&gt;          Else&lt;br/&gt;            v_line := v_line || &apos; DimNames(&apos; ||&lt;br/&gt;                         Null_String_Check(p_record.diminfo(1).sdo_dimname) ||&lt;br/&gt;                         &apos;,&apos; ||&lt;br/&gt;                         Null_String_Check(p_record.diminfo(2).sdo_dimname);&lt;br/&gt;            If p_record.diminfo.count &gt; 2 Then&lt;br/&gt;               v_line := v_line || &apos;,&apos; || Null_String_Check(p_record.diminfo(3).sdo_dimname);&lt;br/&gt;            End If;&lt;br/&gt;            v_line := v_line || &apos;) Extent((&apos; ||&lt;br/&gt;                      Null_Number_Check(p_record.diminfo(1).sdo_lb) ||&lt;br/&gt;                      &apos;,&apos; ||&lt;br/&gt;                      Null_Number_Check(p_record.diminfo(2).sdo_lb);&lt;br/&gt;            If p_record.diminfo.count &gt; 2 Then&lt;br/&gt;               v_line := v_line || &apos;,&apos; || Null_Number_Check(p_record.diminfo(3).sdo_lb);&lt;br/&gt;            End If;&lt;br/&gt;            v_line := v_line || &apos;)(&apos; ||&lt;br/&gt;                         Null_Number_Check(p_record.diminfo(1).sdo_ub) ||&lt;br/&gt;                         &apos;,&apos; ||&lt;br/&gt;                         Null_Number_Check(p_record.diminfo(2).sdo_ub);&lt;br/&gt;            If p_record.diminfo.count &gt; 2 Then&lt;br/&gt;               v_line := v_line || &apos;,&apos; || Null_Number_Check(p_record.diminfo(3).sdo_ub);&lt;br/&gt;            End If;&lt;br/&gt;            v_line := v_line ||&lt;br/&gt;                      &apos;)) Tolerance(&apos; ||&lt;br/&gt;                      Null_Number_Check(p_record.diminfo(1).sdo_tolerance) ||&lt;br/&gt;                      &apos;,&apos; ||&lt;br/&gt;                      Null_Number_Check(p_record.diminfo(2).sdo_tolerance);&lt;br/&gt;            If p_record.diminfo.count &gt; 2 Then&lt;br/&gt;               v_line := v_line || &apos;,&apos; || Null_Number_Check(p_record.diminfo(3).sdo_tolerance);&lt;br/&gt;            End If;&lt;br/&gt;            v_line := v_line || &apos;)&apos;;&lt;br/&gt;          End If;&lt;br/&gt;          v_line := v_line || &apos;)&apos;;&lt;br/&gt;          Return v_line;&lt;br/&gt;     End Format_Metadata_Record;&lt;br/&gt;&lt;br/&gt;      FUNCTION Write_Sdo_Geom_Record&lt;br/&gt;        RETURN BOOLEAN&lt;br/&gt;      IS&lt;br/&gt;      BEGIN&lt;br/&gt;         INSERT INTO USER_SDO_GEOM_METADATA&lt;br/&gt;                   (table_name,&lt;br/&gt;                    column_name,&lt;br/&gt;                    diminfo,&lt;br/&gt;                    srid)&lt;br/&gt;             VALUES(v_geom_metadata_rec.table_name,&lt;br/&gt;                    v_geom_metadata_rec.column_name,&lt;br/&gt;                    v_geom_metadata_rec.diminfo,&lt;br/&gt;                    v_geom_metadata_rec.srid);&lt;br/&gt;         COMMIT;&lt;br/&gt;         Analysis_Report_Row( 5,&apos;USER_SDO_GEOM_METADATA row inserted.&apos; );&lt;br/&gt;         RETURN TRUE;&lt;br/&gt;         EXCEPTION&lt;br/&gt;            WHEN OTHERS THEN&lt;br/&gt;              Analysis_Report_Row(6,&apos;Failed to insert new user_sdo_geom_metadata record (&apos;|| SQLCODE ||&apos;) of &apos; || SQLERRM(SQLCODE));&lt;br/&gt;              RETURN FALSE;&lt;br/&gt;      END Write_Sdo_Geom_Record;&lt;br/&gt;&lt;br/&gt;      Function Create_Geom_Metadata_Record( p_table_name    in user_sdo_geom_metadata.table_name%type,&lt;br/&gt;                                            p_column_name   in user_sdo_geom_metadata.column_name%type,&lt;br/&gt;                                            p_srid          IN INTEGER)&lt;br/&gt;        Return USER_SDO_GEOM_METADATA%ROWTYPE DETERMINISTIC&lt;br/&gt;      Is&lt;br/&gt;        v_geom_metadata_rec USER_SDO_GEOM_METADATA%ROWTYPE;&lt;br/&gt;      BEGIN&lt;br/&gt;        Analysis_Report_Row(4,&apos;Is there an existing user_sdo_geom_metadata entry?&apos;);&lt;br/&gt;        SELECT *&lt;br/&gt;          INTO v_geom_metadata_rec&lt;br/&gt;          FROM USER_SDO_GEOM_METADATA&lt;br/&gt;         WHERE  table_name = p_table_name&lt;br/&gt;           AND column_name = p_column_name;&lt;br/&gt;        --&lt;br/&gt;        -- If we have been passed a fixed SRID update it&lt;br/&gt;        --&lt;br/&gt;        IF ( p_srid &lt;&gt; c_discover_srid ) THEN&lt;br/&gt;          v_geom_metadata_rec.srid := p_srid;&lt;br/&gt;          Analysis_Report_Row(5,&apos;Yes (but SRID updated to &apos; || p_srid || &apos;)&apos;);&lt;br/&gt;        Else&lt;br/&gt;          Analysis_Report_Row(5,&apos;Yes&apos;);&lt;br/&gt;        END IF;&lt;br/&gt;        Return v_geom_metadata_rec;&lt;br/&gt;        EXCEPTION&lt;br/&gt;          WHEN NO_DATA_FOUND THEN&lt;br/&gt;            Analysis_Report_Row(5,&apos;No&apos;);&lt;br/&gt;            --&lt;br/&gt;            -- Let&apos;s create a basic metadata entry&lt;br/&gt;            --&lt;br/&gt;            Analysis_Report_Row( 4,&apos;Generating user_sdo_geom_metadata record ...&apos;);&lt;br/&gt;            v_geom_metadata_rec.srid        := p_srid;&lt;br/&gt;            v_geom_metadata_rec.table_name  := UPPER(p_table_name);&lt;br/&gt;            v_geom_metadata_rec.column_name := UPPER(p_column_name);&lt;br/&gt;            v_geom_metadata_rec.diminfo     := Create_Diminfo( 2, c_min_number, c_max_number, c_max_tolerance );&lt;br/&gt;            Return v_geom_metadata_rec;&lt;br/&gt;      END Create_Geom_Metadata_Record;&lt;br/&gt;&lt;br/&gt;      PROCEDURE Print_Activity( p_indent in number )&lt;br/&gt;      Is&lt;br/&gt;      BEGIN&lt;br/&gt;          --&lt;br/&gt;          -- Report activities added to activity array&lt;br/&gt;          --&lt;br/&gt;          If ( v_activity.COUNT &gt; 0 ) Then&lt;br/&gt;            For action IN v_activity.FIRST..v_activity.LAST Loop&lt;br/&gt;               If ( v_activity.EXISTS(action) AND LENGTH(TRIM(v_activity(action))) &gt; 0 ) Then&lt;br/&gt;                 Analysis_Report_Row( p_indent,v_activity(action) );&lt;br/&gt;               End If;&lt;br/&gt;            End Loop;&lt;br/&gt;            v_activity.TRIM(v_activity.COUNT);&lt;br/&gt;          End If;&lt;br/&gt;      END Print_Activity;&lt;br/&gt;&lt;br/&gt;   BEGIN -- MetadataAnalyzer&lt;br/&gt;&lt;br/&gt;      --&lt;br/&gt;      -- Check variables and parameters&lt;br/&gt;      --&lt;br/&gt;      v_activity.TRIM(v_activity.COUNT);&lt;br/&gt;      If ( p_owner Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;      Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_owner,1,32));&lt;br/&gt;      End If;&lt;br/&gt;&lt;br/&gt;      IF NOT ( p_stats_percent BETWEEN 0 AND 100 ) THEN&lt;br/&gt;        RAISE BAD_STATS_PARAMETER;&lt;br/&gt;        Analysis_Report_Row(1,&apos;p_stats_percent parameter value (&apos;||p_stats_percent||&apos;) not between 1 and 100&apos;);&lt;br/&gt;        RETURN;&lt;br/&gt;      END IF;&lt;br/&gt;&lt;br/&gt;      Analysis_Report_Row(1,&apos;Processing tables or materialized views like &apos;|| p_table_regex ||&apos; for user (&apos;|| v_owner || &apos;) ...&apos;);&lt;br/&gt;&lt;br/&gt;      --&lt;br/&gt;      -- Create list of table/geometry columns for processing/checking&lt;br/&gt;      --&lt;br/&gt;      &lt;&lt;user_tab_columns_loop&gt;&gt;&lt;br/&gt;      FOR geomcolrec IN c_geom_columns( v_owner, p_table_regex ) LOOP&lt;br/&gt;        v_start_date := SYSDATE;&lt;br/&gt;        v_managed_id := Managed_Column_Id(geomcolrec.Table_Name, geomcolrec.Column_Name, v_owner);&lt;br/&gt;        Analysis_Report_Row(2,geomcolrec.table_name || &apos;.&apos; || geomcolrec.column_name);&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Is there any data in this table?&lt;br/&gt;        --&lt;br/&gt;        v_data := hasData( geomcolrec.table_name, v_owner );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- ================ USER_SDO_GEOM_METADATA PROCESSING =======================&lt;br/&gt;        --&lt;br/&gt;        -- Create new USER_SDO_GEOM_METADATA record (may start with any existing record)&lt;br/&gt;        --&lt;br/&gt;        v_geom_metadata_rec := Create_Geom_Metadata_Record(geomcolrec.table_name,&lt;br/&gt;                                                           geomcolrec.column_name,&lt;br/&gt;                                                           CASE WHEN p_fixed_srid = c_discover_srid&lt;br/&gt;                                                                THEN NULL&lt;br/&gt;                                                                ELSE p_fixed_srid&lt;br/&gt;                                                            END );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Print out the starting metadata ...&lt;br/&gt;        --&lt;br/&gt;        v_rubbish := Format_Metadata_Record( v_geom_metadata_rec );&lt;br/&gt;        Analysis_Report_Row(6, &apos;STARTING &apos; || v_rubbish );&lt;br/&gt;&lt;br/&gt;        -- Now, we process the actual data to determine what the actual metadata record should be&lt;br/&gt;        --&lt;br/&gt;        -- Use Discover_SRID to get most common SRID in table...&lt;br/&gt;        --&lt;br/&gt;        IF ( v_Data ) THEN&lt;br/&gt;            v_geom_metadata_rec.srid := Discover_SRID( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                                       p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                                       p_activity    =&gt; v_activity );&lt;br/&gt;            Print_Activity( 6 );&lt;br/&gt;        ELSIF ( p_fixed_srid = c_discover_srid ) THEN&lt;br/&gt;          v_geom_metadata_rec.srid := NULL;&lt;br/&gt;        END IF;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Now we have the SRID, let&apos;s discover if the data is projected or geodetic&lt;br/&gt;        --&lt;br/&gt;        v_coord_ref := &apos;PROJECTED&apos;;&lt;br/&gt;        IF ( v_geom_metadata_rec.SRID IS NOT NULL ) THEN&lt;br/&gt;          SELECT CASE WHEN coord_ref_sys_kind LIKE &apos;GEO%&apos; THEN c_geographic&lt;br/&gt;                      ELSE coord_ref_sys_kind&lt;br/&gt;                  END as Coord_Ref&lt;br/&gt;            INTO v_coord_ref&lt;br/&gt;            FROM MDSYS.SDO_COORD_REF_SYS&lt;br/&gt;           WHERE SRID = v_geom_metadata_rec.SRID;&lt;br/&gt;        END IF;&lt;br/&gt;        Analysis_Report_Row( 5, &apos;Table contains &apos;||v_coord_ref||&apos; data.&apos; );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- We need to know the actual data dimensions ie 2D, 3D etc for indexing ie sdo_indx_dims=2&lt;br/&gt;        --&lt;br/&gt;        IF ( v_data ) THEN&lt;br/&gt;          v_dimensions := Discover_Dimensions( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                               p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                               p_activity    =&gt; v_activity );&lt;br/&gt;          Print_Activity( 6 );&lt;br/&gt;          --&lt;br/&gt;          -- If 2D then diminfo should contain 2 sdo_dim_elements etc...&lt;br/&gt;          --&lt;br/&gt;          v_geom_metadata_rec.diminfo := Check_DimInfo_Dimensions( v_dimensions, v_geom_metadata_rec.diminfo );&lt;br/&gt;        End If;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Now get Spatial Index Name (if exists)&lt;br/&gt;        --&lt;br/&gt;        v_spindex_name := GetSpatialIndexName( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                               p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                               p_owner       =&gt; p_owner );&lt;br/&gt;        If ( v_spindex_name IS NOT NULL ) Then&lt;br/&gt;           Analysis_Report_Row( 4,&apos;Spatial Index name = &apos; || v_spindex_name );&lt;br/&gt;        Else&lt;br/&gt;           Analysis_Report_Row( 4,&apos;No spatial index exists.&apos; );&lt;br/&gt;        End If;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Examine the actual data to determine the sdo_tolerance of the data&lt;br/&gt;        -- This must be done before spatial extent as spatial extent needs valid tolerance value&lt;br/&gt;        --&lt;br/&gt;        IF ( p_fixed_diminfo IS NULL OR p_fixed_diminfo(1).sdo_tolerance IS NULL ) THEN&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_tolerance :=&lt;br/&gt;                Discover_Tolerance( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                    p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                    p_coord_ref   =&gt; v_coord_ref );&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_tolerance := v_geom_metadata_rec.diminfo(1).sdo_tolerance;&lt;br/&gt;        ELSIF ( p_fixed_diminfo IS NOT NULL AND p_fixed_diminfo(1).sdo_tolerance IS NOT NULL ) THEN&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_tolerance := p_fixed_diminfo(1).sdo_tolerance;&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_tolerance := p_fixed_diminfo(2).sdo_tolerance;&lt;br/&gt;        END IF;&lt;br/&gt;        --&lt;br/&gt;        -- Because Z/M tolerance is not yet discoverable by the tool....&lt;br/&gt;        --&lt;br/&gt;        If ( p_fixed_diminfo IS NOT NULL ) Then&lt;br/&gt;          If ( v_dimensions &gt; 2 ) AND ( p_fixed_diminfo.COUNT &gt; 2 ) Then&lt;br/&gt;            v_geom_metadata_rec.diminfo(3).sdo_tolerance := p_fixed_diminfo(3).sdo_tolerance;&lt;br/&gt;            If ( v_dimensions &gt; 3 ) AND ( p_fixed_diminfo.COUNT &gt; 3 ) Then&lt;br/&gt;               v_geom_metadata_rec.diminfo(4).sdo_tolerance := p_fixed_diminfo(4).sdo_tolerance;&lt;br/&gt;            End If;&lt;br/&gt;          End If;&lt;br/&gt;        End If;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Now set sdo_lb/sdo_ub of diminfo structure from real data (if possible)&lt;br/&gt;        --&lt;br/&gt;        v_discover_data_extent := TRUE;&lt;br/&gt;        IF ( v_data&lt;br/&gt;             AND&lt;br/&gt;             p_fixed_diminfo IS NULL ) THEN&lt;br/&gt;           -- No fixed diminfo supplied...&lt;br/&gt;           -- Can we use the spatial index to get the extent?&lt;br/&gt;           IF ( v_spindex_name IS NOT NULL ) THEN&lt;br/&gt;             -- Only if data is 2D and non-geodetic&lt;br/&gt;             IF ( v_dimensions = 2 ) AND ( v_coord_ref &lt;&gt; c_geographic ) THEN&lt;br/&gt;                v_discover_data_extent := NOT Get_Spatial_Index_Extent( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                                                        p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                                                        p_diminfo     =&gt; v_geom_metadata_rec.diminfo );&lt;br/&gt;                If v_discover_data_extent Then&lt;br/&gt;                    Analysis_Report_Row( 4,&lt;br/&gt;                           &apos;SDO_TUNE.EXTENT_OF returned extent of (&apos; ||&lt;br/&gt;                           v_geom_metadata_rec.diminfo(1).sdo_lb||&apos;,&apos;||v_geom_metadata_rec.diminfo(2).sdo_lb ||&lt;br/&gt;                           &apos;)(&apos;||&lt;br/&gt;                           v_geom_metadata_rec.diminfo(1).sdo_ub||&apos;,&apos;||v_geom_metadata_rec.diminfo(2).sdo_ub ||&lt;br/&gt;                           &apos;)&apos;&lt;br/&gt;                         );&lt;br/&gt;                Else&lt;br/&gt;                  Analysis_Report_Row( 4, &apos;SDO_TUNE.EXTENT_OF returned empty extent.&apos;);&lt;br/&gt;                End If;&lt;br/&gt;             END IF;&lt;br/&gt;           END IF;&lt;br/&gt;           --&lt;br/&gt;           -- Do we still need to access the raw data to get the extent?&lt;br/&gt;           --&lt;br/&gt;           IF ( v_discover_data_extent ) THEN&lt;br/&gt;              IF Discover_Data_Extent( p_owner        =&gt; v_owner,&lt;br/&gt;                                       p_spatial_type =&gt; v_spatial_type,&lt;br/&gt;                                       p_table_name   =&gt; geomcolrec.table_name,&lt;br/&gt;                                       p_column_name  =&gt; geomcolrec.column_name,&lt;br/&gt;                                       p_coord_ref    =&gt; v_coord_ref,&lt;br/&gt;                                       p_diminfo      =&gt; v_geom_metadata_rec.diminfo ) THEN&lt;br/&gt;                 IF ( v_coord_ref &lt;&gt; c_geographic ) THEN&lt;br/&gt;                    v_geom_metadata_rec.diminfo := Apply_Tolerance_To_Extent( v_geom_metadata_rec.diminfo );&lt;br/&gt;                 END IF;&lt;br/&gt;              END IF;&lt;br/&gt;            END IF;&lt;br/&gt;&lt;br/&gt;        ELSIF ( p_fixed_diminfo is not null ) THEN&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_lb := p_fixed_diminfo(1).sdo_lb;&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_ub := p_fixed_diminfo(1).sdo_ub;&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_lb := p_fixed_diminfo(2).sdo_lb;&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_ub := p_fixed_diminfo(2).sdo_ub;&lt;br/&gt;          If ( v_dimensions &gt; 2 ) AND ( p_fixed_diminfo.COUNT &gt; 2 ) Then&lt;br/&gt;            v_geom_metadata_rec.diminfo(3).sdo_lb := p_fixed_diminfo(3).sdo_lb;&lt;br/&gt;            v_geom_metadata_rec.diminfo(3).sdo_ub := p_fixed_diminfo(3).sdo_ub;&lt;br/&gt;            If ( v_dimensions &gt; 3 ) AND ( p_fixed_diminfo.COUNT &gt; 3 ) Then&lt;br/&gt;              v_geom_metadata_rec.diminfo(4).sdo_lb := p_fixed_diminfo(4).sdo_lb;&lt;br/&gt;              v_geom_metadata_rec.diminfo(4).sdo_ub := p_fixed_diminfo(4).sdo_ub;&lt;br/&gt;            End If;&lt;br/&gt;          End If;&lt;br/&gt;        END IF /* p_fixed_diminfo is not null */;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Regardless of result we will now drop the spatial index because we are about to update the table.&lt;br/&gt;        --&lt;br/&gt;        If ( v_spindex_name IS NOT NULL ) Then&lt;br/&gt;          Execute_Statement(&apos;DROP INDEX &apos; || v_spindex_name || &apos; FORCE&apos;,TRUE);&lt;br/&gt;          Analysis_Report_Row( 7, &apos;Existing Index (&apos; || v_spindex_name || &apos;) dropped.&apos; );&lt;br/&gt;        END IF;&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Update SRID of table if different to supplied/calculated&lt;br/&gt;        --&lt;br/&gt;        Update_Table_Column_SRID( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                  p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                  p_srid        =&gt; v_geom_metadata_rec.srid );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Assign Dimension names to all sdo_dim_elements based on whether data is Projected or Geodetic&lt;br/&gt;        --&lt;br/&gt;        IF ( v_coord_ref = &apos;PROJECTED&apos; ) THEN&lt;br/&gt;          v_rubbish := &apos;X,Y&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_dimname := &apos;X&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_dimname := &apos;Y&apos;;&lt;br/&gt;        ELSE&lt;br/&gt;          v_rubbish := &apos;Long,Lat&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(1).sdo_dimname := &apos;Long&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(2).sdo_dimname := &apos;Lat&apos;;&lt;br/&gt;        END IF;&lt;br/&gt;        If ( v_dimensions &gt; 2 ) Then&lt;br/&gt;          v_rubbish := v_rubbish || &apos;,Z&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(3).sdo_dimname := &apos;Z&apos;;&lt;br/&gt;        End If;&lt;br/&gt;        If ( v_dimensions &gt; 3 ) Then&lt;br/&gt;          v_rubbish := v_rubbish || &apos;,M&apos;;&lt;br/&gt;          v_geom_metadata_rec.diminfo(4).sdo_dimname := &apos;M&apos;;&lt;br/&gt;        End If;&lt;br/&gt;        Analysis_Report_Row( 4, &apos;Assigned Dimension Names (&apos; || v_rubbish || &apos;).&apos; );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        If ( v_data ) Then&lt;br/&gt;          --&lt;br/&gt;          -- Discover geometry types within table/column&lt;br/&gt;          --&lt;br/&gt;          Analysis_Report_Row( 4,&apos;Discovering spatial type...&apos;);&lt;br/&gt;          v_spatial_type := Discover_SpatialType( p_table_name  =&gt; geomcolrec.table_name,&lt;br/&gt;                                                  p_column_name =&gt; geomcolrec.column_name,&lt;br/&gt;                                                  p_owner       =&gt; v_owner,&lt;br/&gt;                                                  p_activity    =&gt; v_activity );&lt;br/&gt;          Print_Activity( 6 );&lt;br/&gt;          Analysis_Report_Row( 6,&apos;Discovered spatial type is &apos; || v_spatial_type);&lt;br/&gt;          --&lt;br/&gt;          -- We don&apos;t want any SDO_GTYPEs &lt; 2000 ie old SDO_GTYPES for which we need to run MDSYS.SDO_MIGRATE.TO_CURRENT()&lt;br/&gt;          --&lt;br/&gt;          Check_GType_Is_Current( p_table_name =&gt; geomcolrec.table_name,&lt;br/&gt;                                  p_column_name =&gt; geomcolrec.column_name );&lt;br/&gt;        End If /* v_data */;&lt;br/&gt;        --&lt;br/&gt;        -- Need to update metadata before building spatial index...&lt;br/&gt;        --&lt;br/&gt;        Update_Metadata( p_record =&gt; v_geom_metadata_rec );&lt;br/&gt;        --&lt;br/&gt;        -- Print out the Final metadata ...&lt;br/&gt;        --&lt;br/&gt;        v_rubbish := Format_Metadata_Record( v_geom_metadata_rec );&lt;br/&gt;        Analysis_Report_Row( 6, &apos;FINAL &apos; || v_rubbish );&lt;br/&gt;&lt;br/&gt;        --&lt;br/&gt;        -- Now rebuild index if we can&lt;br/&gt;        --&lt;br/&gt;        IF ( v_data&lt;br/&gt;             AND&lt;br/&gt;             v_spatial_type &lt;&gt; &apos;NO_DATA&apos; ) THEN&lt;br/&gt;            Analysis_Report_Row(4,&apos;Creating new index...&apos;);&lt;br/&gt;            SpatialIndexer( p_table_name      =&gt; geomcolrec.table_name,&lt;br/&gt;                            p_column_name     =&gt; geomcolrec.column_name,&lt;br/&gt;                            p_owner           =&gt; p_owner,&lt;br/&gt;                            p_spatial_type    =&gt; NULL,&lt;br/&gt;                            p_check           =&gt; FALSE,&lt;br/&gt;                            p_dimensions      =&gt; v_dimensions,&lt;br/&gt;                            p_tablespace      =&gt; p_tablespace,&lt;br/&gt;                            p_work_tablespace =&gt; p_work_tablespace,&lt;br/&gt;                            p_pin_non_leaf    =&gt; p_pin_non_leaf,&lt;br/&gt;                            p_stats_percent   =&gt; p_stats_percent,&lt;br/&gt;                            p_activity        =&gt; v_activity );&lt;br/&gt;            Print_Activity( 6 );&lt;br/&gt;            DBMS_STATS.GATHER_TABLE_STATS(v_owner, geomcolrec.table_name, estimate_percent =&gt; p_stats_percent );&lt;br/&gt;            Analysis_Report_Row( 8, &apos;Statistics gathered on &apos;||p_stats_percent||&apos;% of the table.&apos;);&lt;br/&gt;        END IF;&lt;br/&gt;        Analysis_Report_Row( 1, &apos;Metadata Analysis of table completed.&apos; );&lt;br/&gt;        SELECT codesys.COLUMN_ANALYSIS_SUMMARIES_ID.NEXTVAL INTO v_id FROM DUAL;&lt;br/&gt;        INSERT INTO codesys.COLUMN_ANALYSIS_SUMMARIES (&lt;br/&gt;             ID,   Managed_Column_ID, analysis_process_start, analysis_process_end&lt;br/&gt;	) VALUES(&lt;br/&gt;           v_id, v_managed_id,                  v_start_date, SYSDATE );&lt;br/&gt;      END LOOP user_tab_columns_loop;&lt;br/&gt;      COMMIT;&lt;br/&gt;      Analysis_Report_Row( 2, &apos;Metadata Analysis completed.&apos; );&lt;br/&gt;   END MetadataAnalyzer;&lt;br/&gt;&lt;br/&gt;  PROCEDURE RandomSearchByExtent( p_schema          In VarChar2,&lt;br/&gt;                                  p_table_name      In VarChar2,&lt;br/&gt;                                  p_column_name     In VarChar2,&lt;br/&gt;                                  p_number_searches In Number  := 100,&lt;br/&gt;                                  p_window_set      In codesys.T_WindowSet := codesys.T_WindowSet(500,1000,2000,3000,4000,5000,10000,20000,50000),&lt;br/&gt;                                  p_no_zeros        In Boolean := TRUE,&lt;br/&gt;                                  p_sdo_anyinteract In Boolean := FALSE,&lt;br/&gt;                                  p_count_vertices  in Boolean := FALSE,&lt;br/&gt;                                  p_debug_detail    In Boolean := FALSE,&lt;br/&gt;                                  p_min_pixel_size  In Number  := NULL )&lt;br/&gt;   IS&lt;br/&gt;     v_rand_x            number := 0;&lt;br/&gt;     v_rand_y            number := 0;&lt;br/&gt;     v_searchWindowList  codesys.T_WindowSet := p_window_set;&lt;br/&gt;     v_searchWindowSize  number;&lt;br/&gt;     v_searchShape       mdsys.sdo_geometry;&lt;br/&gt;     v_diminfo           mdsys.sdo_dim_array;&lt;br/&gt;     v_srid              number;&lt;br/&gt;     v_lower_x           number;&lt;br/&gt;     v_lower_y           number;&lt;br/&gt;     v_upper_x           number;&lt;br/&gt;     v_upper_y           number;&lt;br/&gt;     v_range_x           number;&lt;br/&gt;     v_range_y           number;&lt;br/&gt;     v_ll_x              number;&lt;br/&gt;     v_ll_y              number;&lt;br/&gt;     v_ur_x              number;&lt;br/&gt;     v_ur_y              number;&lt;br/&gt;     v_Start_Time        number;&lt;br/&gt;     v_End_Time          number;&lt;br/&gt;     v_totalFeatures     PLS_INTEGER;&lt;br/&gt;     v_totalVertices     PLS_INTEGER;&lt;br/&gt;     v_totalSeconds      Number;&lt;br/&gt;     v_fcount            pls_integer;&lt;br/&gt;     v_vcount            pls_integer;&lt;br/&gt;     v_seconds           number;&lt;br/&gt;     v_schema_table      varchar2(100);&lt;br/&gt;     v_sql               varchar2(4000);&lt;br/&gt;     v_owner             varchar2(32);&lt;br/&gt;   BEGIN&lt;br/&gt;     If ( p_schema Is NULL ) Then&lt;br/&gt;        v_owner := sys_context(&apos;userenv&apos;,&apos;session_user&apos;);&lt;br/&gt;     Else&lt;br/&gt;        v_owner := UPPER(SUBSTR(p_schema,1,32));&lt;br/&gt;     End If;&lt;br/&gt;     V_schema_table := v_owner || &apos;.&apos; || UPPER(p_table_name);&lt;br/&gt;     DBMS_OUTPUT.ENABLE ( 100000 );&lt;br/&gt;     BEGIN&lt;br/&gt;       SELECT diminfo, srid&lt;br/&gt;         INTO v_diminfo, v_srid&lt;br/&gt;         FROM all_sdo_geom_metadata&lt;br/&gt;        WHERE table_name  = UPPER(p_table_name)&lt;br/&gt;          AND column_name = UPPER(p_column_name)&lt;br/&gt;          AND owner       = v_owner;&lt;br/&gt;       v_lower_x := v_diminfo(1).SDO_LB;&lt;br/&gt;       v_upper_x := v_diminfo(1).SDO_UB;&lt;br/&gt;       v_lower_y := v_diminfo(2).SDO_LB;&lt;br/&gt;       v_upper_y := v_diminfo(2).SDO_UB;&lt;br/&gt;       EXCEPTION&lt;br/&gt;         WHEN NO_DATA_FOUND&lt;br/&gt;         THEN&lt;br/&gt;              dbms_output.put_line(&apos;No metadata record found for &apos;||v_schema_table||&apos;.&apos;||p_column_name || &apos; manually computing MBR&apos;);&lt;br/&gt;              execute immediate &apos;select min(t.x),min(t.y), max(t.x),max(t.y)&lt;br/&gt;                                   from table(sdo_util.getVertices((SELECT sdo_aggr_mbr(&apos; || p_column_name || &apos;) from &apos; || v_schema_table || &apos;))) t&apos;&lt;br/&gt;              into v_lower_x,v_lower_y,v_upper_x,v_upper_y;&lt;br/&gt;     END;&lt;br/&gt;&lt;br/&gt;     v_range_x := v_upper_x - v_lower_x;&lt;br/&gt;     v_range_y := v_upper_y - v_lower_y;&lt;br/&gt;&lt;br/&gt;     if ( p_count_vertices ) then&lt;br/&gt;        v_sql := &apos;SELECT count(*), sum(mdsys.sdo_util.getNumVertices(a.&apos; || p_column_name || &apos;)) FROM &apos;||v_schema_table||&apos; A WHERE &apos;;&lt;br/&gt;     Else&lt;br/&gt;        v_sql := &apos;SELECT count(*), 0 FROM &apos;||v_schema_table||&apos; A WHERE &apos;;&lt;br/&gt;     End If;&lt;br/&gt;     IF ( p_Sdo_AnyInteract ) THEN&lt;br/&gt;       v_sql := v_sql || &apos;MDSYS.SDO_RELATE(A.&apos;||p_column_name||&apos;,:1,&apos;&apos;mask=ANYINTERACT &apos;;&lt;br/&gt;     ELSE&lt;br/&gt;       v_sql := v_sql || &apos;MDSYS.SDO_FILTER(A.&apos;||p_column_name||&apos;,:1,&apos;&apos;&apos;;&lt;br/&gt;     END IF;&lt;br/&gt;     IF p_min_pixel_size IS NOT NULL THEN&lt;br/&gt;       v_sql := v_sql || &apos; min_resolution=&apos; || p_min_pixel_size ;&lt;br/&gt;     END IF;&lt;br/&gt;     v_sql := v_sql || &apos; querytype=WINDOW&apos;&apos;) = &apos;&apos;TRUE&apos;&apos;&apos;;&lt;br/&gt;&lt;br/&gt;     dbms_output.put_line(SUBSTR(&apos;Search SQL = &apos; || v_Sql,1,255));&lt;br/&gt;&lt;br/&gt;     dbms_output.put_line(&apos;SearchWindow,Searches,TotalFeatures,TotalSeconds,FeaturesPerSecond&apos; || case when p_count_vertices then &apos;,AverageVertices&apos; else &apos;&apos; end);&lt;br/&gt;&lt;br/&gt;     FOR searchSizeCounter IN v_searchWindowList.FIRST..v_searchWindowList.LAST LOOP&lt;br/&gt;       v_totalFeatures := 0;&lt;br/&gt;       v_totalVertices := 0;&lt;br/&gt;       v_totalSeconds  := 0;&lt;br/&gt;       v_searchWindowSize := v_searchWindowList(searchSizeCounter);&lt;br/&gt;       FOR r IN 1..p_number_searches LOOP&lt;br/&gt;         v_fcount := -1;&lt;br/&gt;         -- Loop until we get a valid search&lt;br/&gt;         IF ( p_debug_detail ) THEN&lt;br/&gt;           dbms_output.put_line(&apos;RandX,RandY,Count,Seconds&apos;);&lt;br/&gt;         END IF;&lt;br/&gt;         WHILE ( v_fcount = -1 ) OR ( v_fcount = 0 AND p_no_zeros ) LOOP&lt;br/&gt;           v_rand_x := dbms_random.value(v_lower_x,v_upper_x);&lt;br/&gt;           v_rand_y := dbms_random.value(v_lower_y,v_upper_y);&lt;br/&gt;           v_ll_x := v_rand_x - ( v_searchWindowSize / 2 );&lt;br/&gt;           v_ll_y := v_rand_y - ( v_searchWindowSize / 2 );&lt;br/&gt;           v_ur_x := v_rand_x + ( v_searchWindowSize / 2 );&lt;br/&gt;           v_ur_y := v_rand_y + ( v_searchWindowSize / 2 );&lt;br/&gt;           v_searchShape := MDSYS.SDO_GEOMETRY(2003,v_srid,NULL,&lt;br/&gt;                             MDSYS.SDO_ELEM_INFO_ARRAY(1,1003,3),&lt;br/&gt;                             MDSYS.SDO_ORDINATE_ARRAY(v_ll_X,v_ll_y,v_ur_x,v_ur_y));&lt;br/&gt;           v_Start_Time := dbms_utility.get_time;&lt;br/&gt;           EXECUTE IMMEDIATE v_sql&lt;br/&gt;                        INTO v_fcount, v_vcount&lt;br/&gt;                       USING v_searchShape;&lt;br/&gt;           v_End_Time := dbms_utility.get_time;&lt;br/&gt;         END LOOP;&lt;br/&gt;         v_totalFeatures := v_totalFeatures + v_fcount;&lt;br/&gt;         v_totalVertices := v_totalVertices + v_vcount;&lt;br/&gt;         v_seconds       := ( v_End_Time - v_Start_Time ) / 100;&lt;br/&gt;         v_totalSeconds  := v_totalSeconds + v_seconds;&lt;br/&gt;         IF ( p_debug_detail ) THEN&lt;br/&gt;           dbms_output.put_line(round(v_rand_x,3)||&apos;,&apos;||round(v_rand_y,3)||&apos;,&apos;||round(v_fcount,1)||&apos;,&apos;||TO_CHAR(round(v_seconds,2),&apos;FM999.99&apos;));&lt;br/&gt;         END IF;&lt;br/&gt;       END LOOP;&lt;br/&gt;       dbms_output.put_line(SUBSTR(v_searchWindowSize || &apos;,&apos; ||&lt;br/&gt;                            p_number_Searches || &apos;,&apos; ||&lt;br/&gt;                            trim(TO_CHAR(v_totalFeatures,&apos;9999999&apos;)) || &apos;,&apos; ||&lt;br/&gt;                            round(v_Totalseconds,2) || &apos;,&apos; ||&lt;br/&gt;                            trim(TO_CHAR(round(v_totalFeatures / v_TotalSeconds,1),&apos;999999.9&apos;)),1,255) ||&lt;br/&gt;                            case when p_count_vertices then &apos;,&apos; || TO_CHAR(round(v_totalVertices / v_totalFeatures,1),&apos;FM999,999,999.9&apos;) else &apos;&apos; end );&lt;br/&gt;     END LOOP;&lt;br/&gt;   END RandomSearchByExtent;&lt;br/&gt;&lt;br/&gt;BEGIN&lt;br/&gt;  DBMS_OUTPUT.ENABLE ( buffer_size =&gt; NULL );&lt;br/&gt;END TOOLS;</source>
</body>
</PackageOracle>