<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="SDO_ERROR" directorySegmentName="seg_0" id="02F07A81-F8FB-FA75-4F5B-9A73646E54C7">
<sourceConnName>codesys12</sourceConnName>
<sourceObjSchema>CODESYS</sourceObjSchema>
<sourceObjName>SDO_ERROR</sourceObjName>
<createdBy>Simon</createdBy>
<createdTime>2015-10-27 07:11:21 UTC</createdTime>
<ownerDesignName>ManagedColumns</ownerDesignName>
<owner>CD237EE0-EC38-4CFB-299A-D68C1EE5DB10</owner>
<source>CREATE OR REPLACE PACKAGE CODESYS.SDO_ERROR&lt;br/&gt;AUTHID CURRENT_USER&lt;br/&gt;IS&lt;br/&gt;   TYPE T_GeometrySet   IS TABLE OF codesys.T_Geometry;&lt;br/&gt;   Type T_ElemInfoSet   Is Table Of codesys.T_ElemInfo;&lt;br/&gt;   TYPE T_VectorSet     IS TABLE OF codesys.T_Vector;&lt;br/&gt;   TYPE T_ErrorSet      IS TABLE OF codesys.T_Error;&lt;br/&gt;   TYPE T_VertexMarkSet IS TABLE OF codesys.T_VertexMark;&lt;br/&gt;   TYPE T_Strings       IS TABLE OF varchar2(4000);&lt;br/&gt;&lt;br/&gt;    /* Options for marking geometries&lt;br/&gt;    */&lt;br/&gt;    c_ID                   CONSTANT PLS_INTEGER := 0;&lt;br/&gt;    c_ID_COORD             CONSTANT PLS_INTEGER := 1;&lt;br/&gt;    c_COORD                CONSTANT PLS_INTEGER := 2;&lt;br/&gt;    c_ELEM                 CONSTANT PLS_INTEGER := 3;&lt;br/&gt;&lt;br/&gt;    c_DEGREES              CONSTANT PLS_INTEGER := 0;&lt;br/&gt;    c_RADIANS              CONSTANT PLS_INTEGER := 1;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getValidateErrors&lt;br/&gt;    * @precis     : Core, or base, function which returns each individual error in a geometry.&lt;br/&gt;    *               Edge errors returns as separate edges and calculated intersection point unless&lt;br/&gt;    *               p_all only set to 1.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getValidateErrors(a.geom,0.005,null,0) b;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_tolerance   : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @param      : p_geog_digits : pls_integer : Number of significant digits when p_geometry contains long/lat data.&lt;br/&gt;    * @param      : p_srid        : pls_integer : Projected SRID to be used if p_geometry is geodetic for error calculations.&lt;br/&gt;    * @param      : p_context     : varchar2    : Value returned by validate_geometry_with_context. If null,&lt;br/&gt;    *                                             the sdo_geom function will be run but this function.&lt;br/&gt;    * @return     : p_all         : pls_integer : If 0 then only the error location is returned, otherwise the&lt;br/&gt;    *                                            element/ring of host geometry containing error is also returned.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;    **/&lt;br/&gt;    Function getValidateErrors(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                               p_tolerance   in number      default 0.005,&lt;br/&gt;                               p_geog_digits in pls_integer default NULL,&lt;br/&gt;                               p_srid        in pls_integer default NULL,&lt;br/&gt;                               p_all         in pls_integer default 0,&lt;br/&gt;                               p_drilldown   in pls_integer default 1,&lt;br/&gt;                               p_context     in varchar2    default null)&lt;br/&gt;      return codesys.SDO_ERROR.T_ErrorSet pipelined;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getErrors&lt;br/&gt;    * @precis     : Function which returns each individual error in a geometry as a single geometry.&lt;br/&gt;    *               Edge errors returns as separate edges and calculated intersection point unless&lt;br/&gt;    *               p_all only set to 1.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getErrors(a.geom,0.005,null,0) b;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_tolerance   : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @param      : p_geog_digits : pls_integer : Number of significant digits when p_geometry contains long/lat data.&lt;br/&gt;    * @param      : p_srid        : pls_integer : Projected SRID to be used if p_geometry is geodetic for error calculations.&lt;br/&gt;    * @return     : p_all         : pls_integer : If 0 then only the error location is returned, otherwise the&lt;br/&gt;    *                                            element/ring of host geometry containing error is also returned.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function getErrors(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                      p_tolerance   in number      default 0.005,&lt;br/&gt;                      p_geog_digits in pls_integer default NULL,&lt;br/&gt;                      p_srid        in pls_integer default NULL,&lt;br/&gt;                      p_all         in pls_integer default 0,&lt;br/&gt;                      p_drilldown   in pls_integer default 1)&lt;br/&gt;     return codesys.SDO_ERROR.T_ErrorSet pipelined;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getErrorsAsMulti&lt;br/&gt;    * @precis     : Function which returns all errors in a geometry as a single multipoint or compound geometry.&lt;br/&gt;    *               Edge errors returns as separate edges and calculated intersection points unless&lt;br/&gt;    *               p_all only set to 1. If p_all set to 1 a multipoint is returned, otherwise&lt;br/&gt;    *               possibly a compound geometry composed of points and lines.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT getErrorsAsMulti(a.geom,0.005,null,0) FROM test a;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_tolerance   : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @param      : p_geog_digits : pls_integer : Number of significant digits when p_geometry contains long/lat data.&lt;br/&gt;    * @param      : p_srid        : pls_integer : Projected SRID to be used if p_geometry is geodetic for error calculations.&lt;br/&gt;    * @return     : p_all         : pls_integer : If 0 then only the error location is returned, otherwise the&lt;br/&gt;    *                                            element/ring of host geometry containing error is also returned.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;  **/&lt;br/&gt;   Function getErrorsAsMulti(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                             p_tolerance   in number      default 0.005,&lt;br/&gt;                             p_geog_digits in pls_integer default NULL,&lt;br/&gt;                             p_srid        in pls_integer default NULL,&lt;br/&gt;                             p_all         in pls_integer default 0)&lt;br/&gt;     return mdsys.sdo_geometry deterministic;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getError&lt;br/&gt;    * @precis     : Function which returns a the nominated error number as a single geometry.&lt;br/&gt;    *               Edge errors returns as single edge, points as single point.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT getError(a.geom,0.005,null) FROM test a;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_tolerance   : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @param      : p_geog_digits : pls_integer : Number of significant digits when p_geometry contains long/lat data.&lt;br/&gt;    * @param      : p_srid        : pls_integer : Projected SRID to be used if p_geometry is geodetic for error calculations.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function getError(p_geometry     in mdsys.sdo_geometry,&lt;br/&gt;                     p_error_number in pls_integer,&lt;br/&gt;                     p_tolerance    in number      default 0.005,&lt;br/&gt;                     p_geog_digits  in pls_integer default NULL,&lt;br/&gt;                     p_srid        in pls_integer  default NULL)&lt;br/&gt;    return mdsys.sdo_geometry deterministic;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getErrorText&lt;br/&gt;    * @precis     : Function which returns the text that describes each error in a geometry.&lt;br/&gt;    *               All errors are returned.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getErrorText(a.geom,0.005,null,0) b;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_tolerance   : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;  **/&lt;br/&gt;   Function getErrorText(p_geometry  in mdsys.sdo_geometry,&lt;br/&gt;                         p_tolerance in number DEFAULT 0.005)&lt;br/&gt;     return codesys.SDO_ERROR.T_Strings pipelined;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getErrorText&lt;br/&gt;    * @precis     : Function which returns the text that describes a specific error in a geometry.&lt;br/&gt;    *               Validate_Geometry_With_Context only returns the first error it finds so this&lt;br/&gt;    *               function is useless unless the error is 13356 or 13349 as this package implements&lt;br/&gt;    *               custom processing to discover all errors of this type.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getErrorText(a.geom,0.005,null,0) b;&lt;br/&gt;    * @param      : p_geometry     : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_error_number : pls_integer : The position of the error returned by validate_geometry_with_context.&lt;br/&gt;    * @param      : p_tolerance    : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function getErrorText(p_geometry     in mdsys.sdo_geometry,&lt;br/&gt;                         p_error_number in pls_integer,&lt;br/&gt;                         p_tolerance    in number default 0.05)&lt;br/&gt;    return varchar2 deterministic;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getMarks&lt;br/&gt;    * @precis     : Returns a table that describes each vertex in the provided geometry.&lt;br/&gt;    *               The desciption can be in one of a number of patterns:&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_ID       &lt;id&gt;&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_ID_COORD &lt;id&gt;{x,y}&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_COORD    {x,y}&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_ELEM     {element,ring,id}&lt;br/&gt;    *               The textual marks will be rotated algorithmically depending on the vectors&lt;br/&gt;    *               in/out of a vertex. The returned angle can be either in radians or degrees&lt;br/&gt;    *               depending on the value of the p_degrees parameter.&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_DEGREES&lt;br/&gt;    *                 - codesys.SDO_ERROR.c_RADIANS&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getMarks(a.geom,1,0,0.005,null) b;&lt;br/&gt;    * @param      : p_geometry     : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_error_number : pls_integer : The position of the error returned by validate_geometry_with_context.&lt;br/&gt;    * @param      : p_geog_digits  : NUMBER      : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function getMarks(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                     p_markType    in pls_integer default 0,&lt;br/&gt;                     p_degrees     in pls_integer default 0,&lt;br/&gt;                     p_tolerance   in number      default 0.005,&lt;br/&gt;                     p_geog_digits in pls_integer default null)&lt;br/&gt;     return codesys.SDO_ERROR.T_VertexMarkSet pipelined;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : fix13348&lt;br/&gt;    * @precis     : Function that corrects an ORA-13348 - polygon boundary is not closed&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(getMarks(a.geom,1,0,0.005,null) b;&lt;br/&gt;    * @param      : p_geometry    : MDSYS.SDO_GEOMETRY  : An sdo_geometry object.&lt;br/&gt;    * @param      : p_make_equal  : pls_integer : Boolean flag saying whether to make the last&lt;br/&gt;    *                                         vertex equal (1) to the first or whether to insert&lt;br/&gt;    *                                         a nother vertex (0) at the end that is the same as the first.&lt;br/&gt;    * @param      : p_tolerance    : NUMBER : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @param      : p_geog_digits  : pls_integer : if p_geometry contains long/lat data then this&lt;br/&gt;    *                                              parameter should be set to the number of precise&lt;br/&gt;    *                                              decimal digits of degrees for comparing two ordinates.&lt;br/&gt;    * @history    : Simon Greener - Jun 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function fix13348(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                     p_make_equal  in pls_integer default 1,&lt;br/&gt;                     p_tolerance   in number      default 0.005,&lt;br/&gt;                     p_geog_digits in pls_integer default null)&lt;br/&gt;    return mdsys.sdo_geometry deterministic;&lt;br/&gt;&lt;br/&gt;   /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : FindSpikes&lt;br/&gt;    * @precis     : Function that implements a simple &quot;spike&quot; finder.&lt;br/&gt;    * @version    : 1.0&lt;br/&gt;    * @usage      : SELECT b.* FROM test a, TABLE(FindSpikes(a.geom,0.005) b;&lt;br/&gt;    * @param      : p_geometry  : MDSYS.SDO_GEOMETRY : An sdo_geometry line or polygon object.&lt;br/&gt;    * @param      : p_tolerance : NUMBER             : Oracle sdo_tolerance value eg 0.005 meters for geodetic.&lt;br/&gt;    * @history    : Simon Greener - October 2011 - Original coding.&lt;br/&gt;    * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License.&lt;br/&gt;    *               http://creativecommons.org/licenses/by-sa/2.5/au/&lt;br/&gt;   **/&lt;br/&gt;   Function FindSpikes(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                       p_tolerance   in number default 0.005)&lt;br/&gt;     return codesys.SDO_ERROR.T_VectorSet pipelined;&lt;br/&gt;&lt;br/&gt;  /** UTILITY FUNCTIONS THAT HAVE TO BE PUBLIC **/&lt;br/&gt;&lt;br/&gt;    /*********************************************************************************&lt;br/&gt;  * @function    : Tokenizer&lt;br/&gt;  * @precis      : Splits any string into its tokens.&lt;br/&gt;  * @description : Supplied a string and a list of separators this function&lt;br/&gt;  *                returns resultant tokens as a pipelined collection.&lt;br/&gt;  * @example     : SELECT t.column_value&lt;br/&gt;  *                  FROM TABLE(tokenizer(&apos;The rain in spain, stays mainly on the plain.!&apos;,&apos; ,.!&apos;) ) t;&lt;br/&gt;  * @param       : p_string. The string to be Tokenized.&lt;br/&gt;  * @param       : p_separators. The characters that are used to split the string.&lt;br/&gt;  * @requires    : t_TokenSet type to be declared.&lt;br/&gt;  * @history     : Pawel Barut, http://pbarut.blogspot.com/2007/03/yet-another-tokenizer-in-oracle.html&lt;br/&gt;  * @history     : Simon Greener - July 2006 - Original coding (extended SQL sourced from a blog on the internet)&lt;br/&gt;  **/&lt;br/&gt;  Function Tokenizer(p_string     In VarChar2,&lt;br/&gt;                     p_separators In VarChar2)&lt;br/&gt;    Return codesys.SDO_ERROR.T_Strings Pipelined;&lt;br/&gt;&lt;br/&gt;    /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : GetVector&lt;br/&gt;    * @precis     : Places a geometry&apos;&apos;s coordinates into a pipelined vector data structure.&lt;br/&gt;    * @version    : 3.0&lt;br/&gt;    * @description: Loads the coordinates of a linestring, polygon geometry into a&lt;br/&gt;    *               pipelined vector data structure for easy manipulation by other functions&lt;br/&gt;    *               such as geom.SDO_Centroid.&lt;br/&gt;    * @usage      : Function GetVector( p_geometry IN MDSYS.SDO_GEOMETRY,&lt;br/&gt;    *                                   p_dimarray IN MDSYS.SDO_DIM_ARRAY )&lt;br/&gt;    *                        RETURN VectorSetType PIPELINED&lt;br/&gt;    *               eg select *&lt;br/&gt;    *                    from myshapetable a,&lt;br/&gt;    *                         table(codesys.linear.GetVector(a.shape));&lt;br/&gt;    * @param      : p_geometry : MDSYS.SDO_GEOMETRY : A geographic shape.&lt;br/&gt;    * @return     : geomVector : VectorSetType      : The vector pipelined.&lt;br/&gt;    * @requires   : Global data types coordRec, vectorRec and VectorSetType&lt;br/&gt;    * @requires   : GF package.&lt;br/&gt;    * @history    : Simon Greener - July 2006 - Original coding from GetVector&lt;br/&gt;    * @history    : Simon Greener - July 2008 - Re-write to be standalone of other packages eg GF&lt;br/&gt;    * @history    : Simon Greener - October 2008 - Removed 2D limits&lt;br/&gt;    * @copyright  : Free for public use&lt;br/&gt;  **/&lt;br/&gt;  Function GetVector(P_Geometry  In Mdsys.Sdo_Geometry,&lt;br/&gt;                     P_Exception In Pls_Integer Default 0)&lt;br/&gt;    Return codesys.SDO_ERROR.T_VectorSet Pipelined ;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;end SDO_ERROR;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="SDO_ERROR" id="02F07A81-F8FB-FA75-4F5B-9A73646E54C7">
<sourceConnName>codesys12</sourceConnName>
<sourceObjSchema>CODESYS</sourceObjSchema>
<sourceObjName>SDO_ERROR</sourceObjName>
<createdBy>Simon</createdBy>
<createdTime>2015-10-27 07:11:21 UTC</createdTime>
<ownerDesignName>ManagedColumns</ownerDesignName>
<owner>CD237EE0-EC38-4CFB-299A-D68C1EE5DB10</owner>
<source>CREATE OR REPLACE PACKAGE BODY CODESYS.SDO_ERROR&lt;br/&gt;AS&lt;br/&gt;  c_PI                   CONSTANT NUMBER(16,14) := 3.14159265358979;&lt;br/&gt;  c_MAX                  CONSTANT NUMBER        := 1E38;&lt;br/&gt;  c_Min                  CONSTANT NUMBER        := -1E38;&lt;br/&gt;&lt;br/&gt;  C_I_No_Error           Constant Pls_Integer   := -20001;&lt;br/&gt;  C_S_No_Error           Constant Varchar2(100) := &apos;No errors exist in geometry&apos;;&lt;br/&gt;  C_I_Null_Geometry      Constant  Integer      := -20002;&lt;br/&gt;  C_S_Null_Geometry      Constant Varchar2(100) := &apos;Input geometry must not be null&apos;;&lt;br/&gt;  C_I_Invalid_Mark       Constant Pls_Integer   := -20003;&lt;br/&gt;  C_S_Invalid_Mark       Constant Varchar2(100) := &apos;Invalid mark option. Only c_ID(&apos; || codesys.SDO_ERROR.C_Id ||&lt;br/&gt;                                                                    &apos;), c_ID_COORD(&apos; || codesys.SDO_ERROR.C_Id_Coord ||&lt;br/&gt;                                                                       &apos;), c_COORD(&apos; || codesys.SDO_ERROR.C_Coord ||&lt;br/&gt;                                                                     &apos;) and c_ELEM(&apos; || codesys.SDO_ERROR.c_ELEM || &apos;) allowed.&apos;;&lt;br/&gt;  c_i_invalid_degrees    Constant PLS_Integer   := -20004;&lt;br/&gt;  C_S_Invalid_Radians    Constant Varchar2(100) := &apos;Invalid degrees value option. Only c_DEGREES(&apos; || codesys.SDO_ERROR.C_Degrees || &apos;) or c_RADIANS(&apos; || codesys.SDO_ERROR.C_Radians || &apos;) allowed.&apos;;&lt;br/&gt;  C_I_Arcs_Unsupported   Constant Integer       := -20005;&lt;br/&gt;  C_S_Arcs_Unsupported   Constant Varchar2(100) := &apos;Geometries with Circular Arcs not supported.&apos;;&lt;br/&gt;  c_i_not_polygon        CONSTANT INTEGER       := -20006;&lt;br/&gt;  c_s_not_polygon        CONSTANT VARCHAR2(100) := &apos;Input geometry is not a polygon (xxx3) or multi-polygon (xxx7)&apos;;&lt;br/&gt;  c_i_not_line_poly      CONSTANT INTEGER       := -20007;&lt;br/&gt;  c_s_not_line_poly      CONSTANT VARCHAR2(200) := &apos;Input geometry is not a linestring (xxx2), polygon (xxx3), multi-linestring (xxx6) or multi-polygon (xxx7)&apos;;&lt;br/&gt;&lt;br/&gt;  v_bracketStart         varchar2(2) := &apos;{&apos;;&lt;br/&gt;  v_bracketEnd           varchar2(2) := &apos;}&apos;;&lt;br/&gt;&lt;br/&gt;  /* ****************************************************************************************************&lt;br/&gt;   * Utilities&lt;br/&gt;  ** *****************************************************************************************************/&lt;br/&gt;&lt;br/&gt;  Procedure logger(p_text in varchar2,&lt;br/&gt;                   p_cr   in boolean default true)&lt;br/&gt;  As&lt;br/&gt;  Begin&lt;br/&gt;      if ( p_cr ) then&lt;br/&gt;        dbms_output.put_line(p_text);&lt;br/&gt;      else&lt;br/&gt;        dbms_output.put(p_text);&lt;br/&gt;      end if;&lt;br/&gt;  End logger;&lt;br/&gt;&lt;br/&gt;  Procedure PrintVector(p_vector in codesys.T_Vector,&lt;br/&gt;                        p_cr     in boolean default true)&lt;br/&gt;  As&lt;br/&gt;  Begin&lt;br/&gt;      logger(p_vector.startCoord.x||&apos;,&apos;||p_vector.startCoord.y||&apos;,&apos;||p_vector.endCoord.x||&apos;,&apos;||p_vector.endCoord.y,p_cr);&lt;br/&gt;  End PrintVector;&lt;br/&gt;&lt;br/&gt;  Function Tokenizer(p_string     In VarChar2,&lt;br/&gt;                     p_separators In VarChar2)&lt;br/&gt;    Return codesys.SDO_ERROR.T_Strings pipelined&lt;br/&gt;  As&lt;br/&gt;    v_strs codesys.SDO_ERROR.T_Strings;&lt;br/&gt;  Begin&lt;br/&gt;    With sel_string As (Select p_string fullstring From dual)&lt;br/&gt;    Select substr(fullstring, beg+1, end_p-beg-1) token&lt;br/&gt;           Bulk Collect Into v_strs&lt;br/&gt;      From (Select beg, Lead(beg) Over (Order By beg) end_p, fullstring&lt;br/&gt;              From (Select beg, fullstring&lt;br/&gt;                      From (Select Level beg, fullstring&lt;br/&gt;                              From sel_string&lt;br/&gt;                            Connect By Level &lt;= length(fullstring)&lt;br/&gt;                  )&lt;br/&gt;                     Where instr(p_separators,substr(fullstring,beg,1)) &gt;0&lt;br/&gt;                    Union All&lt;br/&gt;                    Select 0, fullstring&lt;br/&gt;                      From sel_string&lt;br/&gt;                    Union All&lt;br/&gt;                    Select length(fullstring)+1, fullstring&lt;br/&gt;                      From sel_string)&lt;br/&gt;           )&lt;br/&gt;     Where end_p Is Not Null&lt;br/&gt;       And end_p &gt; beg + 1;&lt;br/&gt;    For i In v_strs.first..v_strs.last Loop&lt;br/&gt;      PIPE ROW(v_strs(i));&lt;br/&gt;    End Loop;&lt;br/&gt;    RETURN;&lt;br/&gt;  End Tokenizer;&lt;br/&gt;&lt;br/&gt;  Function GetNumRings( p_geometry  in mdsys.sdo_geometry,&lt;br/&gt;                        p_ring_type in integer /* 0 = ALL; 1 = OUTER; 2 = INNER */ )&lt;br/&gt;    Return Number&lt;br/&gt;  Is&lt;br/&gt;     v_ring_count number := 0;&lt;br/&gt;     v_ring_type  number := p_ring_type;&lt;br/&gt;     v_elements   number;&lt;br/&gt;     v_etype      pls_integer;&lt;br/&gt;  Begin&lt;br/&gt;     If ( p_geometry is null ) Then&lt;br/&gt;        return 0;&lt;br/&gt;     End If;&lt;br/&gt;     If ( v_ring_type not in (0,1,2) ) Then&lt;br/&gt;        v_ring_type := 0;&lt;br/&gt;     End If;&lt;br/&gt;     v_elements := ( ( p_geometry.sdo_elem_info.COUNT / 3 ) - 1 );&lt;br/&gt;     &lt;&lt;element_extraction&gt;&gt;&lt;br/&gt;     for v_i IN 0 .. v_elements LOOP&lt;br/&gt;       v_etype := p_geometry.sdo_elem_info(v_i * 3 + 2);&lt;br/&gt;       If  ( v_etype in (1003,1005,2003,2005) and 0 = v_ring_type )&lt;br/&gt;        OR ( v_etype in (1003,1005)           and 1 = v_ring_type )&lt;br/&gt;        OR ( v_etype in (2003,2005)           and 2 = v_ring_type ) Then&lt;br/&gt;           v_ring_count := v_ring_count + 1;&lt;br/&gt;       end If;&lt;br/&gt;     end loop element_extraction;&lt;br/&gt;     Return v_ring_count;&lt;br/&gt;  End GetNumRings;&lt;br/&gt;&lt;br/&gt;  Function GetNumRings( p_geometry  in mdsys.sdo_geometry )&lt;br/&gt;    Return Number&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    Return GetNumRings(p_geometry,0);&lt;br/&gt;  End GetNumRings;&lt;br/&gt;&lt;br/&gt;  Function GetNumOuterRings( p_geometry  in mdsys.sdo_geometry )&lt;br/&gt;    Return Number&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    Return GetNumRings(p_geometry,1);&lt;br/&gt;  End GetNumOuterRings;&lt;br/&gt;&lt;br/&gt;  Function GetNumInnerRings( p_geometry  in mdsys.sdo_geometry )&lt;br/&gt;    Return Number&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    Return GetNumRings(p_geometry,2);&lt;br/&gt;  End GetNumInnerRings;&lt;br/&gt;&lt;br/&gt;  /** ----------------------------------------------------------------------------------------&lt;br/&gt;  * @function   : hasCircularArcs&lt;br/&gt;  * @precis     : A function that tests whether an sdo_geometry contains circular arcs&lt;br/&gt;  * @version    : 1.0&lt;br/&gt;  * @history    : Simon Greener - Dec 2008 - Original coding.&lt;br/&gt;  * @copyright  : Licensed under a Creative Commons Attribution-Share Alike 2.5 Australia License. (http://creativecommons.org/licenses/by-sa/2.5/au/)&lt;br/&gt;  **/&lt;br/&gt;  Function hasCircularArcs(p_elem_info in mdsys.sdo_elem_info_array)&lt;br/&gt;     return boolean&lt;br/&gt;   Is&lt;br/&gt;     v_elements  number;&lt;br/&gt;   Begin&lt;br/&gt;     v_elements := ( ( p_elem_info.COUNT / 3 ) - 1 );&lt;br/&gt;     &lt;&lt;element_extraction&gt;&gt;&lt;br/&gt;     for v_i IN 0 .. v_elements LOOP&lt;br/&gt;        if ( ( /* etype */         p_elem_info(v_i * 3 + 2) = 2 AND&lt;br/&gt;               /* interpretation*/ p_elem_info(v_i * 3 + 3) = 2 )&lt;br/&gt;             OR&lt;br/&gt;             ( /* etype */         p_elem_info(v_i * 3 + 2) in (1003,2003) AND&lt;br/&gt;               /* interpretation*/ p_elem_info(v_i * 3 + 3) IN (2,4) ) ) then&lt;br/&gt;               return true;&lt;br/&gt;        end If;&lt;br/&gt;     end loop element_extraction;&lt;br/&gt;     return false;&lt;br/&gt;   End hasCircularArcs;&lt;br/&gt;&lt;br/&gt;  Function GetVector(p_geometry  IN mdsys.sdo_geometry,&lt;br/&gt;                     p_exception IN PLS_INTEGER DEFAULT 0)&lt;br/&gt;    Return codesys.SDO_ERROR.T_VectorSet pipelined&lt;br/&gt;  Is&lt;br/&gt;    v_element        mdsys.sdo_geometry;&lt;br/&gt;    v_ring           mdsys.sdo_geometry;&lt;br/&gt;    v_element_no     pls_integer;&lt;br/&gt;    v_ring_no        pls_integer;&lt;br/&gt;    v_num_elements   pls_integer;&lt;br/&gt;    v_num_rings      pls_integer;&lt;br/&gt;    v_dims           pls_integer;&lt;br/&gt;    v_coordinates    mdsys.vertex_set_type;&lt;br/&gt;    NULL_GEOMETRY    EXCEPTION;&lt;br/&gt;    NOT_CIRCULAR_ARC EXCEPTION;&lt;br/&gt;&lt;br/&gt;    Function Vertex2Vertex(p_vertex in mdsys.vertex_type,&lt;br/&gt;                           p_id     in pls_integer)&lt;br/&gt;      return codesys.T_Vertex deterministic&lt;br/&gt;    Is&lt;br/&gt;    Begin&lt;br/&gt;       if ( p_vertex is null ) then&lt;br/&gt;          return null;&lt;br/&gt;       end if;&lt;br/&gt;       return new codesys.T_Vertex(p_vertex.x,p_vertex.y,p_vertex.z,p_vertex.w,p_id);&lt;br/&gt;    End Vertex2Vertex;&lt;br/&gt;&lt;br/&gt;  Begin&lt;br/&gt;    If ( p_geometry is NULL ) Then&lt;br/&gt;       If ( p_exception is null or p_exception = 1) then&lt;br/&gt;          raise NULL_GEOMETRY;&lt;br/&gt;       Else&lt;br/&gt;          return;&lt;br/&gt;       End If;&lt;br/&gt;    End If;&lt;br/&gt;&lt;br/&gt;    -- No Points&lt;br/&gt;    -- DEBUG  logger(p_geometry.sdo_gtype);&lt;br/&gt;    If ( Mod(p_geometry.sdo_gtype,10) in (1,5) ) Then&lt;br/&gt;      Return;&lt;br/&gt;    End If;&lt;br/&gt;&lt;br/&gt;   If ( hasCircularArcs(p_geometry.sdo_elem_info) ) Then&lt;br/&gt;       If ( p_exception is null or p_exception = 1) then&lt;br/&gt;          raise NOT_CIRCULAR_ARC;&lt;br/&gt;       Else&lt;br/&gt;          return;&lt;br/&gt;       End If;&lt;br/&gt;   End If;&lt;br/&gt;&lt;br/&gt;   v_num_elements := MDSYS.SDO_UTIL.GETNUMELEM(p_geometry);&lt;br/&gt;   -- DEBUG logger(&apos;GetVector=&apos; || v_num_elements);&lt;br/&gt;&lt;br/&gt;   &lt;&lt;all_elements&gt;&gt;&lt;br/&gt;   FOR v_element_no IN 1..v_num_elements LOOP&lt;br/&gt;       v_element := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,0);&lt;br/&gt;       -- DEBUG logger(&apos;v_element extracted &apos; || case when v_element is null then &apos;null&apos; else &apos;not null&apos; end );&lt;br/&gt;       If ( v_element is not null ) Then&lt;br/&gt;           -- Polygons&lt;br/&gt;           -- Need to check for inner rings&lt;br/&gt;           --&lt;br/&gt;           -- DEBUG logger( v_element.get_gtype());&lt;br/&gt;           If ( v_element.get_gtype() = 3) Then&lt;br/&gt;              -- Process all rings in this single polygon have?&lt;br/&gt;              v_num_rings := GetNumRings(v_element,0);&lt;br/&gt;              -- DEBUG logger(&apos;v_num_rings=&apos; || v_num_rings);&lt;br/&gt;&lt;br/&gt;              &lt;&lt;All_Rings&gt;&gt;&lt;br/&gt;              FOR v_ring_no IN 1..v_num_rings LOOP&lt;br/&gt;                  v_ring := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,v_ring_no);&lt;br/&gt;                  -- Now generate marks&lt;br/&gt;                  If ( v_ring is not null ) Then&lt;br/&gt;                      v_coordinates := mdsys.sdo_util.getVertices(v_ring);&lt;br/&gt;                      If ( v_ring.sdo_elem_info(2) in (1003,2003) And v_coordinates.COUNT = 2 ) Then&lt;br/&gt;                         PIPE ROW( codesys.T_Vector(1,&lt;br/&gt;                                                    Vertex2Vertex(v_coordinates(1),1),&lt;br/&gt;                                                    codesys.T_Vertex(v_coordinates(2).x, v_coordinates(1).y,&lt;br/&gt;                                                                     v_coordinates(1).z, v_coordinates(1).w,&lt;br/&gt;                                                                     2) ) );&lt;br/&gt;                         PIPE ROW( codesys.T_Vector(2,&lt;br/&gt;                                                    codesys.T_Vertex(v_coordinates(2).x, v_coordinates(1).y,&lt;br/&gt;                                                                     v_coordinates(1).z, v_coordinates(1).w,&lt;br/&gt;                                                                2),&lt;br/&gt;                                                    Vertex2Vertex(v_coordinates(2),3) ) );&lt;br/&gt;                         PIPE ROW( codesys.T_Vector(3,&lt;br/&gt;                                                    Vertex2Vertex(v_coordinates(2),3),&lt;br/&gt;                                                    codesys.T_Vertex(v_coordinates(1).x, v_coordinates(2).y,&lt;br/&gt;                                                                     v_coordinates(1).z, v_coordinates(1).w,&lt;br/&gt;                                                                     4) ) );&lt;br/&gt;                         PIPE ROW( codesys.T_Vector(4,&lt;br/&gt;                                                    codesys.T_Vertex(v_coordinates(1).x, v_coordinates(2).y,&lt;br/&gt;                                                                     v_coordinates(1).z, v_coordinates(1).w,&lt;br/&gt;                                                                     4),&lt;br/&gt;                                                    Vertex2Vertex(v_coordinates(1),5) ) );&lt;br/&gt;                      Else&lt;br/&gt;                         FOR v_coord_no IN 1..v_coordinates.COUNT-1 LOOP&lt;br/&gt;                            PIPE ROW(codesys.T_Vector(v_coord_no,&lt;br/&gt;                                                      codesys.T_Vertex(v_coordinates(v_coord_no).x,&lt;br/&gt;                                                                       v_coordinates(v_coord_no).y,&lt;br/&gt;                                                                       v_coordinates(v_coord_no).z,&lt;br/&gt;                                                                       v_coordinates(v_coord_no).w,&lt;br/&gt;                                                                       v_coord_no),&lt;br/&gt;                                                      codesys.T_Vertex(v_coordinates(v_coord_no+1).x,&lt;br/&gt;                                                                       v_coordinates(v_coord_no+1).y,&lt;br/&gt;                                                                       v_coordinates(v_coord_no+1).z,&lt;br/&gt;                                                                       v_coordinates(v_coord_no+1).w,&lt;br/&gt;                                                                       v_coord_no + 1) ) );&lt;br/&gt;                         END LOOP;&lt;br/&gt;                      End If;&lt;br/&gt;                  End If;&lt;br/&gt;              END LOOP All_Rings;&lt;br/&gt;           -- Linestrings&lt;br/&gt;           --&lt;br/&gt;           ElsIf ( v_element.get_gtype() = 2) Then&lt;br/&gt;               v_coordinates := mdsys.sdo_util.getVertices(v_element);&lt;br/&gt;               FOR v_coord_no IN 1..v_coordinates.COUNT-1 LOOP&lt;br/&gt;                   PIPE ROW(codesys.T_Vector(v_coord_no,&lt;br/&gt;                                             codesys.T_Vertex(v_coordinates(v_coord_no).x,&lt;br/&gt;                                                              v_coordinates(v_coord_no).y,&lt;br/&gt;                                                              v_coordinates(v_coord_no).z,&lt;br/&gt;                                                              v_coordinates(v_coord_no).w,&lt;br/&gt;                                                              v_coord_no),&lt;br/&gt;                                             codesys.T_Vertex(v_coordinates(v_coord_no+1).x,&lt;br/&gt;                                                              v_coordinates(v_coord_no+1).y,&lt;br/&gt;                                                              v_coordinates(v_coord_no+1).z,&lt;br/&gt;                                                              v_coordinates(v_coord_no+1).w,&lt;br/&gt;                                                              v_coord_no + 1)) );&lt;br/&gt;               END LOOP;&lt;br/&gt;           End If;&lt;br/&gt;       End If;&lt;br/&gt;   END LOOP all_elements;&lt;br/&gt;   RETURN;&lt;br/&gt;   EXCEPTION&lt;br/&gt;      WHEN NULL_GEOMETRY THEN&lt;br/&gt;        raise_application_error(c_i_null_geometry, c_s_null_geometry,TRUE);&lt;br/&gt;        RETURN;&lt;br/&gt;      WHEN NOT_CIRCULAR_ARC THEN&lt;br/&gt;        raise_application_error(c_i_arcs_unsupported, c_s_arcs_unsupported,TRUE);&lt;br/&gt;        RETURN;&lt;br/&gt;  End GetVector;&lt;br/&gt;&lt;br/&gt;  Procedure ADD_Element( p_sdo_elem_info   in out nocopy mdsys.sdo_elem_info_array,&lt;br/&gt;                         p_elem_info_array in mdsys.sdo_elem_info_array,&lt;br/&gt;                         p_ordinates       in mdsys.sdo_ordinate_array)&lt;br/&gt;  IS&lt;br/&gt;    v_i          pls_integer;&lt;br/&gt;    v_end_elem   pls_integer;&lt;br/&gt;    v_additional pls_integer;&lt;br/&gt;    v_ord_count  pls_integer;&lt;br/&gt;  Begin&lt;br/&gt;    if ( p_sdo_elem_info is null&lt;br/&gt;         or&lt;br/&gt;         p_elem_info_array is null ) Then&lt;br/&gt;         return;&lt;br/&gt;    End If;&lt;br/&gt;    v_ord_count  := CASE WHEN p_ordinates is null THEN 0 ELSE p_ordinates.COUNT END;&lt;br/&gt;    v_end_elem   := p_sdo_elem_info.COUNT;&lt;br/&gt;    v_additional := p_elem_info_array.COUNT;&lt;br/&gt;    p_sdo_elem_info.extend(v_additional);&lt;br/&gt;    FOR v_i IN 1..v_additional LOOP&lt;br/&gt;        if ( MOD(v_i,3) = 1 ) then&lt;br/&gt;           p_sdo_elem_info(v_end_elem + v_i) := v_ord_count + p_Elem_Info_array(v_i);&lt;br/&gt;        else&lt;br/&gt;           p_sdo_elem_info(v_end_elem + v_i) := p_Elem_Info_array(v_i);&lt;br/&gt;        End If;&lt;br/&gt;    END LOOP;&lt;br/&gt;  END ADD_Element;&lt;br/&gt;&lt;br/&gt;  Procedure ADD_Ordinates(p_sdo_ordinates in out nocopy mdsys.sdo_ordinate_array,&lt;br/&gt;                          p_ordinates     in mdsys.sdo_ordinate_array)&lt;br/&gt;  IS&lt;br/&gt;    v_i          pls_integer;&lt;br/&gt;    v_start      pls_integer;&lt;br/&gt;    v_additional pls_integer;&lt;br/&gt;  Begin&lt;br/&gt;    if ( p_sdo_ordinates is null&lt;br/&gt;         or&lt;br/&gt;         p_ordinates is null ) Then&lt;br/&gt;         return;&lt;br/&gt;    End If;&lt;br/&gt;    v_start      := p_sdo_ordinates.COUNT;&lt;br/&gt;    v_additional := p_ordinates.COUNT;&lt;br/&gt;    p_sdo_ordinates.extend(v_additional);&lt;br/&gt;    FOR v_i IN 1..v_additional LOOP&lt;br/&gt;        p_sdo_ordinates(v_start + v_i) := p_ordinates(v_i);&lt;br/&gt;    END LOOP;&lt;br/&gt;  END ADD_Ordinates;&lt;br/&gt;&lt;br/&gt;  PROCEDURE ADD_Coordinate( p_ordinates  in out nocopy mdsys.sdo_ordinate_array,&lt;br/&gt;                            p_dim        in number,&lt;br/&gt;                            p_x_coord    in number,&lt;br/&gt;                            p_y_coord    in number,&lt;br/&gt;                            p_z_coord    in number,&lt;br/&gt;                            p_m_coord    in number,&lt;br/&gt;                            p_measured   in boolean := false,&lt;br/&gt;                            p_duplicates in boolean := false)&lt;br/&gt;    IS&lt;br/&gt;      Function Duplicate&lt;br/&gt;        Return Boolean&lt;br/&gt;      Is&lt;br/&gt;      Begin&lt;br/&gt;        Return case when p_ordinates is null or p_ordinates.count = 0&lt;br/&gt;                    then False&lt;br/&gt;                    Else case p_dim&lt;br/&gt;                              when 2&lt;br/&gt;                              then ( p_ordinates(p_ordinates.COUNT)   = p_y_coord&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-1) = p_x_coord )&lt;br/&gt;                              when 3&lt;br/&gt;                              then ( p_ordinates(p_ordinates.COUNT)   =  case when p_measured then p_m_coord else p_z_coord end&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-1) = p_y_coord&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-2) = p_x_coord )&lt;br/&gt;                              when 4&lt;br/&gt;                              then ( p_ordinates(p_ordinates.COUNT)   = p_m_coord&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-1) = p_z_coord&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-2) = p_y_coord&lt;br/&gt;                                     AND&lt;br/&gt;                                     p_ordinates(p_ordinates.COUNT-3) = p_x_coord )&lt;br/&gt;                          end&lt;br/&gt;                  End;&lt;br/&gt;      End Duplicate;&lt;br/&gt;&lt;br/&gt;  Begin&lt;br/&gt;    If ( p_ordinates is null ) Then&lt;br/&gt;       p_ordinates := new mdsys.sdo_ordinate_array(null);&lt;br/&gt;       p_ordinates.DELETE;&lt;br/&gt;    End If;&lt;br/&gt;    If ( p_duplicates or Not Duplicate() ) Then&lt;br/&gt;      IF ( p_dim &gt;= 2 ) Then&lt;br/&gt;        p_ordinates.extend(2);&lt;br/&gt;        p_ordinates(p_ordinates.count-1) := p_x_coord;&lt;br/&gt;        p_ordinates(p_ordinates.count  ) := p_y_coord;&lt;br/&gt;      END IF;&lt;br/&gt;      IF ( p_dim &gt;= 3 ) Then&lt;br/&gt;        p_ordinates.extend(1);&lt;br/&gt;        p_ordinates(p_ordinates.count)   := case when p_dim = 3 And p_measured&lt;br/&gt;                                                 then p_m_coord&lt;br/&gt;                                                 else p_z_coord&lt;br/&gt;                                            end;&lt;br/&gt;      END IF;&lt;br/&gt;      IF ( p_dim = 4 ) Then&lt;br/&gt;        p_ordinates.extend(1);&lt;br/&gt;        p_ordinates(p_ordinates.count)   := p_m_coord;&lt;br/&gt;      END IF;&lt;br/&gt;    End If;&lt;br/&gt;  END ADD_Coordinate;&lt;br/&gt;&lt;br/&gt;  PROCEDURE ADD_Coordinate( p_ordinates  in out nocopy mdsys.sdo_ordinate_array,&lt;br/&gt;                            p_dim        in number,&lt;br/&gt;                            p_coord      in mdsys.sdo_point_type,&lt;br/&gt;                            p_measured   in boolean := false,&lt;br/&gt;                            p_duplicates in boolean := false)&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    ADD_Coordinate( p_ordinates, p_dim, p_coord.x, p_coord.y, p_coord.z, NULL, p_measured, p_duplicates);&lt;br/&gt;  END Add_Coordinate;&lt;br/&gt;&lt;br/&gt;  Function hasRectangles( p_elem_info in mdsys.sdo_elem_info_array  )&lt;br/&gt;    Return Pls_Integer&lt;br/&gt;  Is&lt;br/&gt;     v_rectangle_count number := 0;&lt;br/&gt;     v_etype           pls_integer;&lt;br/&gt;     v_interpretation  pls_integer;&lt;br/&gt;     v_elements        pls_integer;&lt;br/&gt;  Begin&lt;br/&gt;     If ( p_elem_info is null ) Then&lt;br/&gt;        return 0;&lt;br/&gt;     End If;&lt;br/&gt;     v_elements := ( ( p_elem_info.COUNT / 3 ) - 1 );&lt;br/&gt;     &lt;&lt;element_extraction&gt;&gt;&lt;br/&gt;     for v_i IN 0 .. v_elements LOOP&lt;br/&gt;       v_etype := p_elem_info(v_i * 3 + 2);&lt;br/&gt;       v_interpretation := p_elem_info(v_i * 3 + 3);&lt;br/&gt;       If  ( v_etype in (1003,2003) AND v_interpretation = 3  ) Then&lt;br/&gt;           v_rectangle_count := v_rectangle_count + 1;&lt;br/&gt;       end If;&lt;br/&gt;     end loop element_extraction;&lt;br/&gt;     Return v_rectangle_Count;&lt;br/&gt;  End hasRectangles;&lt;br/&gt;&lt;br/&gt;  Function Rectangle2Polygon(p_geometry in mdsys.sdo_geometry)&lt;br/&gt;    return mdsys.sdo_geometry deterministic&lt;br/&gt;  As&lt;br/&gt;    v_dims      pls_integer;&lt;br/&gt;    v_ordinates mdsys.sdo_ordinate_array := new mdsys.sdo_ordinate_array(null);&lt;br/&gt;    v_vertices  mdsys.vertex_set_type;&lt;br/&gt;    v_etype     pls_integer;&lt;br/&gt;    v_start_coord mdsys.vertex_type;&lt;br/&gt;    v_end_coord   mdsys.vertex_type;&lt;br/&gt;  Begin&lt;br/&gt;      v_ordinates.DELETE;&lt;br/&gt;      v_dims        := p_geometry.get_dims();&lt;br/&gt;      v_etype       := p_geometry.sdo_elem_info(2);&lt;br/&gt;      v_vertices    := sdo_util.getVertices(p_geometry);&lt;br/&gt;      v_start_coord := v_vertices(1);&lt;br/&gt;      v_end_coord   := v_vertices(2);&lt;br/&gt;      -- First coordinate&lt;br/&gt;      ADD_Coordinate( v_ordinates, v_dims, v_start_coord.x, v_start_coord.y, v_start_coord.z, v_start_coord.w );&lt;br/&gt;      -- Second coordinate&lt;br/&gt;      If ( v_etype = 1003 ) Then&lt;br/&gt;        ADD_Coordinate(v_ordinates,v_dims,v_end_coord.x,v_start_coord.y,(v_start_coord.z + v_end_coord.z) /2, v_start_coord.w);&lt;br/&gt;      Else&lt;br/&gt;        ADD_Coordinate(v_ordinates,v_dims,v_start_coord.x,v_end_coord.y,(v_start_coord.z + v_end_coord.z) /2,&lt;br/&gt;            (v_end_coord.w - v_start_coord.w) * ((v_end_coord.x - v_start_coord.x) /&lt;br/&gt;           ((v_end_coord.x - v_start_coord.x) + (v_end_coord.y - v_start_coord.y)) ));&lt;br/&gt;      End If;&lt;br/&gt;      -- 3rd or middle coordinate&lt;br/&gt;      ADD_Coordinate(v_ordinates,v_dims,v_end_coord.x,v_end_coord.y,v_end_coord.z,v_end_coord.w);&lt;br/&gt;      -- 4th coordinate&lt;br/&gt;      If ( v_etype = 1003 ) Then&lt;br/&gt;        ADD_Coordinate(v_ordinates,v_dims,v_start_coord.x,v_end_coord.y,(v_start_coord.z + v_end_coord.z) /2,v_start_coord.w);&lt;br/&gt;      Else&lt;br/&gt;        Add_Coordinate(v_ordinates,v_dims,v_end_coord.x,v_start_coord.y,(v_start_coord.z + v_end_coord.z) /2,&lt;br/&gt;            (v_end_coord.w - v_start_coord.w) * ((v_end_coord.x - v_start_coord.x) /&lt;br/&gt;           ((v_end_coord.x - v_start_coord.x) + (v_end_coord.y - v_start_coord.y)) ));&lt;br/&gt;      End If;&lt;br/&gt;      -- Last coordinate&lt;br/&gt;      ADD_Coordinate(v_ordinates,v_dims,v_start_coord.x,v_start_coord.y,v_start_coord.z,v_start_coord.w);&lt;br/&gt;      return mdsys.sdo_geometry(p_geometry.sdo_gtype,p_geometry.sdo_srid,null,mdsys.sdo_elem_info_array(1,v_etype,1),v_ordinates);&lt;br/&gt;  End Rectangle2Polygon;&lt;br/&gt;&lt;br/&gt;  Function isMeasured( p_gtype in number )&lt;br/&gt;    return boolean&lt;br/&gt;  is&lt;br/&gt;  Begin&lt;br/&gt;    Return CASE WHEN MOD(trunc(p_gtype/100),10) = 0&lt;br/&gt;                THEN False&lt;br/&gt;                ELSE True&lt;br/&gt;             END;&lt;br/&gt;  End isMeasured;&lt;br/&gt;&lt;br/&gt;  Function isOrientedPoint( p_elem_info in mdsys.sdo_elem_info_array)&lt;br/&gt;    return boolean&lt;br/&gt;  is&lt;br/&gt;  Begin&lt;br/&gt;    /* Single Oriented Point&lt;br/&gt;    // Sdo_Elem_Info = (1,1,1, 3,1,0), SDO_ORDINATE_ARRAY(12,14, 0.3,0.2)));&lt;br/&gt;    // The Final 1,0 In 3,1,0 Indicates That This Is An Oriented Point.&lt;br/&gt;    //&lt;br/&gt;    // Multi Oriented Point&lt;br/&gt;    // Sdo_Elem_Info_Array(1,1,1, 3,1,0, 5,1,1, 7,1,0), Sdo_Ordinate_Array(12,14, 0.3,0.2, 12,10, -1,-1)));&lt;br/&gt;    */&lt;br/&gt;    If ( P_Elem_Info Is Null ) Then&lt;br/&gt;       Return False;&lt;br/&gt;    Elsif ( P_Elem_Info.Count &gt;= 6 ) Then&lt;br/&gt;       Return ( P_Elem_Info(2) = 1 ) /* Point */          And&lt;br/&gt;              ( P_Elem_Info(3) = 1 ) /* Singlge Point */  And&lt;br/&gt;              ( P_Elem_Info(5) = 1 ) /* Oriented Point */ And&lt;br/&gt;              ( P_Elem_Info(6) = 0 );&lt;br/&gt;    Else&lt;br/&gt;       Return false;&lt;br/&gt;    End If;&lt;br/&gt;  End isOrientedPoint;&lt;br/&gt;&lt;br/&gt;  Function GetDimensions( p_gtype in number )&lt;br/&gt;    return integer&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    return TRUNC(p_gtype/1000,0);&lt;br/&gt;  End GetDimensions;&lt;br/&gt;&lt;br/&gt;  Function GetElemInfo(&lt;br/&gt;    p_geometry in mdsys.sdo_geometry)&lt;br/&gt;    Return codesys.SDO_ERROR.T_ElemInfoSet pipelined&lt;br/&gt;  Is&lt;br/&gt;    v_elements  number;&lt;br/&gt;  Begin&lt;br/&gt;    If ( p_geometry is not null ) Then&lt;br/&gt;      v_elements := ( ( p_geometry.sdo_elem_info.COUNT / 3 ) - 1 );&lt;br/&gt;      &lt;&lt;element_extraction&gt;&gt;&lt;br/&gt;      for v_i IN 0 .. v_elements LOOP&lt;br/&gt;         PIPE ROW ( codesys.T_ElemInfo(&lt;br/&gt;                      p_geometry.sdo_elem_info(v_i * 3 + 1),&lt;br/&gt;                      p_geometry.sdo_elem_info(v_i * 3 + 2),&lt;br/&gt;                      p_geometry.sdo_elem_info(v_i * 3 + 3) ) );&lt;br/&gt;        end loop element_extraction;&lt;br/&gt;    End If;&lt;br/&gt;    Return;&lt;br/&gt;  End GetElemInfo;&lt;br/&gt;&lt;br/&gt;  Function GetNumElem( p_geometry IN mdsys.sdo_geometry )&lt;br/&gt;    return number&lt;br/&gt;  Is&lt;br/&gt;    TYPE T_elemCursor IS REF CURSOR;&lt;br/&gt;    c_elems                T_elemCursor;&lt;br/&gt;    v_num_elems            number := 0;&lt;br/&gt;    v_rin                  number := 0;&lt;br/&gt;    v_compound_element     boolean := FALSE;&lt;br/&gt;    v_compound_element_end number := 0;&lt;br/&gt;  Begin&lt;br/&gt;    If ( p_geometry is not null ) Then&lt;br/&gt;      If ( p_geometry.sdo_elem_info is not null ) Then&lt;br/&gt;        If ( DBMS_DB_VERSION.VERSION &lt; 10 ) Then&lt;br/&gt;          -- Get count of all elements&lt;br/&gt;          OPEN c_elems FOR&lt;br/&gt;            &apos;SELECT rownum as rin,&lt;br/&gt;                    case when i.etype in (4,5,1005,2005) then i.interpretation + rownum else 0 end as celem&lt;br/&gt;               FROM (SELECT rownum as id,&lt;br/&gt;                            e.interpretation,&lt;br/&gt;                            e.etype,&lt;br/&gt;                            e.offset&lt;br/&gt;                      FROM TABLE(codesys.SDO_ERROR.GetElemInfo(:1)) e&lt;br/&gt;                         ) i&apos;&lt;br/&gt;            USING p_geometry;&lt;br/&gt;          LOOP&lt;br/&gt;            FETCH c_elems INTO v_rin, v_compound_element_end;&lt;br/&gt;            EXIT WHEN c_elems%NOTFOUND;&lt;br/&gt;            If ( v_compound_element_end &lt;&gt; 0 ) Then&lt;br/&gt;              v_compound_element := TRUE;&lt;br/&gt;              v_num_elems := v_num_elems + 1;&lt;br/&gt;            Else&lt;br/&gt;              If ( v_compound_element ) Then&lt;br/&gt;                 If ( v_compound_element_end = v_rin ) Then&lt;br/&gt;                    v_compound_element := FALSE;&lt;br/&gt;                 End If;&lt;br/&gt;              Else&lt;br/&gt;                 v_num_elems := v_num_elems + 1;&lt;br/&gt;              End If;&lt;br/&gt;            End If;&lt;br/&gt;          END LOOP;&lt;br/&gt;        Else&lt;br/&gt;          EXECUTE IMMEDIATE &apos;SELECT mdsys.sdo_util.GetNumElem(:1) FROM DUAL&apos; INTO v_num_elems USING p_geometry ;&lt;br/&gt;        END IF;&lt;br/&gt;      End If;&lt;br/&gt;    End If;&lt;br/&gt;    RETURN v_num_elems;&lt;br/&gt;  End GetNumElem;&lt;br/&gt;&lt;br/&gt;  Procedure FindLineIntersection(&lt;br/&gt;    x11       in number,        y11       in number,&lt;br/&gt;    x12       in number,        y12       in number,&lt;br/&gt;    x21       in number,        y21       in number,&lt;br/&gt;    x22       in number,        y22       in number,&lt;br/&gt;    inter_x  out nocopy number, inter_y  out nocopy number,&lt;br/&gt;    inter_x1 out nocopy number, inter_y1 out nocopy number,&lt;br/&gt;    inter_x2 out nocopy number, inter_y2 out nocopy number )&lt;br/&gt;  IS&lt;br/&gt;      X1          NUMBER;&lt;br/&gt;      Y1          NUMBER;&lt;br/&gt;      dx2         NUMBER;&lt;br/&gt;      dy2         NUMBER;&lt;br/&gt;      t1          NUMBER;&lt;br/&gt;      t2          NUMBER;&lt;br/&gt;      denominator NUMBER;&lt;br/&gt;  BEGIN&lt;br/&gt;    -- Get the segments&apos; parameters.&lt;br/&gt;    X1 := x12 - x11;&lt;br/&gt;    Y1 := y12 - y11;&lt;br/&gt;    dx2 := x22 - x21;&lt;br/&gt;    dy2 := y22 - y21;&lt;br/&gt;&lt;br/&gt;    -- Solve for t1 and t2.&lt;br/&gt;    denominator := (Y1 * dx2 - X1 * dy2);&lt;br/&gt;    IF ( denominator = 0 ) Then&lt;br/&gt;      -- The lines are parallel.&lt;br/&gt;      inter_x  := c_Max;&lt;br/&gt;      inter_y  := c_Max;&lt;br/&gt;      inter_x1 := c_Max;&lt;br/&gt;      inter_y1 := c_Max;&lt;br/&gt;      inter_x2 := c_Max;&lt;br/&gt;      inter_y2 := c_Max;&lt;br/&gt;      RETURN;&lt;br/&gt;    End If;&lt;br/&gt;    t1 := ((x11 - x21) * dy2 + (y21 - y11) * dx2) /  denominator;&lt;br/&gt;    t2 := ((x21 - x11) * Y1  + (y11 - y21) * X1)  / -denominator;&lt;br/&gt;&lt;br/&gt;    -- Find the point of intersection.&lt;br/&gt;    inter_x := x11 + X1 * t1;&lt;br/&gt;    inter_y := y11 + Y1 * t1;&lt;br/&gt;&lt;br/&gt;    -- Find the closest points on the segments.&lt;br/&gt;    If t1 &lt; 0 Then&lt;br/&gt;      t1 := 0;&lt;br/&gt;    ElsIf t1 &gt; 1 Then&lt;br/&gt;      t1 := 1;&lt;br/&gt;    End If;&lt;br/&gt;    If t2 &lt; 0 Then&lt;br/&gt;      t2 := 0;&lt;br/&gt;    ElsIf t2 &gt; 1 Then&lt;br/&gt;      t2 := 1;&lt;br/&gt;    End If;&lt;br/&gt;    inter_x1 := x11 + X1 * t1;&lt;br/&gt;    inter_y1 := y11 + Y1 * t1;&lt;br/&gt;    inter_x2 := x21 + dx2 * t2;&lt;br/&gt;    inter_y2 := y21 + dy2 * t2;&lt;br/&gt;  END FindLineIntersection;&lt;br/&gt;&lt;br/&gt;  Procedure FindLineIntersection(&lt;br/&gt;    p_vector1 in t_vector,      p_vector2 in t_vector,&lt;br/&gt;    inter_x  out nocopy number, inter_y  out nocopy number,&lt;br/&gt;    inter_x1 out nocopy number, inter_y1 out nocopy number,&lt;br/&gt;    inter_x2 out nocopy number, inter_y2 out nocopy number )&lt;br/&gt;  IS&lt;br/&gt;  BEGIN&lt;br/&gt;      FindLineIntersection(&lt;br/&gt;          p_vector1.startCoord.x, p_vector1.startCoord.y,&lt;br/&gt;          p_vector1.endCoord.x,   p_vector1.endCoord.y,&lt;br/&gt;          p_vector2.startCoord.x, p_vector2.startCoord.y,&lt;br/&gt;          p_vector2.endCoord.x,   p_vector2.endCoord.y,&lt;br/&gt;          inter_x,  inter_y,&lt;br/&gt;          inter_x1, inter_y1,&lt;br/&gt;          inter_x2, inter_y2);&lt;br/&gt;  END FindLineIntersection;&lt;br/&gt;&lt;br/&gt;  /* **************************** COGO FUNCTIONS *************************** */&lt;br/&gt;&lt;br/&gt;  Function degrees(p_radians in number)&lt;br/&gt;    return number&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    return p_radians * (180.0 / c_PI);&lt;br/&gt;  End degrees;&lt;br/&gt;&lt;br/&gt;  Function radians(p_degrees in number)&lt;br/&gt;    Return number&lt;br/&gt;  Is&lt;br/&gt;  Begin&lt;br/&gt;    Return p_degrees * (c_PI / 180.0);&lt;br/&gt;  End radians;&lt;br/&gt;&lt;br/&gt;  Function Bearing(dE1 in number, dN1 in number,&lt;br/&gt;                   dE2 in number, dN2 in number)&lt;br/&gt;    Return Number&lt;br/&gt;  IS&lt;br/&gt;      dBearing Number;&lt;br/&gt;      dEast    Number;&lt;br/&gt;      dNorth   Number;&lt;br/&gt;  BEGIN&lt;br/&gt;      If (   dE1 Is Null or dN1 Is Null&lt;br/&gt;          or dE2 Is Null or dE1 Is null )&lt;br/&gt;      Then&lt;br/&gt;         Return Null;&lt;br/&gt;      End If;&lt;br/&gt;      If ( (dE1 = dE2) And (dN1 = dN2) ) Then&lt;br/&gt;         Return Null;&lt;br/&gt;      End If;&lt;br/&gt;      dEast  := dE2 - dE1;&lt;br/&gt;      dNorth := dN2 - dN1;&lt;br/&gt;      If ( dEast = 0 ) Then&lt;br/&gt;          If ( dNorth &lt; 0 ) Then&lt;br/&gt;              dBearing := c_PI;&lt;br/&gt;          Else&lt;br/&gt;              dBearing := 0;&lt;br/&gt;          End If;&lt;br/&gt;      Else&lt;br/&gt;          dBearing := -aTan(dNorth / dEast) + c_PI / 2;&lt;br/&gt;      End If;&lt;br/&gt;      If ( dEast &lt; 0 ) Then&lt;br/&gt;          dBearing := dBearing + c_PI;&lt;br/&gt;      End If;&lt;br/&gt;      Return dBearing;&lt;br/&gt;  End Bearing;&lt;br/&gt;&lt;br/&gt;  Function Bearing(startCoord in mdsys.sdo_point_type,&lt;br/&gt;                     endCoord in mdsys.sdo_point_type)&lt;br/&gt;  Return Number&lt;br/&gt;  IS&lt;br/&gt;  Begin&lt;br/&gt;    Return Bearing( startCoord.X, startCoord.Y, endCoord.X, endCoord.Y );&lt;br/&gt;  End Bearing;&lt;br/&gt;&lt;br/&gt;  Function Bearing(startCoord in mdsys.vertex_type,&lt;br/&gt;                     endCoord in mdsys.vertex_type)&lt;br/&gt;  Return Number&lt;br/&gt;  IS&lt;br/&gt;  Begin&lt;br/&gt;    Return Bearing( startCoord.X, startCoord.Y, endCoord.X, endCoord.Y );&lt;br/&gt;  End Bearing;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;  /* **************************************************************************************************** */&lt;br/&gt;&lt;br/&gt;  /**&lt;br/&gt;  * ******************************* Error functions ****************************&lt;br/&gt;  * Examples: [Element &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Coordinate &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Coordinate &lt;&gt;][Ring &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Ring &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Ring &lt;&gt;][Edge &lt;&gt;] [Element &lt;&gt;] [Ring &lt;&gt;][Edge &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Ring &lt;&gt;][Edge &lt;&gt;][Edge &lt;&gt;]&lt;br/&gt;              [Element &lt;&gt;] [Rings , ][Edge &lt;&gt; in ring &lt;&gt;][Edge &lt;&gt; in ring &lt;&gt;]&lt;br/&gt;  **/&lt;br/&gt; Function getValidateErrors(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                            p_tolerance   in number      default 0.005,&lt;br/&gt;                            p_geog_digits in pls_integer default NULL,&lt;br/&gt;                            p_srid        in pls_integer default NULL,&lt;br/&gt;                            p_all         in pls_integer default 0,&lt;br/&gt;                            p_drilldown   in pls_integer default 1,&lt;br/&gt;                            p_context     in varchar2    default null)&lt;br/&gt;    return codesys.SDO_ERROR.T_ErrorSet pipelined&lt;br/&gt;  AS&lt;br/&gt;      v_validate   varchar2(10);&lt;br/&gt;      v_round      pls_integer := case when p_geog_digits is not null&lt;br/&gt;                                       then p_geog_digits&lt;br/&gt;                                       else case when p_tolerance is null&lt;br/&gt;                                                 then 3&lt;br/&gt;                                                 else round(log(10,(1/p_tolerance)/2))&lt;br/&gt;                                             end&lt;br/&gt;                                   end;&lt;br/&gt;      v_all        boolean := p_all &lt;&gt; 0;&lt;br/&gt;      v_point      mdsys.sdo_geometry;&lt;br/&gt;      v_geom       mdsys.sdo_geometry;&lt;br/&gt;      v_element    mdsys.sdo_geometry;&lt;br/&gt;      V_Ring       Mdsys.Sdo_Geometry;&lt;br/&gt;      v_edge       mdsys.sdo_geometry;&lt;br/&gt;      V_Prev_Edge  Mdsys.Sdo_Geometry;&lt;br/&gt;      v_vector     codesys.t_vector;&lt;br/&gt;      v_vectors    codesys.SDO_ERROR.T_VectorSet;&lt;br/&gt;      v_vector_max pls_integer;&lt;br/&gt;      v_vertices   MDSYS.VERTEX_SET_TYPE;&lt;br/&gt;      v_part       mdsys.sdo_geometry;&lt;br/&gt;      v_row        PLS_INTEGER;&lt;br/&gt;      V_Validation Varchar2(20000);&lt;br/&gt;      v_error      varchar2(100);&lt;br/&gt;&lt;br/&gt;      V_Dims       Pls_Integer;&lt;br/&gt;      V_Gtype_P    Pls_Integer;&lt;br/&gt;      V_Gtype_l    Pls_Integer;&lt;br/&gt;      v_vertex     PLS_INTEGER;&lt;br/&gt;      v_rings      PLS_INTEGER;&lt;br/&gt;      v_elements   PLS_INTEGER;&lt;br/&gt;      v_element_no PLS_INTEGER;&lt;br/&gt;      v_ring_no    PLS_INTEGER;&lt;br/&gt;      v_edge_no    PLS_INTEGER;&lt;br/&gt;      v_z          NUMBER;&lt;br/&gt;&lt;br/&gt;      Function FindPoint(p_vector1     codesys.T_Vector,&lt;br/&gt;                         p_vector2     codesys.T_Vector,&lt;br/&gt;                         p_tolerance   number,&lt;br/&gt;                         p_geog_digits pls_integer,&lt;br/&gt;                         p_pt_gtype    pls_integer,&lt;br/&gt;                         p_srid        pls_integer)&lt;br/&gt;        return mdsys.sdo_geometry&lt;br/&gt;      Is&lt;br/&gt;         v_round      pls_integer := case when p_geog_digits is not null&lt;br/&gt;                                         then p_geog_digits&lt;br/&gt;                                         else case when p_tolerance is null&lt;br/&gt;                                                   then 3&lt;br/&gt;                                                   else round(log(10,(1/p_tolerance)/2))&lt;br/&gt;                                               end&lt;br/&gt;                                     end;&lt;br/&gt;        v_validate   varchar2(10);&lt;br/&gt;        v_vector1    codesys.t_vector := p_vector1;&lt;br/&gt;        v_vector2    codesys.t_vector := p_vector2;&lt;br/&gt;        v_geom       mdsys.sdo_geometry;&lt;br/&gt;        v_geom1      mdsys.sdo_geometry;&lt;br/&gt;        v_geom2      mdsys.sdo_geometry;&lt;br/&gt;        v_inter_x    number;&lt;br/&gt;        v_inter_y    number;&lt;br/&gt;        v_inter_x1   number;&lt;br/&gt;        v_inter_y1   number;&lt;br/&gt;        v_inter_x2   number;&lt;br/&gt;        v_inter_y2   number;&lt;br/&gt;      Begin&lt;br/&gt;-- DEBUG logger(case when v_vector1 is null then &apos;NULL1&apos; else &apos;NOT NULL1&apos; end);&lt;br/&gt;-- DEBUG logger(case when v_vector2 is null then &apos;NULL2&apos; else &apos;NOT NULL2&apos; end);&lt;br/&gt;          v_validate := &apos;TOUCH&apos;;&lt;br/&gt;          if ( p_geog_digits IS NOT NULL) then&lt;br/&gt;            v_geom1 := sdo_geometry(2002,p_srid,null,&lt;br/&gt;                                      sdo_elem_info_array(1,2,1),&lt;br/&gt;                                      sdo_ordinate_array(p_vector1.startCoord.x, p_vector1.startCoord.y,&lt;br/&gt;                                                         p_vector1.endCoord.x,   p_vector1.endCoord.y));&lt;br/&gt;            v_geom2 := sdo_geometry(2002,p_srid,null,&lt;br/&gt;                                      sdo_elem_info_array(1,2,1),&lt;br/&gt;                                      sdo_ordinate_array(p_vector2.startCoord.x, p_vector2.startCoord.y,&lt;br/&gt;                                                         p_vector2.endCoord.x,   p_vector2.endCoord.y));&lt;br/&gt;            v_validate := substr(mdsys.sdo_geom.relate(v_geom1,&apos;DETERMINE&apos;,v_geom2,p_tolerance),1,10);&lt;br/&gt;-- DEBUG logger(v_validate);&lt;br/&gt;            If ( v_validate &lt;&gt; &apos;DISJOINT&apos; And p_srid is not null ) Then&lt;br/&gt;               -- Calculate new vector ordinates by projecting into a suitable UTM Zone&lt;br/&gt;               v_geom := mdsys.sdo_cs.transform(v_geom1,p_srid);&lt;br/&gt;               v_vector1.startCoord.x := v_geom.sdo_ordinates(1);&lt;br/&gt;               v_vector1.startCoord.y := v_geom.sdo_ordinates(2);&lt;br/&gt;               v_vector1.endCoord.x   := v_geom.sdo_ordinates(3);&lt;br/&gt;               v_vector1.endCoord.y   := v_geom.sdo_ordinates(4);&lt;br/&gt;               v_geom := mdsys.sdo_cs.transform(v_geom2,p_srid);&lt;br/&gt;               v_vector2.startCoord.x := v_geom.sdo_ordinates(1);&lt;br/&gt;               v_vector2.startCoord.y := v_geom.sdo_ordinates(2);&lt;br/&gt;               v_vector2.endCoord.x   := v_geom.sdo_ordinates(3);&lt;br/&gt;               v_vector2.endCoord.y   := v_geom.sdo_ordinates(4);&lt;br/&gt;-- DEBUG logger(substr(sdo_geom.relate(sdo_geometry(2002,p_srid,null,&lt;br/&gt;-- DEBUG                                       sdo_elem_info_array(1,2,1),&lt;br/&gt;-- DEBUG                                       sdo_ordinate_array(v_vector1.startCoord.x, v_vector1.startCoord.y,&lt;br/&gt;-- DEBUG                                                          v_vector1.endCoord.x,   v_vector1.endCoord.y)),&lt;br/&gt;-- DEBUG                       &apos;DETERMINE&apos;,&lt;br/&gt;-- DEBUG                       sdo_geometry(2002,p_srid,null,&lt;br/&gt;-- DEBUG                                       sdo_elem_info_array(1,2,1),&lt;br/&gt;-- DEBUG                                       sdo_ordinate_array(v_vector2.startCoord.x, v_vector2.startCoord.y,&lt;br/&gt;-- DEBUG                                                          v_vector2.endCoord.x,   v_vector2.endCoord.y)),&lt;br/&gt;-- DEBUG                       p_tolerance),1,10));&lt;br/&gt;            End If;&lt;br/&gt;         End If;&lt;br/&gt;         if ( v_validate &lt;&gt; &apos;DISJOINT&apos; ) Then&lt;br/&gt;-- DEBUG logger(&apos;FindLineIntersection&apos;);&lt;br/&gt;            -- Find actual intersection&lt;br/&gt;            --&lt;br/&gt;            FindLineIntersection( v_vector1,  v_vector2,&lt;br/&gt;                                  v_inter_x,  v_inter_y,&lt;br/&gt;                                  v_inter_x1, v_inter_y1,&lt;br/&gt;                                  v_inter_x2, v_inter_y2 );&lt;br/&gt;             -- When all three returned points are the same (and not c_Max) we have an actual intersection&lt;br/&gt;             If ( round(v_inter_x,v_round) &lt;&gt; c_Max ) Then&lt;br/&gt;                If ( round(v_inter_x,v_round) = round(v_inter_x1,v_round)&lt;br/&gt;                 and round(v_inter_y,v_round) = round(v_inter_y1,v_round)&lt;br/&gt;                 and round(v_inter_x,v_round) = round(v_inter_x2,v_round)&lt;br/&gt;                 and round(v_inter_y,v_round) = round(v_inter_y2,v_round)&lt;br/&gt;                  or p_geog_digits IS NOT NULL ) THEN&lt;br/&gt;-- DEBUG logger(&apos;Intersection point found or p_geog_digits is not null&apos;);&lt;br/&gt;-- DEBUG logger(case when v_inter_x is null then &apos;null inter x&apos; else &apos;valid inter x&apos; end);&lt;br/&gt;-- DEBUG logger(case when v_inter_y is null then &apos;null inter y&apos; else &apos;valid inter y&apos; end);&lt;br/&gt;                    If ( p_geog_digits IS NOT NULL) then&lt;br/&gt;-- DEBUG logger(&apos;returning projected&apos;);&lt;br/&gt;                       Return mdsys.sdo_cs.transform(Mdsys.Sdo_Geometry(p_pt_gtype,28355,Mdsys.Sdo_Point_Type(round(v_inter_x,v_round),round(v_inter_y,v_round),null),Null,Null),p_srid);&lt;br/&gt;                    Else&lt;br/&gt;-- DEBUG logger(&apos;returning unprojected&apos;);&lt;br/&gt;                       Return Mdsys.Sdo_Geometry(p_pt_gtype,P_Srid,Mdsys.Sdo_Point_Type(round(v_inter_x,v_round),round(v_inter_y,v_round),null),Null,Null);&lt;br/&gt;                    End If;&lt;br/&gt;-- DEBUG if (i between 5005 and 5015) then logger(&apos;NO&apos;); end if;&lt;br/&gt;                End If;&lt;br/&gt;             End If; -- round(v_inter_x,v_round) &lt;&gt; c_Max ) Then&lt;br/&gt;          End If; -- v_validate &lt;&gt; &apos;DISJOINT&apos;&lt;br/&gt;          Return NUll;&lt;br/&gt;      End FindPoint;&lt;br/&gt;&lt;br/&gt;  Begin&lt;br/&gt;      if ( p_geometry is null ) then&lt;br/&gt;         Return;&lt;br/&gt;      end if;&lt;br/&gt;&lt;br/&gt;      if ( p_tolerance is null ) then&lt;br/&gt;         Return;&lt;br/&gt;      end if;&lt;br/&gt;&lt;br/&gt;      If ( p_geometry.get_gtype() not in (2,3) ) Then&lt;br/&gt;         return;&lt;br/&gt;      end If;&lt;br/&gt;&lt;br/&gt;      v_dims := P_Geometry.Get_Dims();&lt;br/&gt;      V_Gtype_P := V_Dims * 1000 + 1;&lt;br/&gt;      V_Gtype_L := V_Dims * 1000 + 2;&lt;br/&gt;&lt;br/&gt;      v_validation := p_context;&lt;br/&gt;      If ( p_context is null ) Then&lt;br/&gt;          v_validation := mdsys.sdo_geom.validate_geometry_with_context(p_geometry,p_tolerance);&lt;br/&gt;      End If;&lt;br/&gt;-- DEBUG logger(&apos;getValidateErrors: &apos; || v_validation || &apos; tol &apos; || p_tolerance || &apos; Rings= &apos; || getNumRings(p_geometry));&lt;br/&gt;      If ( v_validation is null Or REGEXP_LIKE(v_validation, &apos;^[0-9 ]+$&apos;, &apos;i&apos;) or v_validation in (&apos;TRUE&apos;,&apos;NULL&apos;) ) then&lt;br/&gt;          Return;&lt;br/&gt;      End If;&lt;br/&gt;      v_error := substr(v_validation,1,5);&lt;br/&gt;&lt;br/&gt;      -- Handle 13356 Duplicate Vertices separately&lt;br/&gt;      --&lt;br/&gt;      If ( (v_error = &apos;13356&apos;) And (p_drilldown &gt; 0) ) Then&lt;br/&gt;          V_Gtype_P := V_Dims * 1000 + 1;&lt;br/&gt;          V_Gtype_L := V_Dims * 1000 + 2;&lt;br/&gt;          -- Process looking for vectors with zero length&lt;br/&gt;          Select codesys.T_Vector(v.id,V.Startcoord,V.Endcoord) as vector&lt;br/&gt;            Bulk Collect Into V_Vectors&lt;br/&gt;            From Table(codesys.SDO_ERROR.GetVector(P_Geometry)) V&lt;br/&gt;           Where Mdsys.Sdo_Geom.Sdo_Distance(&lt;br/&gt;                                  Mdsys.Sdo_Geometry(V_Gtype_P,P_Geometry.Sdo_Srid,Mdsys.Sdo_Point_Type(V.Startcoord.X,V.Startcoord.Y,V.Startcoord.Z),Null,Null),&lt;br/&gt;                                  Mdsys.Sdo_Geometry(V_Gtype_P,P_Geometry.Sdo_Srid,Mdsys.Sdo_Point_Type(V.Endcoord.X,V.Endcoord.Y,V.Endcoord.Z),Null,Null),&lt;br/&gt;                                  p_tolerance)  = 0.0;&lt;br/&gt;          If ( V_Vectors Is Null Or V_Vectors.Count = 0 ) Then&lt;br/&gt;              Return;&lt;br/&gt;          Else&lt;br/&gt;              If ( V_Dims = 2 Or ( V_Dims = 3 And ( Not Ismeasured(P_Geometry.Sdo_GType)) ) ) Then&lt;br/&gt;                  For I In V_Vectors.First..V_Vectors.Last Loop&lt;br/&gt;                      Pipe Row (codesys.T_Error(v_error,1,0,V_Vectors(i).id,Mdsys.Sdo_Geometry(V_Gtype_P,P_Geometry.Sdo_Srid,Mdsys.Sdo_Point_Type(v_vectors(i).Startcoord.X,v_vectors(i).Startcoord.Y,v_vectors(i).Startcoord.Z),Null,Null)));&lt;br/&gt;                  End Loop;&lt;br/&gt;              Elsif ( V_Dims = 3 And IsMeasured(P_Geometry.SDO_GTYPE) ) Then&lt;br/&gt;                  For I In V_Vectors.First..V_Vectors.Last Loop&lt;br/&gt;                      Pipe Row (codesys.T_Error(v_error,1,0,V_Vectors(i).id,Mdsys.Sdo_Geometry(V_Gtype_P,P_Geometry.Sdo_Srid,NULL,Mdsys.Sdo_Elem_Info_Array(1,1,1),Mdsys.Sdo_Ordinate_array(v_vectors(i).Startcoord.X,v_vectors(i).Startcoord.Y,v_vectors(i).Startcoord.w))));&lt;br/&gt;                  End Loop;&lt;br/&gt;              Else&lt;br/&gt;                  For I In V_Vectors.First..V_Vectors.Last Loop&lt;br/&gt;                      Pipe Row (codesys.T_Error(v_error,1,0,V_Vectors(i).id,Mdsys.Sdo_Geometry(V_Gtype_P,P_Geometry.Sdo_Srid,NULL,Mdsys.Sdo_Elem_Info_Array(1,1,1),Mdsys.Sdo_Ordinate_array(v_vectors(i).Startcoord.X,v_vectors(i).Startcoord.Y,v_vectors(i).Startcoord.Z,v_vectors(i).Startcoord.w))));&lt;br/&gt;                  End Loop;&lt;br/&gt;              End If;&lt;br/&gt;              return;&lt;br/&gt;          End If;&lt;br/&gt;      Else&lt;br/&gt;          v_row := 1;&lt;br/&gt;          v_rings := GetNumRings(v_element);&lt;br/&gt;          FOR rec IN (SELECT b.token_id,&lt;br/&gt;                             b.token                                            as token,&lt;br/&gt;                             TRIM(UPPER(SUBSTR(b.token,1, INSTR(b.token,&apos; &apos;)))) as firstToken,&lt;br/&gt;                             TRIM(UPPER(LAG(SUBSTR(b.token,1, INSTR(b.token,&apos; &apos;)),1)&lt;br/&gt;                                        OVER (ORDER BY b.token_id)))            as prevToken,&lt;br/&gt;                             TRIM(UPPER(LEAD(SUBSTR(b.token,1, INSTR(b.token,&apos; &apos;)),1)&lt;br/&gt;                                        OVER (ORDER BY b.token_id)))            as nextToken,&lt;br/&gt;                             TO_NUMBER(REGEXP_SUBSTR(b.token,&apos;[0-9]+&apos;,1,1))     as firstPosition,&lt;br/&gt;                             TO_NUMBER(REGEXP_SUBSTR(LAG(b.token,1) OVER (ORDER BY b.token_id),&apos;[0-9]+&apos;,1,1)) as prevFirstPosition,&lt;br/&gt;                             TRIM(REGEXP_REPLACE(&lt;br/&gt;                                REGEXP_SUBSTR(b.token,&lt;br/&gt;                                             &apos;[,]|&gt;[ ,a-z0-9]+&lt;&apos;,1,1),&lt;br/&gt;                                             &apos;(&gt; )|( &lt;)&apos;,&apos;&apos;))                   as SecondToken,&lt;br/&gt;                             TO_NUMBER(REGEXP_SUBSTR(b.token,&apos;[0-9]+&apos;,1,2))     as SecondPosition&lt;br/&gt;                        FROM (SELECT rownum as token_id,&lt;br/&gt;                                     a.COLUMN_VALUE as token&lt;br/&gt;                                FROM TABLE(codesys.SDO_ERROR.Tokenizer(v_validation,&apos;[]&apos;)) a&lt;br/&gt;                             ) b&lt;br/&gt;                       WHERE TRIM(b.token) is not null&lt;br/&gt;                         AND UPPER(SUBSTR(b.token,1, INSTR(b.token,&apos; &apos;))) NOT LIKE &apos;RINGS%&apos;  /* Not needed as in Edge &lt;&gt; in ring &lt;&gt; token that follows */&lt;br/&gt;                         AND NOT REGEXP_LIKE(b.token, &apos;^[0-9 ]+$&apos;, &apos;i&apos;)&lt;br/&gt;                       ORDER BY b.token_id ) LOOP&lt;br/&gt;              IF ( rec.firstToken = &apos;ELEMENT&apos; ) THEN&lt;br/&gt;                    -- Explode to get multipart indicated by firstPosition&lt;br/&gt;                    -- 13356 [Element &lt;1&gt;] [Coordinate &lt;10&gt;][Ring &lt;1&gt;]&lt;br/&gt;                    v_element_no := CASE WHEN rec.firstPosition = 0 THEN 1 ELSE rec.firstPosition END;&lt;br/&gt;                    v_element := mdsys.sdo_util.Extract(p_geometry,v_element_no,0);&lt;br/&gt;                    If ( rec.nextToken is not null or rec.nextToken = &apos;Coordinate&apos; ) THEN&lt;br/&gt;                        If ( v_element is not null ) Then&lt;br/&gt;                            v_vertices := mdsys.sdo_util.getVertices(v_element);&lt;br/&gt;                        Else&lt;br/&gt;                            v_vertices := mdsys.sdo_util.getVertices(p_geometry);&lt;br/&gt;                        End If;&lt;br/&gt;                        if ( v_all ) Then&lt;br/&gt;                            PIPE ROW ( codesys.T_Error(v_error,v_element_no,0,0,v_element ) );&lt;br/&gt;                        End If;&lt;br/&gt;                    End If;&lt;br/&gt;              ELSIF ( rec.firstToken = &apos;RING&apos; ) THEN&lt;br/&gt;                   v_ring_no := CASE WHEN rec.SecondToken = &apos;RING&apos; THEN rec.SecondPosition ELSE 1 END;&lt;br/&gt;                   v_ring := mdsys.sdo_util.Extract(p_geometry,v_element_no,v_ring_no);&lt;br/&gt;                   If ( v_ring is not null ) Then&lt;br/&gt;                      v_vertices := mdsys.sdo_util.getVertices(v_ring);&lt;br/&gt;                      if ( v_all and v_rings &gt; 0 ) Then -- If polygon has only one ring then it is the element&lt;br/&gt;                          PIPE ROW ( codesys.T_Error(v_error,v_element_no,v_ring_no,0,v_ring ) );&lt;br/&gt;                      End If;&lt;br/&gt;                      -- eg 13356 [Element &lt;1&gt;] [Coordinate &lt;10&gt;][Ring &lt;1&gt;] &lt;-- Polygons only&lt;br/&gt;                      If ( rec.prevToken = &apos;COORDINATE&apos; ) THEN&lt;br/&gt;                          v_vertex := CASE WHEN rec.prevFirstPosition = 0 THEN 1 ELSE rec.firstPosition END;&lt;br/&gt;                          v_z      := CASE WHEN v_vertices(v_vertex).z IS NULL THEN NULL ELSE v_vertices(v_vertex).z END;&lt;br/&gt;                          PIPE ROW ( codesys.T_Error(v_error,&lt;br/&gt;                                                     v_element_no,&lt;br/&gt;                                                     v_ring_no,&lt;br/&gt;                                                     v_vertex,&lt;br/&gt;                                                     MDSYS.SDO_GEOMETRY(v_dims * 1000 +1,&lt;br/&gt;                                                                        p_geometry.SDO_SRID,&lt;br/&gt;                                                                        mdsys.sdo_point_type(v_vertices(v_vertex).x,&lt;br/&gt;                                                                                             v_vertices(v_vertex).y,&lt;br/&gt;                                                                                             v_z),&lt;br/&gt;                                                                        NULL,&lt;br/&gt;                                                                        NULL)) );&lt;br/&gt;                      End If;&lt;br/&gt;                   End If;&lt;br/&gt;                NULL;&lt;br/&gt;              ELSIF ( rec.firstToken = &apos;EDGE&apos;    ) THEN&lt;br/&gt;                  -- Extract particular vector.&lt;br/&gt;                  -- Examples:&lt;br/&gt;                  -- 13348 [Element &lt;1&gt;] [Ring &lt;80&gt;]&lt;br/&gt;                  -- 13349 [Element &lt;1&gt;] [Ring &lt;1&gt;][Edge &lt;3&gt;][Edge &lt;1&gt;]&lt;br/&gt;                  -- 13351 [Element &lt;1&gt;] [Rings 1, 2][Edge &lt;12&gt; in ring &lt;1&gt;][Edge &lt;10&gt; in ring &lt;2&gt;]&lt;br/&gt;                  -- 13366 [Element &lt;1&gt;] [Rings 1, 11][Edge &lt;0&gt; in ring &lt;1&gt;][Edge &lt;0&gt; in ring &lt;11&gt;]&lt;br/&gt;                  IF ( rec.secondToken = &apos;in ring&apos; ) THEN&lt;br/&gt;                     v_ring_no := CASE WHEN rec.SecondPosition = 0 THEN 1 ELSE rec.SecondPosition END;&lt;br/&gt;                     v_ring := mdsys.sdo_util.Extract(p_geometry,v_element_no,v_ring_no); -- Extract ring.&lt;br/&gt;                     -- Check if Rectangle and convert to 5 vertex equivalent.&lt;br/&gt;                     -- TOBEDONE: Check circles&lt;br/&gt;                     --&lt;br/&gt;                     If ( v_ring is not null ) Then&lt;br/&gt;                        if ( hasRectangles(v_ring.sdo_elem_info) = 1 ) Then&lt;br/&gt;                           v_vertices := mdsys.sdo_util.getVertices(Rectangle2Polygon(v_ring));&lt;br/&gt;                        else&lt;br/&gt;                           v_vertices := mdsys.sdo_util.getVertices(v_ring);&lt;br/&gt;                        end If;&lt;br/&gt;                     End If;&lt;br/&gt;                  ELSE&lt;br/&gt;                     -- ring already extracted&lt;br/&gt;                     NULL;&lt;br/&gt;                  END IF;&lt;br/&gt;                  v_edge_no := CASE WHEN rec.firstPosition = 0 THEN 1 ELSE rec.firstPosition END;&lt;br/&gt;-- DEBUG logger(&apos;v_edge_no=&apos; || v_edge_no);&lt;br/&gt;                  -- Extract edge from vertices list&lt;br/&gt;                  -- Edge 1 is vertex 1 - 2; 2 is 2 - 3; 3 is 3-4&lt;br/&gt;                  --&lt;br/&gt;                  v_edge := MDSYS.SDO_GEOMETRY(v_dims * 1000 + 2,&lt;br/&gt;                                               p_geometry.SDO_SRID,&lt;br/&gt;                                               NULL,&lt;br/&gt;                                               mdsys.sdo_elem_info_array(1,2,1),&lt;br/&gt;                                               mdsys.sdo_ordinate_array(v_vertices(v_edge_no).x,&lt;br/&gt;                                                                        v_vertices(v_edge_no).y,&lt;br/&gt;                                                                        v_vertices(v_edge_no+1).x,&lt;br/&gt;                                                                        v_vertices(v_edge_no+1).y));&lt;br/&gt;                  PIPE ROW ( codesys.T_Error(v_error,&lt;br/&gt;                                             v_element_no,&lt;br/&gt;                                             v_ring_no,&lt;br/&gt;                                             v_edge_no,&lt;br/&gt;                                             v_edge ) );&lt;br/&gt;                  if ( rec.prevToken &lt;&gt; &apos;EDGE&apos; ) then&lt;br/&gt;                     v_prev_edge := v_edge;&lt;br/&gt;                  else&lt;br/&gt;-- DEBUG logger(&apos;Now try and compute intersection of edge &apos; || v_edge_no || &apos; - &apos; || rec.prevFirstPosition);&lt;br/&gt;                     v_point := FindPoint(codesys.T_Vector(rec.prevFirstPosition,&lt;br/&gt;                                                           codesys.t_vertex(v_prev_edge.sdo_ordinates(1), v_prev_edge.sdo_ordinates(2), null,null,rec.prevFirstPosition),&lt;br/&gt;                                                           codesys.t_vertex(v_prev_edge.sdo_ordinates(3), v_prev_edge.sdo_ordinates(4), null,null,rec.prevFirstPosition+1)),&lt;br/&gt;                                          codesys.T_Vector(v_edge_no,&lt;br/&gt;                                                           codesys.t_vertex(v_edge.sdo_ordinates(1),      v_edge.sdo_ordinates(2),      null,null,v_edge_no),&lt;br/&gt;                                                           codesys.t_vertex(v_edge.sdo_ordinates(3),      v_edge.sdo_ordinates(4),      null,null,v_edge_no+1)),&lt;br/&gt;                                          p_tolerance,&lt;br/&gt;                                          p_geog_digits,&lt;br/&gt;                                          v_gtype_p,&lt;br/&gt;                                          p_geometry.sdo_srid);&lt;br/&gt;                     if ( v_point is not null ) then&lt;br/&gt;                         PIPE ROW ( codesys.T_Error(v_error,&lt;br/&gt;                                                    v_element_no,&lt;br/&gt;                                                    v_ring_no,&lt;br/&gt;                                                    rec.prevFirstPosition+1,&lt;br/&gt;                                                    v_point) );&lt;br/&gt;                     End If;&lt;br/&gt;                  End If; -- rec.prevToken = &apos;EDGE&apos;&lt;br/&gt;              ELSIF ( rec.firstToken = &apos;COORDINATE&apos;    ) THEN&lt;br/&gt;                    -- eg 13356 [Element &lt;1&gt;] [Coordinate &lt;10&gt;][Ring &lt;1&gt;] &lt;-- Polygons only&lt;br/&gt;                    --    13356 [Element &lt;1&gt;] [Coordinate &lt;2&gt;]            &lt;-- Linestrings: Only ever reports first duplicate.&lt;br/&gt;                    -- Extract particular coordinate from arrays previously loaded&lt;br/&gt;                    --&lt;br/&gt;                    If ( v_element is not null ) Then&lt;br/&gt;                        If ( v_element.get_gtype() IN (2,6) ) Then -- LineString&lt;br/&gt;                            v_vertex := CASE WHEN rec.firstPosition = 0 THEN 1 ELSE rec.firstPosition END;&lt;br/&gt;                            v_z      := CASE WHEN v_vertices(v_vertex).z IS NULL THEN NULL ELSE v_vertices(v_vertex).z END;&lt;br/&gt;                            PIPE ROW ( codesys.T_Error(v_error,&lt;br/&gt;                                                       v_element_no,&lt;br/&gt;                                                       v_ring_no,&lt;br/&gt;                                                       v_vertex,&lt;br/&gt;                                                       MDSYS.SDO_GEOMETRY(v_dims * 1000 +1,&lt;br/&gt;                                                                          p_geometry.SDO_SRID,&lt;br/&gt;                                                                          mdsys.sdo_point_type(v_vertices(v_vertex).x,&lt;br/&gt;                                                                                               v_vertices(v_vertex).y,&lt;br/&gt;                                                                                               v_z),&lt;br/&gt;                                                                          NULL,NULL)) );&lt;br/&gt;                        ElsIf ( v_element.get_gtype() IN (3,7) ) Then -- Polygon&lt;br/&gt;                            -- Do nothing&lt;br/&gt;                            --&lt;br/&gt;                            null;&lt;br/&gt;                        End If;&lt;br/&gt;                    End If;&lt;br/&gt;                NULL;&lt;br/&gt;              END IF;&lt;br/&gt;          END LOOP;&lt;br/&gt;      End If;&lt;br/&gt;&lt;br/&gt;      -- If 13348 see if we can find additional problems in the ring being processed.&lt;br/&gt;      --&lt;br/&gt;      If ( (v_error = &apos;13349&apos;) And (p_drilldown &gt; 0) ) Then&lt;br/&gt;-- DEBUG logger(&apos;13349&apos;);&lt;br/&gt;          -- Process 1st/3rd vectors looking for intersection&lt;br/&gt;          SELECT codesys.T_Vector(v.id,V.Startcoord,V.Endcoord) as vector&lt;br/&gt;            BULK COLLECT INTO V_Vectors&lt;br/&gt;            FROM TABLE(codesys.SDO_ERROR.GetVector(P_Geometry)) V&lt;br/&gt;           ORDER BY v.id;&lt;br/&gt;&lt;br/&gt;          If ( V_Vectors Is Null Or V_Vectors.Count = 0 ) Then&lt;br/&gt;             Return;&lt;br/&gt;          Else&lt;br/&gt;             v_vector_max := v_vectors.COUNT;&lt;br/&gt;             For I In V_Vectors.First..(V_Vectors.Last-1) Loop&lt;br/&gt;                 if ( i = v_vector_max-1 ) then&lt;br/&gt;                     v_vector := v_vectors(1);&lt;br/&gt;                 Else&lt;br/&gt;                     v_vector := v_vectors(i+2);&lt;br/&gt;                 End If;&lt;br/&gt;-- DEBUG logger(&apos;vector(&apos;||i||&apos;) relate = &apos; || v_validate);&lt;br/&gt;                 v_geom := FindPoint(v_vectors(i), v_vector, p_tolerance, p_geog_digits, v_gtype_p, p_geometry.sdo_srid);&lt;br/&gt;                 if ( v_geom is not null and mdsys.sdo_geom.relate(v_geom,&apos;DETERMINE&apos;,v_point,p_tolerance) &lt;&gt; &apos;EQUAL&apos; ) then&lt;br/&gt;                     if ( v_all ) Then&lt;br/&gt;                         PIPE ROW ( codesys.T_Error(&apos;S&apos;||v_error,1,0,V_Vectors(i).id,v_vectors(i).AsSdoGeometry(p_geometry.sdo_srid) ) );&lt;br/&gt;                         PIPE ROW ( codesys.T_Error(&apos;S&apos;||v_error,1,0,V_Vector.id,    v_vector.AsSdoGeometry(p_geometry.sdo_srid) ) );&lt;br/&gt;                     End If;&lt;br/&gt;                     PIPE ROW (codesys.T_Error(&apos;S&apos;||v_error,1,0,i+1,v_point));&lt;br/&gt;                 End If;&lt;br/&gt;             End Loop;&lt;br/&gt;          End If;&lt;br/&gt;      End If;  -- 13348&lt;br/&gt;      return;&lt;br/&gt;  End getValidateErrors;&lt;br/&gt;&lt;br/&gt;  Function getErrors(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                     p_tolerance   in number      default 0.005,&lt;br/&gt;                     p_geog_digits in pls_integer default NULL,&lt;br/&gt;                     p_srid        in pls_integer default NULL,&lt;br/&gt;                     p_all         in pls_integer default 0,&lt;br/&gt;                     p_drilldown   in pls_integer default 1)&lt;br/&gt;     return codesys.SDO_ERROR.T_ErrorSet pipelined&lt;br/&gt;  AS&lt;br/&gt;      v_geom       mdsys.sdo_geometry;&lt;br/&gt;      v_vectors    codesys.SDO_ERROR.T_VectorSet;&lt;br/&gt;      v_vertices   MDSYS.VERTEX_SET_TYPE;&lt;br/&gt;      V_Validation Varchar2(20000);&lt;br/&gt;      v_errors     pls_integer := 0;&lt;br/&gt;&lt;br/&gt;      V_Dims       Pls_Integer;&lt;br/&gt;      v_vertex     PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;      V_Ring       Mdsys.Sdo_Geometry;&lt;br/&gt;      v_rings      PLS_INTEGER;&lt;br/&gt;      v_ring_no    PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;      v_element    mdsys.sdo_geometry;&lt;br/&gt;      v_elements   PLS_INTEGER;&lt;br/&gt;      v_element_no PLS_INTEGER;&lt;br/&gt;      v_edge_no    PLS_INTEGER;&lt;br/&gt;&lt;br/&gt;      v_z          NUMBER;&lt;br/&gt;  Begin&lt;br/&gt;      if ( p_geometry is null ) then&lt;br/&gt;         Return;&lt;br/&gt;      end if;&lt;br/&gt;&lt;br/&gt;      If ( p_geometry.get_gtype() not in (2,3,4,6,7) ) Then&lt;br/&gt;         return;&lt;br/&gt;      end If;&lt;br/&gt;&lt;br/&gt;      V_Dims := P_Geometry.Get_Dims();&lt;br/&gt;&lt;br/&gt;      -- Process x004, xx02, xx06, x003, x007 elements&lt;br/&gt;      -- For individual errors in their components&lt;br/&gt;      --&lt;br/&gt;      v_elements := MDSYS.SDO_UTIL.GETNUMELEM(p_geometry);&lt;br/&gt;      &lt;&lt;Process_All_Elements&gt;&gt;&lt;br/&gt;      FOR v_element_no IN 1..v_elements LOOP&lt;br/&gt;         v_element := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,0);&lt;br/&gt;         If ( v_element is not null ) Then&lt;br/&gt;             -- If polygon, need to extract inner rings&lt;br/&gt;             --&lt;br/&gt;             If ( v_element.get_gtype() = 3) Then&lt;br/&gt;                -- Process all rings in this single polygon have?&lt;br/&gt;                v_rings := GetNumRings(v_element);&lt;br/&gt;                &lt;&lt;All_Rings&gt;&gt;&lt;br/&gt;                FOR v_ring_no IN 1..v_rings LOOP&lt;br/&gt;                    v_ring := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,v_ring_no);&lt;br/&gt;                   &lt;&lt;all_ring_errors&gt;&gt;&lt;br/&gt;-- debug logger(&apos;Element &apos; || v_element_no || &apos; ring &apos; || v_ring_no);&lt;br/&gt;                   FOR rec IN (SELECT a.error,a.element,a.ring,a.id,a.GEOM&lt;br/&gt;                                 FROM TABLE(codesys.SDO_ERROR.getValidateErrors(v_ring,p_tolerance,p_geog_digits,p_srid,p_all,p_drilldown)) a)&lt;br/&gt;                   LOOP&lt;br/&gt;                       If ( rec.geom is not null ) then&lt;br/&gt;                          v_errors := v_errors + 1;&lt;br/&gt;                          PIPE ROW (codesys.T_Error(rec.error,v_element_no,v_ring_no,rec.id,rec.geom));&lt;br/&gt;                       End If;&lt;br/&gt;                   END LOOP all_ring_errors;&lt;br/&gt;                END LOOP All_Rings;&lt;br/&gt;             -- if line-string then get simply process it&lt;br/&gt;             --&lt;br/&gt;             ElsIf ( v_element.get_gtype() = 2) Then&lt;br/&gt;                 &lt;&lt;all_line_errors&gt;&gt;&lt;br/&gt;                 FOR rec IN (SELECT a.error,a.element,a.ring,a.id,a.GEOM&lt;br/&gt;                               FROM TABLE(codesys.SDO_ERROR.getValidateErrors(v_element,p_tolerance,p_geog_digits,p_srid,p_all,p_drilldown)) a)&lt;br/&gt;                 LOOP&lt;br/&gt;                     If ( rec.geom is not null ) then&lt;br/&gt;                        v_errors := v_errors + 1;&lt;br/&gt;                        PIPE ROW (codesys.T_Error(rec.error,v_element_no,0,rec.id,rec.geom));&lt;br/&gt;                     End If;&lt;br/&gt;                 END LOOP all_line_errors;&lt;br/&gt;             End If;&lt;br/&gt;         End If;&lt;br/&gt;     END LOOP Process_All_Elements;&lt;br/&gt;     -- Error may be due to element interaction and not isolatd to each element&lt;br/&gt;     --&lt;br/&gt;     if ( v_errors = 0 ) Then&lt;br/&gt;         &lt;&lt;all_geom_errors&gt;&gt;&lt;br/&gt;         FOR rec IN (SELECT a.error,a.element,a.ring,a.id,a.GEOM&lt;br/&gt;                       FROM TABLE(codesys.SDO_ERROR.getValidateErrors(p_geometry,p_tolerance,p_geog_digits,p_srid,p_all,p_drilldown)) a)&lt;br/&gt;         LOOP&lt;br/&gt;             If ( rec.geom is not null ) then&lt;br/&gt;                v_errors := v_errors + 1;&lt;br/&gt;                PIPE ROW (codesys.T_Error(rec.error,rec.element,rec.ring,rec.id,rec.geom));&lt;br/&gt;             End If;&lt;br/&gt;         END LOOP all_geom_errors;&lt;br/&gt;     End If;&lt;br/&gt;     return;&lt;br/&gt;  End getErrors;&lt;br/&gt;&lt;br/&gt;  /** ----------------------------------------------------------------------------------------&lt;br/&gt;    * @function   : getError&lt;br/&gt;    * @precis     : Function which returns a the nominated error number as a single geometry.&lt;br/&gt;    *               Edge errors returns as single edge, points as single point.&lt;br/&gt;  **/&lt;br/&gt;   Function getError(p_geometry     in mdsys.sdo_geometry,&lt;br/&gt;                     p_error_number in pls_integer,&lt;br/&gt;                     p_tolerance    in number      default 0.005,&lt;br/&gt;                     p_geog_digits  in pls_integer default NULL,&lt;br/&gt;                     p_srid         in pls_integer default NULL)&lt;br/&gt;     Return mdsys.sdo_geometry&lt;br/&gt;  Is&lt;br/&gt;     v_error pls_integer := 0; -- include error number&lt;br/&gt;     v_geom  mdsys.sdo_geometry;&lt;br/&gt;  Begin&lt;br/&gt;     IF ( p_geometry is null or p_error_number is null) THEN&lt;br/&gt;         RETURN null;&lt;br/&gt;     END IF;&lt;br/&gt;     FOR rec IN (SELECT a.element,a.ring,a.id,a.GEOM&lt;br/&gt;                   FROM TABLE(codesys.SDO_ERROR.getErrors(p_geometry,p_tolerance,p_geog_digits,p_srid,0)) a) LOOP&lt;br/&gt;         If ( rec.geom is not null ) then&lt;br/&gt;             v_error := v_error + 1;&lt;br/&gt;             if ( v_error = p_error_number ) Then&lt;br/&gt;                 return rec.geom;&lt;br/&gt;             End If;&lt;br/&gt;         End If;&lt;br/&gt;     END LOOP;&lt;br/&gt;     RETURN null;&lt;br/&gt;  End getError;&lt;br/&gt;&lt;br/&gt;  Function getErrorsAsMulti(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                            p_tolerance   in number      default 0.005,&lt;br/&gt;                            p_geog_digits in pls_integer default NULL,&lt;br/&gt;                            p_srid        in pls_integer default NULL,&lt;br/&gt;                            p_all         in pls_integer default 0)&lt;br/&gt;    Return mdsys.sdo_geometry&lt;br/&gt;  Is&lt;br/&gt;     v_geom mdsys.sdo_geometry;&lt;br/&gt;     v_dims pls_integer;&lt;br/&gt;  Begin&lt;br/&gt;     IF ( p_geometry is null ) THEN&lt;br/&gt;         RETURN null;&lt;br/&gt;     END IF;&lt;br/&gt;     v_dims := p_geometry.get_dims();&lt;br/&gt;     v_geom := mdsys.sdo_geometry(v_dims * 1000 + 4,&lt;br/&gt;                                  p_geometry.sdo_srid,&lt;br/&gt;                                  null,&lt;br/&gt;                                  mdsys.sdo_elem_info_array(),&lt;br/&gt;                                  mdsys.sdo_ordinate_array());&lt;br/&gt;     FOR rec IN (SELECT a.element,a.ring,a.id,a.GEOM&lt;br/&gt;                   FROM TABLE(codesys.SDO_ERROR.getErrors(p_geometry,p_tolerance,p_geog_digits,p_srid,p_all)) a) LOOP&lt;br/&gt;         If ( rec.geom is not null ) then&lt;br/&gt;              if ( rec.geom.sdo_point is not null ) then&lt;br/&gt;                  ADD_Element(v_geom.sdo_elem_info,&lt;br/&gt;                              new mdsys.sdo_elem_info_array(1,1,1),&lt;br/&gt;                              v_geom.sdo_ordinates);&lt;br/&gt;                  ADD_Coordinate(v_geom.sdo_ordinates,&lt;br/&gt;                                 v_dims,&lt;br/&gt;                                 rec.geom.sdo_point,&lt;br/&gt;                                 false,&lt;br/&gt;                                 true);&lt;br/&gt;              Else&lt;br/&gt;                  ADD_Element(v_geom.sdo_elem_info,&lt;br/&gt;                              rec.geom.sdo_elem_info,&lt;br/&gt;                              v_geom.sdo_ordinates);&lt;br/&gt;                  ADD_Ordinates(v_geom.sdo_ordinates,&lt;br/&gt;                                rec.geom.sdo_ordinates);&lt;br/&gt;              End if;&lt;br/&gt;         End If;&lt;br/&gt;     END LOOP;&lt;br/&gt;     RETURN v_geom;&lt;br/&gt;  End getErrorsAsMulti;&lt;br/&gt;&lt;br/&gt;  Function getErrorText(p_geometry  in mdsys.sdo_geometry,&lt;br/&gt;                        p_tolerance in number default 0.005)&lt;br/&gt;    return codesys.SDO_ERROR.T_Strings pipelined&lt;br/&gt;  Is&lt;br/&gt;     v_validation varchar2(4000);&lt;br/&gt;     v_geom       mdsys.sdo_geometry;&lt;br/&gt;  Begin&lt;br/&gt;      if ( p_geometry is null ) then&lt;br/&gt;         return;&lt;br/&gt;      end if;&lt;br/&gt;      v_validation := mdsys.sdo_geom.validate_geometry_with_context(p_geometry,p_tolerance);&lt;br/&gt;      if ( v_validation is null Or REGEXP_LIKE(v_validation, &apos;^[0-9 ]+$&apos;, &apos;i&apos;) or v_validation in (&apos;TRUE&apos;,&apos;NULL&apos;) ) then&lt;br/&gt;          return;&lt;br/&gt;      end if;&lt;br/&gt;      FOR error IN (SELECT *&lt;br/&gt;                      FROM (SELECT rownum as token_id,&lt;br/&gt;                                   a.COLUMN_VALUE as token&lt;br/&gt;                              FROM TABLE(codesys.SDO_ERROR.tokenizer(v_validation,&apos;[]&apos;)) a&lt;br/&gt;                           ) b&lt;br/&gt;                     WHERE TRIM(b.token) is not null&lt;br/&gt;                  ORDER BY b.token_id) LOOP&lt;br/&gt;          PIPE ROW ( error.token );&lt;br/&gt;      end loop;&lt;br/&gt;      return;&lt;br/&gt;  End getErrorText;&lt;br/&gt;&lt;br/&gt;  Function getErrorText(p_geometry     in mdsys.sdo_geometry,&lt;br/&gt;                        p_error_number in pls_integer,&lt;br/&gt;                        p_tolerance    in number default 0.05 )&lt;br/&gt;    return varchar2&lt;br/&gt;  Is&lt;br/&gt;     v_error      varchar2(400);&lt;br/&gt;     v_geom       mdsys.sdo_geometry;&lt;br/&gt;  Begin&lt;br/&gt;      if ( p_geometry is null ) then&lt;br/&gt;         return null;&lt;br/&gt;      end if;&lt;br/&gt;      BEGIN&lt;br/&gt;          SELECT f.token&lt;br/&gt;            INTO v_error&lt;br/&gt;            FROM (SELECT rownum as token_id,&lt;br/&gt;                         b.token&lt;br/&gt;                    FROM (SELECT rownum as token_id,&lt;br/&gt;                                 a.COLUMN_VALUE as token&lt;br/&gt;                            FROM TABLE(codesys.SDO_ERROR.getErrorText(p_geometry,p_tolerance)) a&lt;br/&gt;                         ) b&lt;br/&gt;                  ORDER BY b.token_id&lt;br/&gt;                  ) f&lt;br/&gt;           WHERE f.token_id = p_error_number;&lt;br/&gt;           EXCEPTION&lt;br/&gt;              WHEN NO_DATA_FOUND THEN&lt;br/&gt;                 RETURN NULL;&lt;br/&gt;      END;&lt;br/&gt;      RETURN v_error;&lt;br/&gt;  End getErrorText;&lt;br/&gt;&lt;br/&gt;  Function getMarks(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                    p_markType    in pls_integer default 0,&lt;br/&gt;                    p_degrees     in pls_integer default 0,&lt;br/&gt;                    p_tolerance   in number      default 0.005,&lt;br/&gt;                    p_geog_digits in pls_integer default null)&lt;br/&gt;    return codesys.SDO_ERROR.T_VertexMarkSet pipelined&lt;br/&gt;  Is&lt;br/&gt;     v_element         mdsys.sdo_geometry;&lt;br/&gt;     v_ring            mdsys.sdo_geometry;&lt;br/&gt;     v_element_no      pls_integer;&lt;br/&gt;     v_actual_etype    pls_integer;&lt;br/&gt;     v_ring_elem_count pls_integer := 0;&lt;br/&gt;     v_ring_no         pls_integer;&lt;br/&gt;     v_num_elements    pls_integer;&lt;br/&gt;     v_num_rings       pls_integer;&lt;br/&gt;     v_dims            pls_integer;&lt;br/&gt;     v_coordinates     mdsys.vertex_set_type;&lt;br/&gt;     v_prevVertex      mdsys.vertex_type;&lt;br/&gt;     v_currVertex      mdsys.vertex_type;&lt;br/&gt;     v_nextVertex      mdsys.vertex_type;&lt;br/&gt;     v_bearing         number := 0.0;&lt;br/&gt;     v_bearingNext     number := 0.0;&lt;br/&gt;     v_bearingPrev     number := 0.0;&lt;br/&gt;     v_delta           number := 0.0;&lt;br/&gt;     v_mark_text       varchar2(4000);&lt;br/&gt;     v_round           pls_integer := case when p_geog_digits is null&lt;br/&gt;                                           then case when p_tolerance is null&lt;br/&gt;                                                     then 3&lt;br/&gt;                                                     else round(log(10,(1/p_tolerance)/2))&lt;br/&gt;                                                 end&lt;br/&gt;                                           else p_geog_digits&lt;br/&gt;                                       end;&lt;br/&gt;&lt;br/&gt;      Function GetETypeAt(&lt;br/&gt;        p_geometry  in mdsys.sdo_geometry,&lt;br/&gt;        p_element   in pls_integer)&lt;br/&gt;        Return pls_integer&lt;br/&gt;      Is&lt;br/&gt;        v_num_elems number;&lt;br/&gt;      Begin&lt;br/&gt;        If ( p_geometry is not null ) Then&lt;br/&gt;          v_num_elems := ( ( p_geometry.sdo_elem_info.COUNT / 3 ) - 1 );&lt;br/&gt;          &lt;&lt;element_extraction&gt;&gt;&lt;br/&gt;          for v_i IN 0 .. v_num_elems LOOP&lt;br/&gt;             if ( (v_i+1) = p_element ) then&lt;br/&gt;                RETURN p_geometry.sdo_elem_info(v_i * 3 + 2);&lt;br/&gt;            End If;&lt;br/&gt;            end loop element_extraction;&lt;br/&gt;        End If;&lt;br/&gt;        Return NULL;&lt;br/&gt;      End GetETypeAt;&lt;br/&gt;&lt;br/&gt;  Begin&lt;br/&gt;     If ( p_geometry is null ) Then&lt;br/&gt;        return;&lt;br/&gt;     End If;&lt;br/&gt;     if (     p_markType &lt;&gt; codesys.SDO_ERROR.c_ID&lt;br/&gt;          AND p_markType &lt;&gt; codesys.SDO_ERROR.c_ID_COORD&lt;br/&gt;          AND p_markType &lt;&gt; codesys.SDO_ERROR.c_COORD&lt;br/&gt;          AND p_markType &lt;&gt; codesys.SDO_ERROR.c_ELEM )&lt;br/&gt;     Then&lt;br/&gt;        raise_application_error(c_i_invalid_mark,c_s_invalid_mark,true);&lt;br/&gt;     End If;&lt;br/&gt;     if (     p_degrees &lt;&gt; codesys.SDO_ERROR.c_DEGREES&lt;br/&gt;          AND p_degrees &lt;&gt; codesys.SDO_ERROR.c_RADIANS )&lt;br/&gt;     Then&lt;br/&gt;        raise_application_error(c_i_invalid_degrees,c_i_invalid_degrees,true);&lt;br/&gt;     End If;&lt;br/&gt;&lt;br/&gt;     v_dims   := p_geometry.get_dims();&lt;br/&gt;     If ( p_geometry.get_gtype()= 1 ) Then&lt;br/&gt;         v_mark_text := case p_markType&lt;br/&gt;                             when codesys.SDO_ERROR.c_ID&lt;br/&gt;                             then &apos;&lt;1&gt;&apos;&lt;br/&gt;                             when codesys.SDO_ERROR.c_ID_COORD&lt;br/&gt;                             then &apos;&lt;1&gt;&apos; ||&lt;br/&gt;                                  v_bracketStart ||&lt;br/&gt;                                    ROUND(p_geometry.sdo_point.X,v_round) || &apos;,&apos; || ROUND(p_geometry.sdo_point.Y,v_round) ||&lt;br/&gt;                                    CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(p_geometry.sdo_point.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                  v_bracketEnd&lt;br/&gt;                             when codesys.SDO_ERROR.c_COORD&lt;br/&gt;                             then v_bracketStart ||&lt;br/&gt;                                    ROUND(p_geometry.sdo_point.X,v_round) || &apos;,&apos; || ROUND(p_geometry.sdo_point.Y,v_round) ||&lt;br/&gt;                                    CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(p_geometry.sdo_point.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                  v_bracketEnd&lt;br/&gt;                             when codesys.SDO_ERROR.c_ELEM&lt;br/&gt;                             then &apos;&lt;1,0,1&gt;&apos;&lt;br/&gt;                             else &apos;&lt;1&gt;&apos;&lt;br/&gt;                         end;&lt;br/&gt;         PIPE ROW ( codesys.T_VertexMark( 1, 0, 1, p_geometry, 0, v_mark_text ) );&lt;br/&gt;         RETURN;&lt;br/&gt;     ElsIf ( p_geometry.get_gtype() = 5 ) Then&lt;br/&gt;        v_coordinates := mdsys.sdo_util.getVertices(p_geometry);&lt;br/&gt;        if ( v_coordinates is not null ) Then&lt;br/&gt;           For v_coord_no in 1..v_coordinates.COUNT Loop&lt;br/&gt;               v_currVertex := v_coordinates(v_coord_no);&lt;br/&gt;               v_mark_text := case p_markType&lt;br/&gt;                                   when codesys.SDO_ERROR.c_ID&lt;br/&gt;                                   then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                   when codesys.SDO_ERROR.c_ID_COORD&lt;br/&gt;                                   then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos; ||&lt;br/&gt;                                        v_bracketStart ||&lt;br/&gt;                                          ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                          CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                        v_bracketEnd&lt;br/&gt;                                   when codesys.SDO_ERROR.c_COORD&lt;br/&gt;                                   then v_bracketStart ||&lt;br/&gt;                                          ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                          CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                        v_bracketEnd&lt;br/&gt;                                   when codesys.SDO_ERROR.c_ELEM&lt;br/&gt;                                   then &apos;&lt;1,0,&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                   else &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                               end;&lt;br/&gt;               PIPE ROW ( codesys.T_VertexMark( 1, 0, v_coord_no,&lt;br/&gt;                                        mdsys.sdo_geometry(v_dims * 1000 + 1,p_geometry.sdo_srid,&lt;br/&gt;                                                           mdsys.sdo_point_type(v_coordinates(v_coord_no).X,v_coordinates(v_coord_no).Y,v_coordinates(v_coord_no).Z),NULL,NULL),&lt;br/&gt;                                        0,&lt;br/&gt;                                        v_mark_text ) );&lt;br/&gt;           End Loop;&lt;br/&gt;        End If;&lt;br/&gt;        RETURN;&lt;br/&gt;     End If;&lt;br/&gt;&lt;br/&gt;     -- Process Line/Multiline and Polygon/Multipolygon&lt;br/&gt;     --&lt;br/&gt;     v_num_elements := MDSYS.SDO_UTIL.GETNUMELEM(p_geometry);&lt;br/&gt;     &lt;&lt;Process_All_Elements&gt;&gt;&lt;br/&gt;     FOR v_element_no IN 1..v_num_elements LOOP&lt;br/&gt;         v_element := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,0);&lt;br/&gt;         If ( v_element is not null ) Then&lt;br/&gt;             -- Polygons&lt;br/&gt;             -- Need to check for inner rings&lt;br/&gt;             --&lt;br/&gt;             If ( v_element.get_gtype() = 3) Then&lt;br/&gt;                -- Process all rings in this single polygon have?&lt;br/&gt;                v_num_rings := GetNumRings(v_element);&lt;br/&gt;                &lt;&lt;All_Rings&gt;&gt;&lt;br/&gt;                FOR v_ring_no IN 1..v_num_rings LOOP&lt;br/&gt;                    v_ring            := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,v_ring_no);&lt;br/&gt;                    v_actual_etype    := GetEtypeAt(p_geometry,(v_ring_elem_count+1));&lt;br/&gt;                    v_ring_elem_count := v_ring_elem_count + v_ring.sdo_elem_info.COUNT / 3;&lt;br/&gt;                    -- Now generate marks&lt;br/&gt;                    If ( v_ring is not null ) Then&lt;br/&gt;                        If ( v_actual_etype = 2003 ) Then -- Extract reverses the linestring&lt;br/&gt;                           v_ring := mdsys.sdo_util.reverse_linestring(&lt;br/&gt;                                            mdsys.sdo_geometry(v_dims*1000+2,&lt;br/&gt;                                                               v_ring.sdo_srid,&lt;br/&gt;                                                               null,&lt;br/&gt;                                                               mdsys.sdo_elem_info_array(1,2,1),&lt;br/&gt;                                                               v_ring.sdo_ordinates));&lt;br/&gt;                        End If;&lt;br/&gt;                        v_coordinates := mdsys.sdo_util.getVertices(v_ring);&lt;br/&gt;                        FOR v_coord_no IN 1..v_coordinates.COUNT LOOP&lt;br/&gt;                            v_currVertex := v_coordinates(v_coord_no);&lt;br/&gt;                            If ( v_coord_no = 1 ) Then&lt;br/&gt;                                v_prevVertex  := v_coordinates(v_coordinates.COUNT-1);&lt;br/&gt;                                v_nextVertex  := v_coordinates(v_coord_no+1);&lt;br/&gt;                                v_bearingNext := ROUND(Degrees(bearing(v_currVertex,v_nextVertex)));&lt;br/&gt;                                v_bearingPrev := ROUND(Degrees(bearing(v_prevVertex,v_currVertex)));&lt;br/&gt;                            ElsIf ( v_coord_no = v_coordinates.count ) Then&lt;br/&gt;                                v_prevVertex  := v_coordinates(v_coord_no-1);&lt;br/&gt;                                v_nextVertex  := v_coordinates(2);&lt;br/&gt;                                v_bearingNext := ROUND(Degrees(bearing(v_currVertex,v_nextVertex)));&lt;br/&gt;                                v_bearingPrev := ROUND(Degrees(bearing(v_prevVertex,v_currVertex)));&lt;br/&gt;                            Else&lt;br/&gt;                                v_prevVertex  := v_coordinates(v_coord_no-1);&lt;br/&gt;                                v_nextVertex  := v_coordinates(v_coord_no+1);&lt;br/&gt;                                v_bearingNext := ROUND(Degrees(bearing(v_currVertex,v_nextVertex)));&lt;br/&gt;                                v_bearingPrev := ROUND(Degrees(bearing(v_prevVertex,v_currVertex)));&lt;br/&gt;                            End If;&lt;br/&gt;                            v_delta   := v_bearingNext - v_bearingPrev;&lt;br/&gt;                            -- DEBUG logger(v_actual_etype);&lt;br/&gt;                            -- Outer ring&lt;br/&gt;                            if ( v_actual_etype = 1003 ) then&lt;br/&gt;                               if ( SIGN(v_delta) = 1 ) then&lt;br/&gt;                                  v_bearing := v_bearingPrev + ABS(v_delta - 180.0)/2.0;&lt;br/&gt;                               else&lt;br/&gt;                                  v_bearing := (v_bearingNext + (180 + ABS(v_delta))/2.0);&lt;br/&gt;                               end If;&lt;br/&gt;                            -- inner ring&lt;br/&gt;                            ElsIf ( v_actual_etype = 2003 ) Then&lt;br/&gt;                               if ( SIGN(v_delta) = 1 ) then  -- Positive&lt;br/&gt;                                  if ( v_delta &lt;= 180 ) Then&lt;br/&gt;                                      v_bearing := v_bearingPrev - (180.0 - v_delta)/2.0;&lt;br/&gt;                                  else&lt;br/&gt;                                      v_bearing := v_bearingNext + (180.0 - v_delta)/2.0;&lt;br/&gt;                                  end If;&lt;br/&gt;                               Else -- negative angle&lt;br/&gt;                                  if ( abs(v_delta) &lt;= 180 ) Then&lt;br/&gt;                                      v_bearing := v_bearingNext + (v_delta/2.0);&lt;br/&gt;                                  else&lt;br/&gt;                                      v_bearing := v_bearingPrev + (180.0 + v_delta)/2.0;&lt;br/&gt;                                  end if;&lt;br/&gt;                               End If;&lt;br/&gt;                            End If;&lt;br/&gt;                            v_bearing := case when v_bearing &gt;= 360&lt;br/&gt;                                              then v_bearing - 360&lt;br/&gt;                                              else case when v_bearing &lt; 0&lt;br/&gt;                                                   then 360 + v_bearing&lt;br/&gt;                                                   else v_bearing&lt;br/&gt;                                               end&lt;br/&gt;                                          end;&lt;br/&gt;                            v_mark_text := case p_markType&lt;br/&gt;                                                when codesys.SDO_ERROR.c_ID       then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                                when codesys.SDO_ERROR.c_ID_COORD then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos; ||&lt;br/&gt;                                                                                       v_bracketStart ||&lt;br/&gt;                                                                                       ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                                                                       CASE WHEN v_dims = 3 THEN &apos;,&apos;    ||     ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                                                                                           v_bracketEnd&lt;br/&gt;                                                when codesys.SDO_ERROR.c_COORD    then v_bracketStart ||&lt;br/&gt;                                                                                       ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                                                                       CASE WHEN v_dims = 3 THEN &apos;,&apos; ||        ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                                                               v_bracketEnd&lt;br/&gt;                                                when codesys.SDO_ERROR.c_ELEM     then &apos;&lt;&apos; || v_element_no || &apos;,&apos; || v_ring_no || &apos;,&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                                else &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                            end;&lt;br/&gt;                            -- DEBUG: v_mark_text := v_bearingPrev || &apos; - &apos; || v_bearingNext || &apos; - &apos; || v_delta || &apos; - &apos; || v_bearing;&lt;br/&gt;                            PIPE ROW ( codesys.T_VertexMark( v_element_no, v_ring_no, v_coord_no,&lt;br/&gt;                                                     mdsys.sdo_geometry(v_dims * 1000 + 1,p_geometry.sdo_srid,mdsys.sdo_point_type(v_currVertex.X,v_currVertex.Y,v_currVertex.Z),NULL,NULL),&lt;br/&gt;                                                     NVL(case when p_degrees = codesys.SDO_ERROR.C_DEGREES THEN v_bearing ELSE Radians(v_bearing) END,0),&lt;br/&gt;                                                     v_mark_text ) );&lt;br/&gt;                        END LOOP;&lt;br/&gt;                    End If;&lt;br/&gt;                END LOOP All_Rings;&lt;br/&gt;&lt;br/&gt;             -- Linestrings&lt;br/&gt;             --&lt;br/&gt;             ElsIf ( v_element.get_gtype() = 2) Then&lt;br/&gt;                 v_coordinates := mdsys.sdo_util.getVertices(v_element);&lt;br/&gt;                 v_prevVertex  := v_coordinates(1);&lt;br/&gt;                 v_delta       := 0;&lt;br/&gt;                 FOR v_coord_no IN 1..v_coordinates.COUNT LOOP&lt;br/&gt;                     v_currVertex := v_coordinates(v_coord_no);&lt;br/&gt;                     If ( v_coord_no = v_coordinates.count ) Then&lt;br/&gt;                         v_nextVertex  := v_coordinates(v_coord_no-1);&lt;br/&gt;                         v_bearingNext := ROUND(Degrees(bearing(v_currVertex, v_nextVertex)));&lt;br/&gt;                     elsif ( v_coord_no = 1 ) then&lt;br/&gt;                         v_nextVertex  := v_coordinates(v_coord_no+1);&lt;br/&gt;                         v_bearingNext := ROUND(Degrees(bearing(v_currVertex, v_nextVertex))) + 180;&lt;br/&gt;                     else&lt;br/&gt;                         v_nextVertex  := v_coordinates(v_coord_no+1);&lt;br/&gt;                         v_bearingNext := ROUND(Degrees(bearing(v_nextVertex, v_currVertex)));&lt;br/&gt;                         if ( v_coord_no &lt;&gt; 1 ) Then&lt;br/&gt;                             v_bearingPrev := ROUND(Degrees(bearing(v_currVertex,v_prevVertex)));&lt;br/&gt;                             v_delta   := v_bearingPrev - v_bearingNext;&lt;br/&gt;                         End If;&lt;br/&gt;                     End If;&lt;br/&gt;                     v_bearing := v_bearingNext + (v_delta / 2.0);&lt;br/&gt;                     v_bearing := v_bearing-90.0;&lt;br/&gt;                     v_mark_text := case p_markType&lt;br/&gt;                                         when codesys.SDO_ERROR.c_ID&lt;br/&gt;                                         then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                         when codesys.SDO_ERROR.c_ID_COORD&lt;br/&gt;                                         then &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos; ||&lt;br/&gt;                                              v_bracketStart ||&lt;br/&gt;                                                ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                                CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                              v_bracketEnd&lt;br/&gt;                                         when codesys.SDO_ERROR.c_COORD&lt;br/&gt;                                         then v_bracketStart ||&lt;br/&gt;                                                ROUND(v_currVertex.X,v_round) || &apos;,&apos; || ROUND(v_currVertex.Y,v_round) ||&lt;br/&gt;                                                CASE WHEN v_dims = 3 THEN &apos;,&apos; || ROUND(v_currVertex.Z,v_round) ELSE &apos;&apos; END ||&lt;br/&gt;                                              v_bracketEnd&lt;br/&gt;                                         when codesys.SDO_ERROR.c_ELEM&lt;br/&gt;                                         then &apos;&lt;1,&apos; || v_element_no || &apos;,&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                         else &apos;&lt;&apos; || v_coord_no || &apos;&gt;&apos;&lt;br/&gt;                                     end;&lt;br/&gt;                     PIPE ROW ( codesys.T_VertexMark( v_element_no, 0, v_coord_no,&lt;br/&gt;                                              mdsys.sdo_geometry(v_dims * 1000 + 1,p_geometry.sdo_srid,mdsys.sdo_point_type(v_currVertex.X,v_currVertex.Y,v_currVertex.Z),NULL,NULL),&lt;br/&gt;                                              case when p_degrees = codesys.SDO_ERROR.C_DEGREES THEN v_bearing ELSE Radians(v_bearing) END,&lt;br/&gt;                                              v_mark_text ) );&lt;br/&gt;                END LOOP;&lt;br/&gt;             End If;&lt;br/&gt;         End If;&lt;br/&gt;     END LOOP;&lt;br/&gt;     RETURN;&lt;br/&gt;  End getMarks;&lt;br/&gt;&lt;br/&gt;  Function fix13348(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                    p_make_equal  in pls_integer default 1,&lt;br/&gt;                    p_tolerance   in number      default 0.005,&lt;br/&gt;                    p_geog_digits in pls_integer default null)&lt;br/&gt;    return mdsys.sdo_geometry deterministic&lt;br/&gt;  as&lt;br/&gt;    v_make_equal   boolean := case when p_make_equal is null then TRUE&lt;br/&gt;                                   when p_make_equal = 0 then FALSE&lt;br/&gt;                                   else TRUE&lt;br/&gt;                               end;&lt;br/&gt;    v_dims         pls_integer;&lt;br/&gt;    v_num_elements pls_integer;&lt;br/&gt;    v_element_no   pls_integer;&lt;br/&gt;    v_element      mdsys.sdo_geometry;&lt;br/&gt;    v_num_rings    pls_integer;&lt;br/&gt;    v_ring_no      pls_integer;&lt;br/&gt;    v_ring         mdsys.sdo_geometry;&lt;br/&gt;    v_round        pls_integer := case when p_geog_digits is null&lt;br/&gt;                                       then case when p_tolerance is null&lt;br/&gt;                                                 then 3&lt;br/&gt;                                                 else round(log(10,(1/p_tolerance)/2))&lt;br/&gt;                                             end&lt;br/&gt;                                       else p_geog_digits&lt;br/&gt;                                   end;&lt;br/&gt;    v_output_geom  mdsys.sdo_geometry;&lt;br/&gt;    NULL_GEOMETRY  EXCEPTION;&lt;br/&gt;    NOT_POLYGON    EXCEPTION;&lt;br/&gt;  Begin&lt;br/&gt;    If ( p_geometry is null ) Then&lt;br/&gt;      Raise NULL_GEOMETRY;&lt;br/&gt;    ElsIf ( p_geometry.get_gtype() not in (3,7) ) Then&lt;br/&gt;       RAISE NOT_POLYGON;&lt;br/&gt;    End If;&lt;br/&gt;&lt;br/&gt;    v_dims := p_geometry.get_dims();&lt;br/&gt;    v_num_elements := mdsys.sdo_util.GetNumElem(p_geometry);&lt;br/&gt;    &lt;&lt;for_all_elements&gt;&gt;&lt;br/&gt;    FOR v_element_no IN 1..v_num_elements LOOP&lt;br/&gt;       v_element := mdsys.sdo_util.Extract(p_geometry,v_element_no,0);   -- Extract element with all sub-elements&lt;br/&gt;       v_num_rings := GetNumRings(v_element);&lt;br/&gt;       &lt;&lt;for_all_rings&gt;&gt;&lt;br/&gt;       FOR v_i in 1..v_num_rings Loop&lt;br/&gt;           v_ring   := mdsys.sdo_util.Extract(v_element,v_i);   -- Extract ring from element&lt;br/&gt;           if NOT ( v_ring.sdo_ordinates is null or v_ring.sdo_ordinates.COUNT &lt; (3*v_dims) ) Then&lt;br/&gt;-- DEBUG logger(round(v_ring.sdo_ordinates(1),v_round_factor) || &apos; = &apos; || round(v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-v_dims),v_round_factor) || &apos; - &apos; || round(v_ring.sdo_ordinates(2),v_round_factor) || &apos; = &apos; || round(v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)),v_round_factor) );&lt;br/&gt;              if Not (  round(v_ring.sdo_ordinates(1),v_round) = round(v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-v_dims),v_round)&lt;br/&gt;                    and round(v_ring.sdo_ordinates(2),v_round) = round(v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)),v_round) ) Then&lt;br/&gt;                 if ( v_make_equal ) then&lt;br/&gt;-- DEBUG logger(&apos;making equal&apos;);&lt;br/&gt;-- DEBUG logger(&apos;before: &apos; || v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)) || &apos;,&apos; || v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-2)));&lt;br/&gt;                     v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)) := v_ring.sdo_ordinates(1);&lt;br/&gt;                     v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-2)) := v_ring.sdo_ordinates(2);&lt;br/&gt;-- DEBUG logger(&apos;after: &apos; ||  v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)) || &apos;,&apos; || v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-2)));&lt;br/&gt;                     if ( v_dims = 3 ) then&lt;br/&gt;                        v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT) := v_ring.sdo_ordinates(3);&lt;br/&gt;                     end if;&lt;br/&gt;                 Else&lt;br/&gt;                     -- Add start vertex to end&lt;br/&gt;                     v_ring.sdo_ordinates.EXTEND(v_dims);&lt;br/&gt;                     v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-1)) := v_ring.sdo_ordinates(1);&lt;br/&gt;                     v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT-(v_dims-2)) := v_ring.sdo_ordinates(2);&lt;br/&gt;                     if ( v_dims = 3 ) then&lt;br/&gt;                        v_ring.sdo_ordinates(v_ring.sdo_ordinates.COUNT) := v_ring.sdo_ordinates(3);&lt;br/&gt;                     end if;&lt;br/&gt;                     -- Need to fix sdo_elem_info&lt;br/&gt;                  End If;&lt;br/&gt;              End If;&lt;br/&gt;              if ( v_output_geom is null ) then&lt;br/&gt;                 v_output_geom := v_ring;&lt;br/&gt;              else&lt;br/&gt;                 v_output_geom := mdsys.sdo_util.append(v_output_geom,v_ring);&lt;br/&gt;              end if;&lt;br/&gt;           End If;&lt;br/&gt;       End Loop for_all_rings;&lt;br/&gt;    END LOOP for_all_elements;&lt;br/&gt;    return v_output_geom;&lt;br/&gt;    EXCEPTION&lt;br/&gt;      WHEN NULL_GEOMETRY Then&lt;br/&gt;        raise_application_error(c_i_null_geometry, c_s_null_geometry,TRUE);&lt;br/&gt;        RETURN p_geometry;&lt;br/&gt;      WHEN NOT_POLYGON THEN&lt;br/&gt;        raise_application_error(c_i_not_polygon,   c_s_not_polygon,true);&lt;br/&gt;       RETURN p_geometry;&lt;br/&gt;  end fix13348;&lt;br/&gt;&lt;br/&gt;  Function FindSpikes(p_geometry    in mdsys.sdo_geometry,&lt;br/&gt;                      p_tolerance   in number default 0.005)&lt;br/&gt;    return codesys.SDO_ERROR.T_VectorSet pipelined&lt;br/&gt;  as&lt;br/&gt;    v_vector       codesys.t_vector;&lt;br/&gt;    v_vectors      codesys.SDO_ERROR.T_VectorSet;&lt;br/&gt;    v_num_elements pls_integer;&lt;br/&gt;    v_element_no   pls_integer;&lt;br/&gt;    v_element      mdsys.sdo_geometry;&lt;br/&gt;    v_num_rings    pls_integer;&lt;br/&gt;    v_ring_no      pls_integer;&lt;br/&gt;    v_ring         mdsys.sdo_geometry;&lt;br/&gt;    v_relate       varchar2(100);&lt;br/&gt;    NULL_GEOMETRY  EXCEPTION;&lt;br/&gt;    NOT_LINE_POLY  EXCEPTION;&lt;br/&gt;  Begin&lt;br/&gt;     If ( p_geometry is null ) Then&lt;br/&gt;       Raise NULL_GEOMETRY;&lt;br/&gt;     ElsIf ( p_geometry.get_gtype() not in (2,5,3,7) ) Then&lt;br/&gt;        RAISE NOT_LINE_POLY;&lt;br/&gt;     End If;&lt;br/&gt;&lt;br/&gt;     -- Process Line/Multiline and Polygon/Multipolygon&lt;br/&gt;     --&lt;br/&gt;     v_num_elements := MDSYS.SDO_UTIL.GETNUMELEM(p_geometry);&lt;br/&gt;     &lt;&lt;Process_All_Elements&gt;&gt;&lt;br/&gt;     FOR v_element_no IN 1..v_num_elements LOOP&lt;br/&gt;         v_element := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,0);&lt;br/&gt;         If ( v_element is not null ) Then&lt;br/&gt;             -- Polygons&lt;br/&gt;             -- Need to check for inner rings&lt;br/&gt;             --&lt;br/&gt;             If ( v_element.get_gtype() = 3) Then&lt;br/&gt;                -- Process all rings in this single polygon have?&lt;br/&gt;                v_num_rings := GetNumRings(v_element);&lt;br/&gt;                &lt;&lt;All_Rings&gt;&gt;&lt;br/&gt;                FOR v_ring_no IN 1..v_num_rings LOOP&lt;br/&gt;                    v_ring            := MDSYS.SDO_UTIL.EXTRACT(p_geometry,v_element_no,v_ring_no);&lt;br/&gt;                    -- Now walk ring&apos;s vectors&lt;br/&gt;                    --&lt;br/&gt;                    If ( v_ring is not null ) Then&lt;br/&gt;                       -- Process 1st/2rd vectors looking for spike&lt;br/&gt;                      SELECT codesys.T_Vector(v.id,V.Startcoord,V.Endcoord) as vector&lt;br/&gt;                        BULK COLLECT INTO V_Vectors&lt;br/&gt;                        FROM TABLE(codesys.SDO_ERROR.GetVector(v_ring)) V&lt;br/&gt;                       ORDER BY v.id;&lt;br/&gt;                      If Not ( V_Vectors Is Null Or V_Vectors.Count = 0 ) Then&lt;br/&gt;                         For I In V_Vectors.First..V_Vectors.Last Loop&lt;br/&gt;                             if ( i = V_Vectors.Last ) then&lt;br/&gt;                                 v_vector := v_vectors(1);&lt;br/&gt;                             Else&lt;br/&gt;                                 v_vector := v_vectors(i+1);&lt;br/&gt;                             End If;&lt;br/&gt;                             -- Check if the interact in a way other than TOUCH&lt;br/&gt;                             --&lt;br/&gt;                             v_relate := mdsys.sdo_geom.relate(v_vectors(i).AsSdoGeometry(p_geometry.sdo_srid),&apos;DETERMINE&apos;,v_vector.asSdoGeometry(p_geometry.sdo_srid),p_tolerance);&lt;br/&gt;                             If ( v_relate &lt;&gt; &apos;TOUCH&apos; ) Then&lt;br/&gt;                                PIPE ROW ( codesys.T_Vector(v_vectors(i).id,v_vectors(i).startCoord,v_vectors(i).endCoord)  );&lt;br/&gt;                                PIPE ROW ( codesys.T_Vector(v_vector.id,v_vector.startCoord,v_vector.endCoord) );&lt;br/&gt;                             End If;&lt;br/&gt;                         End Loop;&lt;br/&gt;                      End If;&lt;br/&gt;                    End If;&lt;br/&gt;                END LOOP All_Rings;&lt;br/&gt;             -- Linestrings&lt;br/&gt;             --&lt;br/&gt;             ElsIf ( v_element.get_gtype() = 2) Then&lt;br/&gt;                   -- Process 1st/2rd vectors looking for spike&lt;br/&gt;                  SELECT codesys.T_Vector(v.id,V.Startcoord,V.Endcoord) as vector&lt;br/&gt;                    BULK COLLECT INTO V_Vectors&lt;br/&gt;                    FROM TABLE(codesys.SDO_ERROR.GetVector(v_element)) V&lt;br/&gt;                   ORDER BY v.id;&lt;br/&gt;                  If Not ( V_Vectors Is Null Or V_Vectors.Count = 0 ) Then&lt;br/&gt;                     For I In V_Vectors.First..(V_Vectors.Last-1) Loop&lt;br/&gt;                         v_vector := v_vectors(i+1);&lt;br/&gt;                         -- Check if the interact in a way other than TOUCH&lt;br/&gt;                         --&lt;br/&gt;                         v_relate := mdsys.sdo_geom.relate(v_vectors(i).AsSdoGeometry(p_geometry.sdo_srid),&apos;DETERMINE&apos;,v_vector.AsSdoGeometry(p_geometry.sdo_srid),p_tolerance);&lt;br/&gt;                         If ( v_relate &lt;&gt; &apos;TOUCH&apos; ) Then&lt;br/&gt;                             PIPE ROW ( codesys.T_Vector(v_vectors(i).id,v_vectors(i).startCoord,v_vectors(i).endCoord)  );&lt;br/&gt;                             PIPE ROW ( codesys.T_Vector(v_vector.id,v_vector.startCoord,v_vector.endCoord) );&lt;br/&gt;                         End If;&lt;br/&gt;                     End Loop;&lt;br/&gt;                  End If;&lt;br/&gt;             End If;&lt;br/&gt;         End If;&lt;br/&gt;     END LOOP;&lt;br/&gt;&lt;br/&gt;    return ;&lt;br/&gt;    EXCEPTION&lt;br/&gt;      WHEN NULL_GEOMETRY Then&lt;br/&gt;        raise_application_error(c_i_null_geometry, c_s_null_geometry,TRUE);&lt;br/&gt;        RETURN;&lt;br/&gt;      WHEN NOT_LINE_POLY THEN&lt;br/&gt;        raise_application_error(c_i_not_line_poly,   c_s_not_line_poly,true);&lt;br/&gt;       RETURN ;&lt;br/&gt;  end FindSpikes;&lt;br/&gt;&lt;br/&gt;end SDO_ERROR;</source>
</body>
</PackageOracle>