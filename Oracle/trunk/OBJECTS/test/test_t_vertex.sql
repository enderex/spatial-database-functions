CREATE OR REPLACE PACKAGE test_t_vertex IS

   /* generated by utPLSQL for SQL Developer on 2019-08-18 18:11:02 */

   --%suite(test_t_vertex)
   --%suitepath(alltests)
   
   --%test
   PROCEDURE t_vertex;

   --%test
   PROCEDURE st_x;

   --%test
   PROCEDURE st_y;

   --%test
   PROCEDURE st_z;

   --%test
   PROCEDURE st_w;

   --%test
   PROCEDURE st_m;

   --%test
   PROCEDURE st_id;

   --%test
   PROCEDURE st_srid;

   --%test
   PROCEDURE st_sdo_gtype;

   --%test
   PROCEDURE st_isdeleted;

   --%test
   PROCEDURE st_ismeasured;

   --%test
   PROCEDURE st_self;

   --%test
   PROCEDURE st_setcoordinate;

   --%test
   PROCEDURE st_setdeleted;

   --%test
   PROCEDURE st_isempty;

   --%test
   PROCEDURE st_dims;

   --%test
   PROCEDURE st_hasz;

   --%test
   PROCEDURE st_hasm;

   --%test
   PROCEDURE st_lrs_dim;

   --%test
   PROCEDURE st_lrs_set_measure;

   --%test
   PROCEDURE st_to2d;

   --%test
   PROCEDURE st_to3d;

   --%test
   PROCEDURE st_vertextype;

   --%test
   PROCEDURE st_sdopointtype;

   --%test
   PROCEDURE st_bearing;

   --%test
   PROCEDURE st_distance;

   --%test
   PROCEDURE st_frombearinganddistance;

   --%test
   PROCEDURE st_add;

   --%test
   PROCEDURE st_normal;

   --%test
   PROCEDURE st_subtract;

   --%test
   PROCEDURE st_scale;

   --%test
   PROCEDURE st_subtendedangle;

   --%test
   PROCEDURE st_withintolerance;

   --%test
   PROCEDURE st_round;

   --%test
   PROCEDURE st_sdogeometry;

   --%test
   PROCEDURE st_astext;

   --%test
   PROCEDURE st_asewkt;

   --%test
   PROCEDURE st_ascoordstring;

   --%test
   PROCEDURE st_equals;

   --%test
   PROCEDURE orderby;

END test_t_vertex;
/

CREATE OR REPLACE PACKAGE BODY test_t_vertex IS

   /* generated by utPLSQL for SQL Developer on 2019-08-18 18:11:02 */

   --
   -- test t_vertex case 1: ...
   --
   PROCEDURE t_vertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.t_vertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END t_vertex;

   --
   -- test st_x case 1: ...
   --
   PROCEDURE st_x IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_x;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_x;

   --
   -- test st_y case 1: ...
   --
   PROCEDURE st_y IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_y;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_y;

   --
   -- test st_z case 1: ...
   --
   PROCEDURE st_z IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_z;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_z;

   --
   -- test st_w case 1: ...
   --
   PROCEDURE st_w IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_w;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_w;

   --
   -- test st_m case 1: ...
   --
   PROCEDURE st_m IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_m;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_m;

   --
   -- test st_id case 1: ...
   --
   PROCEDURE st_id IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_id;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_id;

   --
   -- test st_srid case 1: ...
   --
   PROCEDURE st_srid IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_srid;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_srid;

   --
   -- test st_sdo_gtype case 1: ...
   --
   PROCEDURE st_sdo_gtype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_sdo_gtype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdo_gtype;

   --
   -- test st_isdeleted case 1: ...
   --
   PROCEDURE st_isdeleted IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_isdeleted;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isdeleted;

   --
   -- test st_ismeasured case 1: ...
   --
   PROCEDURE st_ismeasured IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_ismeasured;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_ismeasured;

   --
   -- test st_self case 1: ...
   --
   PROCEDURE st_self IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_self;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_self;

   --
   -- test st_setcoordinate case 1: ...
   --
   PROCEDURE st_setcoordinate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_setcoordinate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setcoordinate;

   --
   -- test st_setdeleted case 1: ...
   --
   PROCEDURE st_setdeleted IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_setdeleted;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setdeleted;

   --
   -- test st_isempty case 1: ...
   --
   PROCEDURE st_isempty IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_isempty;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isempty;

   --
   -- test st_dims case 1: ...
   --
   PROCEDURE st_dims IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_dims;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_dims;

   --
   -- test st_hasz case 1: ...
   --
   PROCEDURE st_hasz IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_hasz;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasz;

   --
   -- test st_hasm case 1: ...
   --
   PROCEDURE st_hasm IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_hasm;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasm;

   --
   -- test st_lrs_dim case 1: ...
   --
   PROCEDURE st_lrs_dim IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_lrs_dim;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_dim;

   --
   -- test st_lrs_set_measure case 1: ...
   --
   PROCEDURE st_lrs_set_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_lrs_set_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_set_measure;

   --
   -- test st_to2d case 1: ...
   --
   PROCEDURE st_to2d IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_to2d;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_to2d;

   --
   -- test st_to3d case 1: ...
   --
   PROCEDURE st_to3d IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_to3d;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_to3d;

   --
   -- test st_vertextype case 1: ...
   --
   PROCEDURE st_vertextype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_vertextype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_vertextype;

   --
   -- test st_sdopointtype case 1: ...
   --
   PROCEDURE st_sdopointtype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_sdopointtype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdopointtype;

   --
   -- test st_bearing case 1: ...
   --
   PROCEDURE st_bearing IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_bearing;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_bearing;

   --
   -- test st_distance case 1: ...
   --
   PROCEDURE st_distance IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_distance;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_distance;

   --
   -- test st_frombearinganddistance case 1: ...
   --
   PROCEDURE st_frombearinganddistance IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_frombearinganddistance;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_frombearinganddistance;

   --
   -- test st_add case 1: ...
   --
   PROCEDURE st_add IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_add;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_add;

   --
   -- test st_normal case 1: ...
   --
   PROCEDURE st_normal IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_normal;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_normal;

   --
   -- test st_subtract case 1: ...
   --
   PROCEDURE st_subtract IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_subtract;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_subtract;

   --
   -- test st_scale case 1: ...
   --
   PROCEDURE st_scale IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_scale;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_scale;

   --
   -- test st_subtendedangle case 1: ...
   --
   PROCEDURE st_subtendedangle IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_subtendedangle;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_subtendedangle;

   --
   -- test st_withintolerance case 1: ...
   --
   PROCEDURE st_withintolerance IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_withintolerance;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_withintolerance;

   --
   -- test st_round case 1: ...
   --
   PROCEDURE st_round IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_round;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_round;

   --
   -- test st_sdogeometry case 1: ...
   --
   PROCEDURE st_sdogeometry IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_sdogeometry;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdogeometry;

   --
   -- test st_astext case 1: ...
   --
   PROCEDURE st_astext IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_astext;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_astext;

   --
   -- test st_asewkt case 1: ...
   --
   PROCEDURE st_asewkt IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_asewkt;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_asewkt;

   --
   -- test st_ascoordstring case 1: ...
   --
   PROCEDURE st_ascoordstring IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_ascoordstring;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_ascoordstring;

   --
   -- test st_equals case 1: ...
   --
   PROCEDURE st_equals IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.st_equals;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_equals;

   --
   -- test orderby case 1: ...
   --
   PROCEDURE orderby IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 0;
   BEGIN
      -- populate actual
      -- t_vertex.orderby;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END orderby;

END test_t_vertex;
/
show errors

set serveroutput on size unlimited
set long 800
set linesize 800
begin ut.run('test_t_vertex'); end;

