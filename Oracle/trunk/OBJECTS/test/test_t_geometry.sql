CREATE OR REPLACE PACKAGE test_t_geometry IS

   /* generated by utPLSQL for SQL Developer on 2019-08-18 18:12:15 */

   --%suite(test_t_geometry)
   --%suitepath(alltests)
   
   --%test
   PROCEDURE t_geometry;

   --%test
   PROCEDURE st_release;

   --%test
   PROCEDURE st_asgeometryrow;

   --%test
   PROCEDURE st_setsdogtype;

   --%test
   PROCEDURE st_setsrid;

   --%test
   PROCEDURE st_setprojection;

   --%test
   PROCEDURE st_setprecision;

   --%test
   PROCEDURE st_settolerance;

   --%test
   PROCEDURE st_setpoint;

   --%test
   PROCEDURE st_gtype;

   --%test
   PROCEDURE st_dims;

   --%test
   PROCEDURE st_sdo_gtype;

   --%test
   PROCEDURE st_srid;

   --%test
   PROCEDURE st_aswkb;

   --%test
   PROCEDURE st_aswkt;

   --%test
   PROCEDURE st_asewkt;

   --%test
   PROCEDURE st_astext;

   --%test
   PROCEDURE st_fromtext;

   --%test
   PROCEDURE st_fromewkt;

   --%test
   PROCEDURE st_asttext;

   --%test
   PROCEDURE st_coorddimension;

   --%test
   PROCEDURE st_dimension;

   --%test
   PROCEDURE st_hasdimension;

   --%test
   PROCEDURE st_hasz;

   --%test
   PROCEDURE st_hasm;

   --%test
   PROCEDURE st_isvalid;

   --%test
   PROCEDURE st_validate;

   --%test
   PROCEDURE st_isvalidcontext;

   --%test
   PROCEDURE st_isempty;

   --%test
   PROCEDURE st_isclosed;

   --%test
   PROCEDURE st_issimple;

   --%test
   PROCEDURE st_geometrytype;

   --%test
   PROCEDURE st_numgeometries;

   --%test
   PROCEDURE st_numvertices;

   --%test
   PROCEDURE st_numpoints;

   --%test
   PROCEDURE st_numelements;

   --%test
   PROCEDURE st_numsubelements;

   --%test
   PROCEDURE st_elementtypeat;

   --%test
   PROCEDURE st_numinteriorring;

   --%test
   PROCEDURE st_numsegments;

   --%test
   PROCEDURE st_isorientedpoint;

   --%test
   PROCEDURE st_hascirculararcs;

   --%test
   PROCEDURE st_incirculararc;

   --%test
   PROCEDURE st_numrectangles;

   --%test
   PROCEDURE st_hasrectangles;

   --%test
   PROCEDURE st_round;

   --%test
   PROCEDURE st_numrings;

   --%test
   PROCEDURE st_eleminfo;

   --%test
   PROCEDURE st_numelementinfo;

   --%test
   PROCEDURE st_dump;

   --%test
   PROCEDURE st_exteriorring;

   --%test
   PROCEDURE st_boundary;

   --%test
   PROCEDURE st_length;

   --%test
   PROCEDURE st_area;

   --%test
   PROCEDURE st_distance;

   --%test
   PROCEDURE st_relate;

   --%test
   PROCEDURE st_swapordinates;

   --%test
   PROCEDURE st_filterrings;

   --%test
   PROCEDURE st_removeinnerrings;

   --%test
   PROCEDURE st_extract;

   --%test
   PROCEDURE st_extractrings;

   --%test
   PROCEDURE st_vertices;

   --%test
   PROCEDURE st_segmentize;

   --%test
   PROCEDURE st_flip_segments;

   --%test
   PROCEDURE st_rectangle2polygon;

   --%test
   PROCEDURE st_polygon2rectangle;

   --%test
   PROCEDURE st_diminfo2rectangle;

   --%test
   PROCEDURE st_geometry2diminfo;

   --%test
   PROCEDURE st_mbr;

   --%test
   PROCEDURE st_tomultipoint;

   --%test
   PROCEDURE st_envelope;

   --%test
   PROCEDURE st_polygon2line;

   --%test
   PROCEDURE st_multi;

   --%test
   PROCEDURE st_append;

   --%test
   PROCEDURE st_rotate;

   --%test
   PROCEDURE st_scale;

   --%test
   PROCEDURE st_translate;

   --%test
   PROCEDURE st_reflect;

   --%test
   PROCEDURE st_rottransscale;

   --%test
   PROCEDURE st_affine;

   --%test
   PROCEDURE st_fixordinates;

   --%test
   PROCEDURE st_vertexn;

   --%test
   PROCEDURE st_startvertex;

   --%test
   PROCEDURE st_endvertex;

   --%test
   PROCEDURE st_pointn;

   --%test
   PROCEDURE st_startpoint;

   --%test
   PROCEDURE st_endpoint;

   --%test
   PROCEDURE st_segmentn;

   --%test
   PROCEDURE st_startsegment;

   --%test
   PROCEDURE st_endsegment;

   --%test
   PROCEDURE st_insertvertex;

   --%test
   PROCEDURE st_updatevertex;

   --%test
   PROCEDURE st_deletevertex;

   --%test
   PROCEDURE st_removeduplicatevertices;

   --%test
   PROCEDURE st_extend;

   --%test
   PROCEDURE st_reduce;

   --%test
   PROCEDURE st_cogo2line;

   --%test
   PROCEDURE st_line2cogo;

   --%test
   PROCEDURE st_cogo2polygon;

   --%test
   PROCEDURE st_travellingsalesman;

   --%test
   PROCEDURE st_compress;

   --%test
   PROCEDURE st_decompress;

   --%test
   PROCEDURE st_sdopoint2ord;

   --%test
   PROCEDURE st_ord2sdopoint;

   --%test
   PROCEDURE st_to2d;

   --%test
   PROCEDURE st_to3d;

   --%test
   PROCEDURE st_fixz;

   --%test
   PROCEDURE st_tile;

   --%test
   PROCEDURE st_smoothtile;

   --%test
   PROCEDURE st_removecollinearpoints;

   --%test
   PROCEDURE st_densify;

   --%test
   PROCEDURE st_lineshift;

   --%test
   PROCEDURE st_parallel;

   --%test
   PROCEDURE st_getoffsetcurve;

   --%test
   PROCEDURE st_rectangle;

   --%test
   PROCEDURE st_centroid_l;

   --%test
   PROCEDURE st_centroid_p;

   --%test
   PROCEDURE st_centroid_a;

   --%test
   PROCEDURE st_multi_centroid;

   --%test
   PROCEDURE st_split_segments;

   --%test
   PROCEDURE st_split;

   --%test
   PROCEDURE st_snap;

   --%test
   PROCEDURE st_snapn;

   --%test
   PROCEDURE st_add_segment;

   --%test
   PROCEDURE st_reverse_linestring;

   --%test
   PROCEDURE st_reverse_geometry;

   --%test
   PROCEDURE st_which_side;

   --%test
   PROCEDURE st_concat_line;

   --%test
   PROCEDURE st_intersection;

   --%test
   PROCEDURE st_difference;

   --%test
   PROCEDURE st_buffer;

   --%test
   PROCEDURE st_squarebuffer;

   --%test
   PROCEDURE st_onesidedbuffer;

   --%test
   PROCEDURE st_sdo_point_equal;

   --%test
   PROCEDURE st_elem_info_equal;

   --%test
   PROCEDURE st_ordinates_equal;

   --%test
   PROCEDURE st_equals;

   --%test
   PROCEDURE orderby;

END test_t_geometry;
/
show errors

CREATE OR REPLACE PACKAGE BODY test_t_geometry IS

   /* generated by utPLSQL for SQL Developer on 2019-08-18 18:12:15 */

   --
   -- test t_geometry case 1: ...
   --
   PROCEDURE t_geometry IS
      l_actual   varchar2(1000);
      l_expected varchar2(1000);
      v_segment  spdba.t_segment;
      v_tgeom    spdba.T_GEOMETRY;
   BEGIN
      v_segment  := spdba.t_segment(sdo_geometry(2002,null,null,sdo_elem_info_array(1,2,1),sdo_ordinate_array(0,0,1,1)));
      v_tgeom    := spdba.T_GEOMETRY(v_segment);
      l_actual   := v_tgeom.ST_AsEWKT();
      l_expected := 'LINESTRING (0 0,1 1)';
      ut.expect(l_actual).to_equal(l_expected);
   END t_geometry;

   --
   -- test st_release case 1: ...
   --
   PROCEDURE st_release 
   IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_release;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_release;

   --
   -- test st_asgeometryrow case 1: ...
   --
   PROCEDURE st_asgeometryrow IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_asgeometryrow;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_asgeometryrow;

   --
   -- test st_setsdogtype case 1: ...
   --
   PROCEDURE st_setsdogtype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_setsdogtype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setsdogtype;

   --
   -- test st_setsrid case 1: ...
   --
   PROCEDURE st_setsrid IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_setsrid;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setsrid;

   --
   -- test st_setprojection case 1: ...
   --
   PROCEDURE st_setprojection IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_setprojection;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setprojection;

   --
   -- test st_setprecision case 1: ...
   --
   PROCEDURE st_setprecision IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_setprecision;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setprecision;

   --
   -- test st_settolerance case 1: ...
   --
   PROCEDURE st_settolerance IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_settolerance;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_settolerance;

   --
   -- test st_setpoint case 1: ...
   --
   PROCEDURE st_setpoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_setpoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_setpoint;

   --
   -- test st_gtype case 1: ...
   --
   PROCEDURE st_gtype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_gtype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_gtype;

   --
   -- test st_dims case 1: ...
   --
   PROCEDURE st_dims IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_dims;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_dims;

   --
   -- test st_sdo_gtype case 1: ...
   --
   PROCEDURE st_sdo_gtype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_sdo_gtype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdo_gtype;

   --
   -- test st_srid case 1: ...
   --
   PROCEDURE st_srid IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_srid;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_srid;

   --
   -- test st_aswkb case 1: ...
   --
   PROCEDURE st_aswkb IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_aswkb;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_aswkb;

   --
   -- test st_aswkt case 1: ...
   --
   PROCEDURE st_aswkt IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_aswkt;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_aswkt;

   --
   -- test st_asewkt case 1: ...
   --
   PROCEDURE st_asewkt IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_asewkt;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_asewkt;

   --
   -- test st_astext case 1: ...
   --
   PROCEDURE st_astext IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_astext;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_astext;

   --
   -- test st_fromtext case 1: ...
   --
   PROCEDURE st_fromtext IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_fromtext;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_fromtext;

   --
   -- test st_fromewkt case 1: ...
   --
   PROCEDURE st_fromewkt IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_fromewkt;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_fromewkt;

   --
   -- test st_asttext case 1: ...
   --
   PROCEDURE st_asttext IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_asttext;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_asttext;

   --
   -- test st_coorddimension case 1: ...
   --
   PROCEDURE st_coorddimension IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_coorddimension;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_coorddimension;

   --
   -- test st_dimension case 1: ...
   --
   PROCEDURE st_dimension IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_dimension;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_dimension;

   --
   -- test st_hasdimension case 1: ...
   --
   PROCEDURE st_hasdimension IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_hasdimension;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasdimension;

   --
   -- test st_hasz case 1: ...
   --
   PROCEDURE st_hasz IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_hasz;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasz;

   --
   -- test st_hasm case 1: ...
   --
   PROCEDURE st_hasm IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_hasm;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasm;

   --
   -- test st_isvalid case 1: ...
   --
   PROCEDURE st_isvalid IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_isvalid;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isvalid;

   --
   -- test st_validate case 1: ...
   --
   PROCEDURE st_validate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_validate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_validate;

   --
   -- test st_isvalidcontext case 1: ...
   --
   PROCEDURE st_isvalidcontext IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_isvalidcontext;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isvalidcontext;

   --
   -- test st_isempty case 1: ...
   --
   PROCEDURE st_isempty IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_isempty;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isempty;

   --
   -- test st_isclosed case 1: ...
   --
   PROCEDURE st_isclosed IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_isclosed;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isclosed;

   --
   -- test st_issimple case 1: ...
   --
   PROCEDURE st_issimple IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_issimple;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_issimple;

   --
   -- test st_geometrytype case 1: ...
   --
   PROCEDURE st_geometrytype IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_geometrytype;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_geometrytype;

   --
   -- test st_numgeometries case 1: ...
   --
   PROCEDURE st_numgeometries IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numgeometries;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numgeometries;

   --
   -- test st_numvertices case 1: ...
   --
   PROCEDURE st_numvertices IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numvertices;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numvertices;

   --
   -- test st_numpoints case 1: ...
   --
   PROCEDURE st_numpoints IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numpoints;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numpoints;

   --
   -- test st_numelements case 1: ...
   --
   PROCEDURE st_numelements IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numelements;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numelements;

   --
   -- test st_numsubelements case 1: ...
   --
   PROCEDURE st_numsubelements IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numsubelements;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numsubelements;

   --
   -- test st_elementtypeat case 1: ...
   --
   PROCEDURE st_elementtypeat IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_elementtypeat;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_elementtypeat;

   --
   -- test st_numinteriorring case 1: ...
   --
   PROCEDURE st_numinteriorring IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numinteriorring;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numinteriorring;

   --
   -- test st_numsegments case 1: ...
   --
   PROCEDURE st_numsegments IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numsegments;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numsegments;

   --
   -- test st_isorientedpoint case 1: ...
   --
   PROCEDURE st_isorientedpoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_isorientedpoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_isorientedpoint;

   --
   -- test st_hascirculararcs case 1: ...
   --
   PROCEDURE st_hascirculararcs IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_hascirculararcs;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hascirculararcs;

   --
   -- test st_incirculararc case 1: ...
   --
   PROCEDURE st_incirculararc IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_incirculararc;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_incirculararc;

   --
   -- test st_numrectangles case 1: ...
   --
   PROCEDURE st_numrectangles IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numrectangles;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numrectangles;

   --
   -- test st_hasrectangles case 1: ...
   --
   PROCEDURE st_hasrectangles IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_hasrectangles;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_hasrectangles;

   --
   -- test st_round case 1: ...
   --
   PROCEDURE st_round IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_round;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_round;

   --
   -- test st_numrings case 1: ...
   --
   PROCEDURE st_numrings IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numrings;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numrings;

   --
   -- test st_eleminfo case 1: ...
   --
   PROCEDURE st_eleminfo IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_eleminfo;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_eleminfo;

   --
   -- test st_numelementinfo case 1: ...
   --
   PROCEDURE st_numelementinfo IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_numelementinfo;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_numelementinfo;

   --
   -- test st_dump case 1: ...
   --
   PROCEDURE st_dump IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_dump;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_dump;

   --
   -- test st_exteriorring case 1: ...
   --
   PROCEDURE st_exteriorring IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_exteriorring;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_exteriorring;

   --
   -- test st_boundary case 1: ...
   --
   PROCEDURE st_boundary IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_boundary;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_boundary;

   --
   -- test st_length case 1: ...
   --
   PROCEDURE st_length IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_length;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_length;

   --
   -- test st_area case 1: ...
   --
   PROCEDURE st_area IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_area;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_area;

   --
   -- test st_distance case 1: ...
   --
   PROCEDURE st_distance IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_distance;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_distance;

   --
   -- test st_relate case 1: ...
   --
   PROCEDURE st_relate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_relate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_relate;

   --
   -- test st_swapordinates case 1: ...
   --
   PROCEDURE st_swapordinates IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_swapordinates;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_swapordinates;

   --
   -- test st_filterrings case 1: ...
   --
   PROCEDURE st_filterrings IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_filterrings;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_filterrings;

   --
   -- test st_removeinnerrings case 1: ...
   --
   PROCEDURE st_removeinnerrings IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_removeinnerrings;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_removeinnerrings;

   --
   -- test st_extract case 1: ...
   --
   PROCEDURE st_extract IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_extract;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_extract;

   --
   -- test st_extractrings case 1: ...
   --
   PROCEDURE st_extractrings IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_extractrings;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_extractrings;

   --
   -- test st_vertices case 1: ...
   --
   PROCEDURE st_vertices IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_vertices;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_vertices;

   --
   -- test st_segmentize case 1: ...
   --
   PROCEDURE st_segmentize IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_segmentize;
            v_distance := p_Segment.ST_Distance(p_vertex => p_vertex,
                                                p_unit   => p_unit);
       p_total_length + p_segment.ST_Length(p_unit=>p_unit)

      -- populate expected

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_segmentize;

   --
   -- test st_flip_segments case 1: ...
   --
   PROCEDURE st_flip_segments IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_flip_segments;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_flip_segments;

   --
   -- test st_rectangle2polygon case 1: ...
   --
   PROCEDURE st_rectangle2polygon IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_rectangle2polygon;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_rectangle2polygon;

   --
   -- test st_polygon2rectangle case 1: ...
   --
   PROCEDURE st_polygon2rectangle IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_polygon2rectangle;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_polygon2rectangle;

   --
   -- test st_diminfo2rectangle case 1: ...
   --
   PROCEDURE st_diminfo2rectangle IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_diminfo2rectangle;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_diminfo2rectangle;

   --
   -- test st_geometry2diminfo case 1: ...
   --
   PROCEDURE st_geometry2diminfo IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_geometry2diminfo;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_geometry2diminfo;

   --
   -- test st_mbr case 1: ...
   --
   PROCEDURE st_mbr IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_mbr;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_mbr;

   --
   -- test st_tomultipoint case 1: ...
   --
   PROCEDURE st_tomultipoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_tomultipoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_tomultipoint;

   --
   -- test st_envelope case 1: ...
   --
   PROCEDURE st_envelope IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_envelope;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_envelope;

   --
   -- test st_polygon2line case 1: ...
   --
   PROCEDURE st_polygon2line IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_polygon2line;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_polygon2line;

   --
   -- test st_multi case 1: ...
   --
   PROCEDURE st_multi IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_multi;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_multi;

   --
   -- test st_append case 1: ...
   --
   PROCEDURE st_append IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_append;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_append;

   --
   -- test st_rotate case 1: ...
   --
   PROCEDURE st_rotate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_rotate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_rotate;

   --
   -- test st_scale case 1: ...
   --
   PROCEDURE st_scale IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_scale;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_scale;

   --
   -- test st_translate case 1: ...
   --
   PROCEDURE st_translate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_translate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_translate;

   --
   -- test st_reflect case 1: ...
   --
   PROCEDURE st_reflect IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_reflect;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_reflect;

   --
   -- test st_rottransscale case 1: ...
   --
   PROCEDURE st_rottransscale IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_rottransscale;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_rottransscale;

   --
   -- test st_affine case 1: ...
   --
   PROCEDURE st_affine IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_affine;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_affine;

   --
   -- test st_fixordinates case 1: ...
   --
   PROCEDURE st_fixordinates IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_fixordinates;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_fixordinates;

   --
   -- test st_vertexn case 1: ...
   --
   PROCEDURE st_vertexn IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_vertexn;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_vertexn;

   --
   -- test st_startvertex case 1: ...
   --
   PROCEDURE st_startvertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_startvertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_startvertex;

   --
   -- test st_endvertex case 1: ...
   --
   PROCEDURE st_endvertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_endvertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_endvertex;

   --
   -- test st_pointn case 1: ...
   --
   PROCEDURE st_pointn IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_pointn;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_pointn;

   --
   -- test st_startpoint case 1: ...
   --
   PROCEDURE st_startpoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_startpoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_startpoint;

   --
   -- test st_endpoint case 1: ...
   --
   PROCEDURE st_endpoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_endpoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_endpoint;

   --
   -- test st_segmentn case 1: ...
   --
   PROCEDURE st_segmentn IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_segmentn;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_segmentn;

   --
   -- test st_startsegment case 1: ...
   --
   PROCEDURE st_startsegment IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_startsegment;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_startsegment;

   --
   -- test st_endsegment case 1: ...
   --
   PROCEDURE st_endsegment IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_endsegment;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_endsegment;

   --
   -- test st_insertvertex case 1: ...
   --
   PROCEDURE st_insertvertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_insertvertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_insertvertex;

   --
   -- test st_updatevertex case 1: ...
   --
   PROCEDURE st_updatevertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_updatevertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_updatevertex;

   --
   -- test st_deletevertex case 1: ...
   --
   PROCEDURE st_deletevertex IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_deletevertex;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_deletevertex;

   --
   -- test st_removeduplicatevertices case 1: ...
   --
   PROCEDURE st_removeduplicatevertices IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_removeduplicatevertices;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_removeduplicatevertices;

   --
   -- test st_extend case 1: ...
   --
   PROCEDURE st_extend IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_extend;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_extend;

   --
   -- test st_reduce case 1: ...
   --
   PROCEDURE st_reduce IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_reduce;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_reduce;

   --
   -- test st_cogo2line case 1: ...
   --
   PROCEDURE st_cogo2line IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_cogo2line;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_cogo2line;

   --
   -- test st_line2cogo case 1: ...
   --
   PROCEDURE st_line2cogo IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_line2cogo;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_line2cogo;

   --
   -- test st_cogo2polygon case 1: ...
   --
   PROCEDURE st_cogo2polygon IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_cogo2polygon;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_cogo2polygon;

   --
   -- test st_travellingsalesman case 1: ...
   --
   PROCEDURE st_travellingsalesman IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_travellingsalesman;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_travellingsalesman;

   --
   -- test st_compress case 1: ...
   --
   PROCEDURE st_compress IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_compress;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_compress;

   --
   -- test st_decompress case 1: ...
   --
   PROCEDURE st_decompress IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_decompress;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_decompress;

   --
   -- test st_sdopoint2ord case 1: ...
   --
   PROCEDURE st_sdopoint2ord IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_sdopoint2ord;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdopoint2ord;

   --
   -- test st_ord2sdopoint case 1: ...
   --
   PROCEDURE st_ord2sdopoint IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_ord2sdopoint;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_ord2sdopoint;

   --
   -- test st_to2d case 1: ...
   --
   PROCEDURE st_to2d IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_to2d;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_to2d;

   --
   -- test st_to3d case 1: ...
   --
   PROCEDURE st_to3d IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_to3d;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_to3d;

   --
   -- test st_fixz case 1: ...
   --
   PROCEDURE st_fixz IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_fixz;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_fixz;

   --
   -- test st_tile case 1: ...
   --
   PROCEDURE st_tile IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_tile;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_tile;

   --
   -- test st_smoothtile case 1: ...
   --
   PROCEDURE st_smoothtile IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_smoothtile;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_smoothtile;

   --
   -- test st_removecollinearpoints case 1: ...
   --
   PROCEDURE st_removecollinearpoints IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_removecollinearpoints;
       v_merged_segment := v_last_segment.ST_Merge(v_segments(i));
        IF ( v_merged_segment.ST_isEmpty()=1
          OR v_merged_segment.midCoord is not null
          OR v_merged_segment.ST_Equals(v_last_segment)=1 ) THEN

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_removecollinearpoints;

   --
   -- test st_densify case 1: ...
   --
   PROCEDURE st_densify IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_densify;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_densify;

   --
   -- test st_lineshift case 1: ...
   --
   PROCEDURE st_lineshift IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lineshift;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lineshift;

   --
   -- test st_parallel case 1: ...
   --
   PROCEDURE st_parallel IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_parallel;
      v_az      := rec.original_Segment.ST_Bearing();
      v_intersection := v_segment.ST_IntersectDetail(

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_parallel;

   --
   -- test st_getoffsetcurve case 1: ...
   --
   PROCEDURE st_getoffsetcurve IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_getoffsetcurve;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_getoffsetcurve;

   --
   -- test st_rectangle case 1: ...
   --
   PROCEDURE st_rectangle IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_rectangle;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_rectangle;

   --
   -- test st_centroid_l case 1: ...
   --
   PROCEDURE st_centroid_l IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_centroid_l;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_centroid_l;

   --
   -- test st_centroid_p case 1: ...
   --
   PROCEDURE st_centroid_p IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_centroid_p;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_centroid_p;

   --
   -- test st_centroid_a case 1: ...
   --
   PROCEDURE st_centroid_a IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_centroid_a;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_centroid_a;

   --
   -- test st_multi_centroid case 1: ...
   --
   PROCEDURE st_multi_centroid IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_multi_centroid;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_multi_centroid;

   --
   -- test st_split_segments case 1: ...
   --
   PROCEDURE st_split_segments IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_split_segments;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_split_segments;

   --
   -- test st_split case 1: ...
   --
   PROCEDURE st_split IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_split;
      
p_Segment.ST_SdoGeometry(SELF.ST_Dims())
      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_split;

   --
   -- test st_snap case 1: ...
   --
   PROCEDURE st_snap IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_snap;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_snap;

   --
   -- test st_snapn case 1: ...
   --
   PROCEDURE st_snapn IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_snapn;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_snapn;

   --
   -- test st_add_segment case 1: ...
   --
   PROCEDURE st_add_segment IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_add_segment;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_add_segment;

   --
   -- test st_reverse_linestring case 1: ...
   --
   PROCEDURE st_reverse_linestring IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_reverse_linestring;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_reverse_linestring;

   --
   -- test st_reverse_geometry case 1: ...
   --
   PROCEDURE st_reverse_geometry IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_reverse_geometry;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_reverse_geometry;

   --
   -- test st_which_side case 1: ...
   --
   PROCEDURE st_which_side IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_which_side;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_which_side;

   --
   -- test st_concat_line case 1: ...
   --
   PROCEDURE st_concat_line IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_concat_line;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_concat_line;

   --
   -- test st_intersection case 1: ...
   --
   PROCEDURE st_intersection IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_intersection;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_intersection;

   --
   -- test st_difference case 1: ...
   --
   PROCEDURE st_difference IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_difference;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_difference;

   --
   -- test st_buffer case 1: ...
   --
   PROCEDURE st_buffer IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_buffer;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_buffer;

   --
   -- test st_squarebuffer case 1: ...
   --
   PROCEDURE st_squarebuffer IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_squarebuffer;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_squarebuffer;

   --
   -- test st_onesidedbuffer case 1: ...
   --
   PROCEDURE st_onesidedbuffer IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_onesidedbuffer;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_onesidedbuffer;

   --
   -- test st_lrs_dim case 1: ...
   --
   PROCEDURE st_lrs_dim IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_dim;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_dim;

   --
   -- test st_lrs_ismeasured case 1: ...
   --
   PROCEDURE st_lrs_ismeasured IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_ismeasured;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_ismeasured;

   --
   -- test st_lrs_get_measure case 1: ...
   --
   PROCEDURE st_lrs_get_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_get_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_get_measure;

   --
   -- test st_lrs_project_point case 1: ...
   --
   PROCEDURE st_lrs_project_point IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_project_point;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_project_point;

   --
   -- test st_lrs_find_measure case 1: ...
   --
   PROCEDURE st_lrs_find_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_find_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_find_measure;

   --
   -- test st_lrs_find_measuren case 1: ...
   --
   PROCEDURE st_lrs_find_measuren IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_find_measuren;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_find_measuren;

   --
   -- test st_lrs_find_offset case 1: ...
   --
   PROCEDURE st_lrs_find_offset IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_find_offset;
segment.ST_FindCircle()
      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_find_offset;

   --
   -- test st_lrs_add_measure case 1: ...
   --
   PROCEDURE st_lrs_add_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_add_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_add_measure;

   --
   -- test st_lrs_update_measures case 1: ...
   --
   PROCEDURE st_lrs_update_measures IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_update_measures;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_update_measures;

   --
   -- test st_lrs_reset_measure case 1: ...
   --
   PROCEDURE st_lrs_reset_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_reset_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_reset_measure;

   --
   -- test st_lrs_reverse_measure case 1: ...
   --
   PROCEDURE st_lrs_reverse_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_reverse_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_reverse_measure;

   --
   -- test st_lrs_scale_measures case 1: ...
   --
   PROCEDURE st_lrs_scale_measures IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_scale_measures;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_scale_measures;

   --
   -- test st_lrs_concatenate case 1: ...
   --
   PROCEDURE st_lrs_concatenate IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_concatenate;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_concatenate;

   --
   -- test st_lrs_start_measure case 1: ...
   --
   PROCEDURE st_lrs_start_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_start_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_start_measure;

   --
   -- test st_lrs_end_measure case 1: ...
   --
   PROCEDURE st_lrs_end_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_end_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_end_measure;

   --
   -- test st_lrs_measure_range case 1: ...
   --
   PROCEDURE st_lrs_measure_range IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_measure_range;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_measure_range;

   --
   -- test st_lrs_is_measure_decreasing case 1: ...
   --
   PROCEDURE st_lrs_is_measure_decreasing IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_is_measure_decreasing;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_is_measure_decreasing;

   --
   -- test st_lrs_is_measure_increasing case 1: ...
   --
   PROCEDURE st_lrs_is_measure_increasing IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_is_measure_increasing;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_is_measure_increasing;

   --
   -- test st_lrs_is_shape_pt_measure case 1: ...
   --
   PROCEDURE st_lrs_is_shape_pt_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_is_shape_pt_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_is_shape_pt_measure;

   --
   -- test st_lrs_measure_to_percentage case 1: ...
   --
   PROCEDURE st_lrs_measure_to_percentage IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_measure_to_percentage;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_measure_to_percentage;

   --
   -- test st_lrs_percentage_to_measure case 1: ...
   --
   PROCEDURE st_lrs_percentage_to_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_percentage_to_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_percentage_to_measure;

   --
   -- test st_lrs_locate_measure case 1: ...
   --
   PROCEDURE st_lrs_locate_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_locate_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_locate_measure;

   --
   -- test st_lrs_locate_point case 1: ...
   --
   PROCEDURE st_lrs_locate_point IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_locate_point;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_locate_point;

   --
   -- test st_lrs_locate_along case 1: ...
   --
   PROCEDURE st_lrs_locate_along IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_locate_along;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_locate_along;

   --
   -- test st_lrs_locate_measures case 1: ...
   --
   PROCEDURE st_lrs_locate_measures IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_locate_measures;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_locate_measures;

   --
   -- test st_lrs_locate_between case 1: ...
   --
   PROCEDURE st_lrs_locate_between IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_locate_between;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_locate_between;

   --
   -- test st_lrs_valid_measure case 1: ...
   --
   PROCEDURE st_lrs_valid_measure IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_valid_measure;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_valid_measure;

   --
   -- test st_lrs_valid_point case 1: ...
   --
   PROCEDURE st_lrs_valid_point IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_valid_point;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_valid_point;

   --
   -- test st_lrs_valid_segment case 1: ...
   --
   PROCEDURE st_lrs_valid_segment IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_valid_segment;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_valid_segment;

   --
   -- test st_lrs_valid_geometry case 1: ...
   --
   PROCEDURE st_lrs_valid_geometry IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_valid_geometry;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_valid_geometry;

   --
   -- test st_lrs_intersection case 1: ...
   --
   PROCEDURE st_lrs_intersection IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_lrs_intersection;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_lrs_intersection;

   --
   -- test st_sdo_point_equal case 1: ...
   --
   PROCEDURE st_sdo_point_equal IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_sdo_point_equal;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_sdo_point_equal;

   --
   -- test st_elem_info_equal case 1: ...
   --
   PROCEDURE st_elem_info_equal IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_elem_info_equal;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_elem_info_equal;

   --
   -- test st_ordinates_equal case 1: ...
   --
   PROCEDURE st_ordinates_equal IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_ordinates_equal;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_ordinates_equal;

   --
   -- test st_equals case 1: ...
   --
   PROCEDURE st_equals IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.st_equals;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END st_equals;

   --
   -- test orderby case 1: ...
   --
   PROCEDURE orderby IS
      l_actual   INTEGER := 0;
      l_expected INTEGER := 1;
   BEGIN
      -- populate actual
      -- t_geometry.orderby;

      -- populate expected
      -- ...

      -- assert
      ut.expect(l_actual).to_equal(l_expected);
   END orderby;

END test_t_geometry;
/
show errors

set serveroutput on size unlimited
set long 800
set linesize 800
begin ut.run('test_t_geometry'); end;


/*
Test:

1. Constructors.
2. ST_Release
ST_SetProjection
ST_SetSdoGtype
ST_SetSrid
ST_SetPrecision
ST_SetTolerance
Nothing till...
ST_AsEWKT
ST_isEmpty
ST_isClosed
ST_NumSegments
ST_Dimension
ST_hasDimension


'<gml:Polygon srsName="SDO:" xmlns:gml="http://www.opengis.net/gml"><gml:exterior><gml:LinearRing><gml:posList srsDimension="2">5.0 1.0 8.0 1.0 8.0 6.0 5.0 7.0 5.0 1.0</gml:posList></gml:LinearRing></gml:exterior></gml:Polygon>'
'<gml:Polygon srsName="SDO:" xmlns:gml="http://www.opengis.net/gml"><gml:outerBoundaryIs><gml:LinearRing><gml:coordinates decimal="." cs="," ts=" ">5.0,1.0 8.0,1.0 8.0,6.0 5.0,7.0 5.0,1.0</gml:coordinates></gml:LinearRing></gml:outerBoundaryIs></gml:Polygon>'

'POINTZ (-123.08963356 49.27575579 70)'
select spdba.t_geometry(TO_CLOB('POINTZ (-123.08963356 49.27575579 70)')).geom from dual;
'SRID=28355;POINTZ (-123.08963356 49.27575579 70)'
select spdba.t_geometry(TO_CLOB('SRID=28355;POINTZ (-123.08963356 49.27575579 70)')).geom from dual;

'LINESTRING (1 1,2 1,3 1)'
'LINESTRING M (1 1 20,2 1 30,3 1 40)'
'LINESTRING Z (1 1 20,2 1 30,3 1 40)'
'LINESTRING ZM (1 1 20 0,2 1 30 10,3 1 40 20)'
'POLYGON Z ((0 0 10,0 1 20,1 1 30,1 0 40,0 0 10))'
'SRID=8307;LINESTRING Z ((0 0 10,0 1 20,1 1 30,1 0 40))'
'SRID=8307;POLYGON Z ((0 0 10,0 1 20,1 1 30,1 0 40,0 0 10))'
SDO_GEOMETRY(2001,28355,sdo_point_type(1,1,NULL),NULL,NULL)
SDO_GEOMETRY(2001, 8307,sdo_point_type(147.5,-32.7,NULL),NULL,NULL)
SDO_GEOMETRY(2001, NULL,sdo_point_type(147.5,-32.7,NULL),NULL,NULL)
SDO_GEOMETRY(2002,28355,NULL,SDO_ELEM_INFO_ARRAY(1,2,1),SDO_ORDINATE_ARRAY(1,1,2,1,3,1))
SDO_GEOMETRY(3001,28355,sdo_point_type(1,1,1),NULL,NULL)
SDO_GEOMETRY(3001, NULL,sdo_point_type(1,1,1),NULL,NULL)
SDO_GEOMETRY(3003, 8307,NULL,SDO_ELEM_INFO_ARRAY(1,1003,1),SDO_ORDINATE_ARRAY(0,0,10,1,0,40,1,1,30,0,1,20,0,0,10))

*/
